<!DOCTYPE html><html lang="en"><head><meta charSet="utf-8"/><meta name="viewport" content="width=device-width, initial-scale=1"/><link rel="preload" href="/_next/static/media/4cf2300e9c8272f7-s.p.woff2" as="font" type="font/woff2"/><link rel="preload" href="/_next/static/media/93f479601ee12b01-s.p.woff2" as="font" type="font/woff2"/><link rel="stylesheet" href="static/css/de70bee13400563f.css" data-precedence="next"/><link rel="stylesheet" href="static/css/b54d92a85d180acc.css" data-precedence="next"/><link rel="preload" as="script" fetchPriority="low" href="static/js/webpack-5400bf868d87f903.js"/><script src="static/js/87c73c54-dd8d81ac9604067c.js" async=""></script><script src="static/js/18-fb3b55923571b003.js" async=""></script><script src="static/js/main-app-57aa1716f0d0f500.js" async=""></script><script src="static/js/b1298b8d-5cac6cd7c8e952ff.js" async=""></script><script src="static/js/378e5a93-860e027c5a5e0c0d.js" async=""></script><script src="static/js/f7f68e2d-d8bf979db5ff4e9d.js" async=""></script><script src="static/js/7963-2c20578d72f6c7cc.js" async=""></script><script src="static/js/1265-fa8a95d3842768f5.js" async=""></script><script src="static/js/9885-b57089f03806c3b8.js" async=""></script><script src="static/js/659-ee9e1e775e30dcef.js" async=""></script><script src="static/js/layout-0537c2076823e553.js" async=""></script><script src="static/js/7bf36345-1ac10ec2f0e0c88f.js" async=""></script><script src="static/js/c16f53c3-b390b6f98a69dcec.js" async=""></script><script src="static/js/6212-505c2fc95d1a35ae.js" async=""></script><script src="static/js/4336-624d5ae6f4cc1cc7.js" async=""></script><script src="static/js/8461-369a9f0c48ea2626.js" async=""></script><script src="static/js/7198-985a49f2b6072d25.js" async=""></script><script src="static/js/1170-02491c90c1c0890e.js" async=""></script><script src="static/js/4429-92c77bf2d3e82e1c.js" async=""></script><script src="static/js/9976-e70b787a4dd08fcf.js" async=""></script><script src="static/js/1481-25d5bbc4f2d9524a.js" async=""></script><script src="static/js/page-9dfe5afb3c44861e.js" async=""></script><script src="static/js/25-9f305b682cea7558.js" async=""></script><script src="static/js/7391-cea3fe9ac7162130.js" async=""></script><script src="static/js/6373-d56a493968555802.js" async=""></script><script src="static/js/6375-7e0e75eb09fc9abe.js" async=""></script><script src="static/js/9437-00f165dda9ad3a42.js" async=""></script><script src="static/js/layout-cecfb9eee640deb0.js" async=""></script><meta name="next-size-adjust" content=""/><title>Key Expansion | QinMoMeak/Simple_FingerPrint_Matching | DeepWiki</title><meta name="description" content="This document explains the AES key expansion algorithm implemented in $1. The key expansion process transforms an original cipher key (128, 192, or 256 bits) into a schedule of round keys used during "/><meta name="keywords" content="QinMoMeak/Simple_FingerPrint_Matching,QinMoMeak,Simple_FingerPrint_Matching,documentation,wiki,codebase,AI documentation,Devin,Key Expansion"/><link rel="canonical" href="https://deepwiki.com/QinMoMeak/Simple_FingerPrint_Matching/2.1-key-expansion"/><meta property="og:title" content="Key Expansion | QinMoMeak/Simple_FingerPrint_Matching | DeepWiki"/><meta property="og:description" content="This document explains the AES key expansion algorithm implemented in $1. The key expansion process transforms an original cipher key (128, 192, or 256 bits) into a schedule of round keys used during "/><meta property="og:url" content="https://deepwiki.com/QinMoMeak/Simple_FingerPrint_Matching/2.1-key-expansion"/><meta property="og:site_name" content="DeepWiki"/><meta property="og:image" content="https://deepwiki.com/QinMoMeak/Simple_FingerPrint_Matching/og-image.png?page=2.1"/><meta property="og:type" content="website"/><meta name="twitter:card" content="summary_large_image"/><meta name="twitter:site" content="@cognition"/><meta name="twitter:creator" content="@cognition"/><meta name="twitter:title" content="Key Expansion | QinMoMeak/Simple_FingerPrint_Matching | DeepWiki"/><meta name="twitter:description" content="This document explains the AES key expansion algorithm implemented in $1. The key expansion process transforms an original cipher key (128, 192, or 256 bits) into a schedule of round keys used during "/><meta name="twitter:image" content="https://deepwiki.com/QinMoMeak/Simple_FingerPrint_Matching/og-image.png?page=2.1"/><link rel="icon" href="/favicon.ico" type="image/x-icon" sizes="48x48"/><link rel="icon" href="/icon.png?1ee4c6a68a73a205" type="image/png" sizes="48x48"/><link rel="apple-touch-icon" href="/apple-icon.png?a4f658907db0ab87" type="image/png" sizes="180x180"/><script src="static/js/polyfills-42372ed130431b0a.js" noModule=""></script></head><body class="__variable_188709 font-geist-sans relative min-h-screen __variable_9a8899 bg-background antialiased"><div hidden=""><!--$--><!--/$--></div><section aria-label="Notifications alt+T" tabindex="-1" aria-live="polite" aria-relevant="additions text" aria-atomic="false"></section><script>((a,b,c,d,e,f,g,h)=>{let i=document.documentElement,j=["light","dark"];function k(b){var c;(Array.isArray(a)?a:[a]).forEach(a=>{let c="class"===a,d=c&&f?e.map(a=>f[a]||a):e;c?(i.classList.remove(...d),i.classList.add(f&&f[b]?f[b]:b)):i.setAttribute(a,b)}),c=b,h&&j.includes(c)&&(i.style.colorScheme=c)}if(d)k(d);else try{let a=localStorage.getItem(b)||c,d=g&&"system"===a?window.matchMedia("(prefers-color-scheme: dark)").matches?"dark":"light":a;k(d)}catch(a){}})("class","theme","light",null,["light","dark"],null,true,true)</script><!--$?--><template id="B:0"></template><div class="flex min-h-screen w-full flex-col text-white"><div class="container-wrapper flex flex-1 items-center justify-center px-4"><div class="inline-block bg-clip-text text-[#b5b5b5a4] animate-shine text-center text-lg" style="background-image:linear-gradient(120deg, rgba(255, 255, 255, 0) 40%, rgba(255, 255, 255, 0.8) 50%, rgba(255, 255, 255, 0) 60%);background-size:200% 100%;-webkit-background-clip:text;animation-duration:1s">Loading...</div></div></div><!--/$--><script>requestAnimationFrame(function(){$RT=performance.now()});</script><script src="static/js/webpack-5400bf868d87f903.js" id="_R_" async=""></script><div hidden id="S:0"><div class="flex min-h-screen w-full flex-col text-white" id="codebase-wiki-repo-page"><div class="bg-background border-b-border sticky top-0 z-30 border-b border-dashed"><div class="font-geist-mono relative flex h-8 items-center justify-center text-xs font-medium sm:hidden"><div class="powered-by-devin-gradient absolute inset-0 z-[-1] h-8 w-full"></div><button class="flex items-center gap-2"><svg class="size-3 [&amp;_path]:stroke-0 [&amp;_path]:animate-[custom-pulse_1.8s_infinite_var(--delay,0s)]" xmlns="http://www.w3.org/2000/svg" viewBox="110 110 460 500"><path style="fill:#21c19a" class="[--delay:0.6s]" d="M418.73,332.37c9.84-5.68,22.07-5.68,31.91,0l25.49,14.71c.82.48,1.69.8,2.58,1.06.19.06.37.11.55.16.87.21,1.76.34,2.65.35.04,0,.08.02.13.02.1,0,.19-.03.29-.04.83-.02,1.64-.13,2.45-.32.14-.03.28-.05.42-.09.87-.24,1.7-.59,2.5-1.03.08-.04.17-.06.25-.1l50.97-29.43c3.65-2.11,5.9-6.01,5.9-10.22v-58.86c0-4.22-2.25-8.11-5.9-10.22l-50.97-29.43c-3.65-2.11-8.15-2.11-11.81,0l-50.97,29.43c-.08.04-.13.11-.2.16-.78.48-1.51,1.02-2.15,1.66-.1.1-.18.21-.28.31-.57.6-1.08,1.26-1.51,1.97-.07.12-.15.22-.22.34-.44.77-.77,1.6-1.03,2.47-.05.19-.1.37-.14.56-.22.89-.37,1.81-.37,2.76v29.43c0,11.36-6.11,21.95-15.95,27.63-9.84,5.68-22.06,5.68-31.91,0l-25.49-14.71c-.82-.48-1.69-.8-2.57-1.06-.19-.06-.37-.11-.56-.16-.88-.21-1.76-.34-2.65-.34-.13,0-.26.02-.4.02-.84.02-1.66.13-2.47.32-.13.03-.27.05-.4.09-.87.24-1.71.6-2.51,1.04-.08.04-.16.06-.24.1l-50.97,29.43c-3.65,2.11-5.9,6.01-5.9,10.22v58.86c0,4.22,2.25,8.11,5.9,10.22l50.97,29.43c.08.04.17.06.24.1.8.44,1.64.79,2.5,1.03.14.04.28.06.42.09.81.19,1.62.3,2.45.32.1,0,.19.04.29.04.04,0,.08-.02.13-.02.89,0,1.77-.13,2.65-.35.19-.04.37-.1.56-.16.88-.26,1.75-.59,2.58-1.06l25.49-14.71c9.84-5.68,22.06-5.68,31.91,0,9.84,5.68,15.95,16.27,15.95,27.63v29.43c0,.95.15,1.87.37,2.76.05.19.09.37.14.56.25.86.59,1.69,1.03,2.47.07.12.15.22.22.34.43.71.94,1.37,1.51,1.97.1.1.18.21.28.31.65.63,1.37,1.18,2.15,1.66.07.04.13.11.2.16l50.97,29.43c1.83,1.05,3.86,1.58,5.9,1.58s4.08-.53,5.9-1.58l50.97-29.43c3.65-2.11,5.9-6.01,5.9-10.22v-58.86c0-4.22-2.25-8.11-5.9-10.22l-50.97-29.43c-.08-.04-.16-.06-.24-.1-.8-.44-1.64-.8-2.51-1.04-.13-.04-.26-.05-.39-.09-.82-.2-1.65-.31-2.49-.33-.13,0-.25-.02-.38-.02-.89,0-1.78.13-2.66.35-.18.04-.36.1-.54.15-.88.26-1.75.59-2.58,1.07l-25.49,14.72c-9.84,5.68-22.07,5.68-31.9,0-9.84-5.68-15.95-16.27-15.95-27.63s6.11-21.95,15.95-27.63Z"></path><path style="fill:#3969ca" d="M141.09,317.65l50.97,29.43c1.83,1.05,3.86,1.58,5.9,1.58s4.08-.53,5.9-1.58l50.97-29.43c.08-.04.13-.11.2-.16.78-.48,1.51-1.02,2.15-1.66.1-.1.18-.21.28-.31.57-.6,1.08-1.26,1.51-1.97.07-.12.15-.22.22-.34.44-.77.77-1.6,1.03-2.47.05-.19.1-.37.14-.56.22-.89.37-1.81.37-2.76v-29.43c0-11.36,6.11-21.95,15.96-27.63s22.06-5.68,31.91,0l25.49,14.71c.82.48,1.69.8,2.57,1.06.19.06.37.11.56.16.87.21,1.76.34,2.64.35.04,0,.09.02.13.02.1,0,.19-.04.29-.04.83-.02,1.65-.13,2.45-.32.14-.03.28-.05.41-.09.87-.24,1.71-.6,2.51-1.04.08-.04.16-.06.24-.1l50.97-29.43c3.65-2.11,5.9-6.01,5.9-10.22v-58.86c0-4.22-2.25-8.11-5.9-10.22l-50.97-29.43c-3.65-2.11-8.15-2.11-11.81,0l-50.97,29.43c-.08.04-.13.11-.2.16-.78.48-1.51,1.02-2.15,1.66-.1.1-.18.21-.28.31-.57.6-1.08,1.26-1.51,1.97-.07.12-.15.22-.22.34-.44.77-.77,1.6-1.03,2.47-.05.19-.1.37-.14.56-.22.89-.37,1.81-.37,2.76v29.43c0,11.36-6.11,21.95-15.95,27.63-9.84,5.68-22.07,5.68-31.91,0l-25.49-14.71c-.82-.48-1.69-.8-2.58-1.06-.19-.06-.37-.11-.55-.16-.88-.21-1.76-.34-2.65-.35-.13,0-.26.02-.4.02-.83.02-1.66.13-2.47.32-.13.03-.27.05-.4.09-.87.24-1.71.6-2.51,1.04-.08.04-.16.06-.24.1l-50.97,29.43c-3.65,2.11-5.9,6.01-5.9,10.22v58.86c0,4.22,2.25,8.11,5.9,10.22Z"></path><path style="fill:#0294de" class="[--delay:1.2s]" d="M396.88,484.35l-50.97-29.43c-.08-.04-.17-.06-.24-.1-.8-.44-1.64-.79-2.51-1.03-.14-.04-.27-.06-.41-.09-.81-.19-1.64-.3-2.47-.32-.13,0-.26-.02-.39-.02-.89,0-1.78.13-2.66.35-.18.04-.36.1-.54.15-.88.26-1.76.59-2.58,1.07l-25.49,14.72c-9.84,5.68-22.06,5.68-31.9,0-9.84-5.68-15.96-16.27-15.96-27.63v-29.43c0-.95-.15-1.87-.37-2.76-.05-.19-.09-.37-.14-.56-.25-.86-.59-1.69-1.03-2.47-.07-.12-.15-.22-.22-.34-.43-.71-.94-1.37-1.51-1.97-.1-.1-.18-.21-.28-.31-.65-.63-1.37-1.18-2.15-1.66-.07-.04-.13-.11-.2-.16l-50.97-29.43c-3.65-2.11-8.15-2.11-11.81,0l-50.97,29.43c-3.65,2.11-5.9,6.01-5.9,10.22v58.86c0,4.22,2.25,8.11,5.9,10.22l50.97,29.43c.08.04.17.06.25.1.8.44,1.63.79,2.5,1.03.14.04.29.06.43.09.8.19,1.61.3,2.43.32.1,0,.2.04.3.04.04,0,.09-.02.13-.02.88,0,1.77-.13,2.64-.34.19-.04.37-.1.56-.16.88-.26,1.75-.59,2.57-1.06l25.49-14.71c9.84-5.68,22.06-5.68,31.91,0,9.84,5.68,15.95,16.27,15.95,27.63v29.43c0,.95.15,1.87.37,2.76.05.19.09.37.14.56.25.86.59,1.69,1.03,2.47.07.12.15.22.22.34.43.71.94,1.37,1.51,1.97.1.1.18.21.28.31.65.63,1.37,1.18,2.15,1.66.07.04.13.11.2.16l50.97,29.43c1.83,1.05,3.86,1.58,5.9,1.58s4.08-.53,5.9-1.58l50.97-29.43c3.65-2.11,5.9-6.01,5.9-10.22v-58.86c0-4.22-2.25-8.11-5.9-10.22Z"></path></svg>Index your code with Devin</button></div><div class="container-wrapper"><div class="container mx-auto flex w-full flex-row items-center gap-2 py-4 md:py-6"><a class="flex items-center gap-3" href="/"><span class="text-base font-medium leading-none md:text-lg hidden sm:block">DeepWiki</span></a><div class="flex-1"><div class="flex flex-row items-center gap-2"><a class="block text-xs font-medium leading-none text-white sm:hidden md:text-lg" href="/">DeepWiki</a><p class="text-sm font-normal leading-none md:text-lg"><a href="https://github.com/QinMoMeak/Simple_FingerPrint_Matching" target="_blank" rel="noopener noreferrer" title="Open repository" class="text-muted-foreground hover:text-muted-foreground/80 group inline-flex items-center gap-1 transition-colors">QinMoMeak/Simple_FingerPrint_Matching<!-- --> <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" viewBox="0 0 256 256" class="opacity-0 transition-opacity group-hover:opacity-100"><path d="M224,104a8,8,0,0,1-16,0V59.32l-66.33,66.34a8,8,0,0,1-11.32-11.32L196.68,48H152a8,8,0,0,1,0-16h64a8,8,0,0,1,8,8Zm-40,24a8,8,0,0,0-8,8v72H48V80h72a8,8,0,0,0,0-16H48A16,16,0,0,0,32,80V208a16,16,0,0,0,16,16H176a16,16,0,0,0,16-16V136A8,8,0,0,0,184,128Z"></path></svg></a></p></div></div><div class="flex items-center gap-4"><button class="group hidden items-center gap-1.5 md:flex"><div class="relative"><span class="text-foreground/70 group-hover:text-foreground text-xs font-light transition-colors">Index your code with</span><div class="bg-foreground/30 absolute bottom-0 left-0 h-[1px] w-0 transition-all duration-300 group-hover:w-full"></div></div><div class="flex items-center gap-1 transition-transform duration-300 group-hover:translate-x-0.5"><svg class="size-4 transform transition-transform duration-700 group-hover:rotate-180 [&amp;_path]:stroke-0" xmlns="http://www.w3.org/2000/svg" viewBox="110 110 460 500"><path style="fill:#21c19a" class="" d="M418.73,332.37c9.84-5.68,22.07-5.68,31.91,0l25.49,14.71c.82.48,1.69.8,2.58,1.06.19.06.37.11.55.16.87.21,1.76.34,2.65.35.04,0,.08.02.13.02.1,0,.19-.03.29-.04.83-.02,1.64-.13,2.45-.32.14-.03.28-.05.42-.09.87-.24,1.7-.59,2.5-1.03.08-.04.17-.06.25-.1l50.97-29.43c3.65-2.11,5.9-6.01,5.9-10.22v-58.86c0-4.22-2.25-8.11-5.9-10.22l-50.97-29.43c-3.65-2.11-8.15-2.11-11.81,0l-50.97,29.43c-.08.04-.13.11-.2.16-.78.48-1.51,1.02-2.15,1.66-.1.1-.18.21-.28.31-.57.6-1.08,1.26-1.51,1.97-.07.12-.15.22-.22.34-.44.77-.77,1.6-1.03,2.47-.05.19-.1.37-.14.56-.22.89-.37,1.81-.37,2.76v29.43c0,11.36-6.11,21.95-15.95,27.63-9.84,5.68-22.06,5.68-31.91,0l-25.49-14.71c-.82-.48-1.69-.8-2.57-1.06-.19-.06-.37-.11-.56-.16-.88-.21-1.76-.34-2.65-.34-.13,0-.26.02-.4.02-.84.02-1.66.13-2.47.32-.13.03-.27.05-.4.09-.87.24-1.71.6-2.51,1.04-.08.04-.16.06-.24.1l-50.97,29.43c-3.65,2.11-5.9,6.01-5.9,10.22v58.86c0,4.22,2.25,8.11,5.9,10.22l50.97,29.43c.08.04.17.06.24.1.8.44,1.64.79,2.5,1.03.14.04.28.06.42.09.81.19,1.62.3,2.45.32.1,0,.19.04.29.04.04,0,.08-.02.13-.02.89,0,1.77-.13,2.65-.35.19-.04.37-.1.56-.16.88-.26,1.75-.59,2.58-1.06l25.49-14.71c9.84-5.68,22.06-5.68,31.91,0,9.84,5.68,15.95,16.27,15.95,27.63v29.43c0,.95.15,1.87.37,2.76.05.19.09.37.14.56.25.86.59,1.69,1.03,2.47.07.12.15.22.22.34.43.71.94,1.37,1.51,1.97.1.1.18.21.28.31.65.63,1.37,1.18,2.15,1.66.07.04.13.11.2.16l50.97,29.43c1.83,1.05,3.86,1.58,5.9,1.58s4.08-.53,5.9-1.58l50.97-29.43c3.65-2.11,5.9-6.01,5.9-10.22v-58.86c0-4.22-2.25-8.11-5.9-10.22l-50.97-29.43c-.08-.04-.16-.06-.24-.1-.8-.44-1.64-.8-2.51-1.04-.13-.04-.26-.05-.39-.09-.82-.2-1.65-.31-2.49-.33-.13,0-.25-.02-.38-.02-.89,0-1.78.13-2.66.35-.18.04-.36.1-.54.15-.88.26-1.75.59-2.58,1.07l-25.49,14.72c-9.84,5.68-22.07,5.68-31.9,0-9.84-5.68-15.95-16.27-15.95-27.63s6.11-21.95,15.95-27.63Z"></path><path style="fill:#3969ca" d="M141.09,317.65l50.97,29.43c1.83,1.05,3.86,1.58,5.9,1.58s4.08-.53,5.9-1.58l50.97-29.43c.08-.04.13-.11.2-.16.78-.48,1.51-1.02,2.15-1.66.1-.1.18-.21.28-.31.57-.6,1.08-1.26,1.51-1.97.07-.12.15-.22.22-.34.44-.77.77-1.6,1.03-2.47.05-.19.1-.37.14-.56.22-.89.37-1.81.37-2.76v-29.43c0-11.36,6.11-21.95,15.96-27.63s22.06-5.68,31.91,0l25.49,14.71c.82.48,1.69.8,2.57,1.06.19.06.37.11.56.16.87.21,1.76.34,2.64.35.04,0,.09.02.13.02.1,0,.19-.04.29-.04.83-.02,1.65-.13,2.45-.32.14-.03.28-.05.41-.09.87-.24,1.71-.6,2.51-1.04.08-.04.16-.06.24-.1l50.97-29.43c3.65-2.11,5.9-6.01,5.9-10.22v-58.86c0-4.22-2.25-8.11-5.9-10.22l-50.97-29.43c-3.65-2.11-8.15-2.11-11.81,0l-50.97,29.43c-.08.04-.13.11-.2.16-.78.48-1.51,1.02-2.15,1.66-.1.1-.18.21-.28.31-.57.6-1.08,1.26-1.51,1.97-.07.12-.15.22-.22.34-.44.77-.77,1.6-1.03,2.47-.05.19-.1.37-.14.56-.22.89-.37,1.81-.37,2.76v29.43c0,11.36-6.11,21.95-15.95,27.63-9.84,5.68-22.07,5.68-31.91,0l-25.49-14.71c-.82-.48-1.69-.8-2.58-1.06-.19-.06-.37-.11-.55-.16-.88-.21-1.76-.34-2.65-.35-.13,0-.26.02-.4.02-.83.02-1.66.13-2.47.32-.13.03-.27.05-.4.09-.87.24-1.71.6-2.51,1.04-.08.04-.16.06-.24.1l-50.97,29.43c-3.65,2.11-5.9,6.01-5.9,10.22v58.86c0,4.22,2.25,8.11,5.9,10.22Z"></path><path style="fill:#0294de" class="" d="M396.88,484.35l-50.97-29.43c-.08-.04-.17-.06-.24-.1-.8-.44-1.64-.79-2.51-1.03-.14-.04-.27-.06-.41-.09-.81-.19-1.64-.3-2.47-.32-.13,0-.26-.02-.39-.02-.89,0-1.78.13-2.66.35-.18.04-.36.1-.54.15-.88.26-1.76.59-2.58,1.07l-25.49,14.72c-9.84,5.68-22.06,5.68-31.9,0-9.84-5.68-15.96-16.27-15.96-27.63v-29.43c0-.95-.15-1.87-.37-2.76-.05-.19-.09-.37-.14-.56-.25-.86-.59-1.69-1.03-2.47-.07-.12-.15-.22-.22-.34-.43-.71-.94-1.37-1.51-1.97-.1-.1-.18-.21-.28-.31-.65-.63-1.37-1.18-2.15-1.66-.07-.04-.13-.11-.2-.16l-50.97-29.43c-3.65-2.11-8.15-2.11-11.81,0l-50.97,29.43c-3.65,2.11-5.9,6.01-5.9,10.22v58.86c0,4.22,2.25,8.11,5.9,10.22l50.97,29.43c.08.04.17.06.25.1.8.44,1.63.79,2.5,1.03.14.04.29.06.43.09.8.19,1.61.3,2.43.32.1,0,.2.04.3.04.04,0,.09-.02.13-.02.88,0,1.77-.13,2.64-.34.19-.04.37-.1.56-.16.88-.26,1.75-.59,2.57-1.06l25.49-14.71c9.84-5.68,22.06-5.68,31.91,0,9.84,5.68,15.95,16.27,15.95,27.63v29.43c0,.95.15,1.87.37,2.76.05.19.09.37.14.56.25.86.59,1.69,1.03,2.47.07.12.15.22.22.34.43.71.94,1.37,1.51,1.97.1.1.18.21.28.31.65.63,1.37,1.18,2.15,1.66.07.04.13.11.2.16l50.97,29.43c1.83,1.05,3.86,1.58,5.9,1.58s4.08-.53,5.9-1.58l50.97-29.43c3.65-2.11,5.9-6.01,5.9-10.22v-58.86c0-4.22-2.25-8.11-5.9-10.22Z"></path></svg><span class="text-sm font-medium">Devin</span></div></button><button aria-label="Edit Wiki" class="flex items-center rounded-md cursor-pointer transition-all border border-border bg-surface hover:border-border-hover hover:bg-component disabled:cursor-default disabled:opacity-50 disabled:hover:border-border disabled:hover:bg-surface gap-2 px-3 py-1.5 text-sm"><svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" fill="currentColor" viewBox="0 0 256 256"><path d="M227.32,73.37,182.63,28.69a16,16,0,0,0-22.63,0L36.69,152A15.86,15.86,0,0,0,32,163.31V208a16,16,0,0,0,16,16H216a8,8,0,0,0,0-16H115.32l112-112A16,16,0,0,0,227.32,73.37ZM92.69,208H48V163.31l88-88L180.69,120ZM192,108.69,147.32,64l24-24L216,84.69Z"></path></svg>Edit Wiki</button><button class="flex items-center rounded-md !text-white cursor-pointer transition-all border bg-blue-500 hover:bg-blue-600 border-blue-500 hover:border-blue-600 dark:bg-blue-900 dark:hover:bg-blue-800 dark:border-blue-900 dark:hover:border-blue-800 disabled:cursor-default disabled:opacity-50 disabled:hover:bg-blue-500 disabled:hover:border-blue-500 dark:disabled:hover:bg-blue-900 dark:disabled:hover:border-blue-900 gap-1.5 px-3 py-1.5 text-sm" aria-label="Share" data-state="closed" data-slot="tooltip-trigger"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="h-4 w-4"><circle cx="18" cy="5" r="3"></circle><circle cx="6" cy="12" r="3"></circle><circle cx="18" cy="19" r="3"></circle><line x1="8.59" y1="13.51" x2="15.42" y2="17.49"></line><line x1="15.41" y1="6.51" x2="8.59" y2="10.49"></line></svg><span>Share</span></button><div class="h-8 w-8"></div></div></div></div></div><!--$?--><template id="B:1"></template><div class="container-wrapper flex flex-1 items-center justify-center px-4"><div class="inline-block bg-clip-text text-[#b5b5b5a4] animate-shine text-center text-lg" style="background-image:linear-gradient(120deg, rgba(255, 255, 255, 0) 40%, rgba(255, 255, 255, 0.8) 50%, rgba(255, 255, 255, 0) 60%);background-size:200% 100%;-webkit-background-clip:text;animation-duration:1s">Loading...</div></div><!--/$--></div></div><script>$RB=[];$RV=function(a){$RT=performance.now();for(var b=0;b<a.length;b+=2){var c=a[b],e=a[b+1];null!==e.parentNode&&e.parentNode.removeChild(e);var f=c.parentNode;if(f){var g=c.previousSibling,h=0;do{if(c&&8===c.nodeType){var d=c.data;if("/$"===d||"/&"===d)if(0===h)break;else h--;else"$"!==d&&"$?"!==d&&"$~"!==d&&"$!"!==d&&"&"!==d||h++}d=c.nextSibling;f.removeChild(c);c=d}while(c);for(;e.firstChild;)f.insertBefore(e.firstChild,c);g.data="$";g._reactRetry&&requestAnimationFrame(g._reactRetry)}}a.length=0};
$RC=function(a,b){if(b=document.getElementById(b))(a=document.getElementById(a))?(a.previousSibling.data="$~",$RB.push(a,b),2===$RB.length&&("number"!==typeof $RT?requestAnimationFrame($RV.bind(null,$RB)):(a=performance.now(),setTimeout($RV.bind(null,$RB),2300>a&&2E3<a?2300-a:$RT+300-a)))):b.parentNode.removeChild(b)};$RC("B:0","S:0")</script><div hidden id="S:1"><script type="application/ld+json">{"@context":"https://schema.org","@type":"TechArticle","headline":"Key Expansion","description":"This document explains the AES key expansion algorithm implemented in $1. The key expansion process transforms an original cipher key (128, 192, or 256 bits) into a schedule of round keys used during ","image":"https://deepwiki.com/QinMoMeak/Simple_FingerPrint_Matching/og-image.png","datePublished":"2026-02-19T03:40:37.381719","dateModified":"2026-02-19T03:40:37.381719","author":{"@type":"Organization","name":"DeepWiki","url":"https://deepwiki.com"},"publisher":{"@type":"Organization","name":"DeepWiki","logo":{"@type":"ImageObject","url":"https://deepwiki.com/icon.png"}},"mainEntityOfPage":{"@type":"WebPage","@id":"https://deepwiki.com/QinMoMeak/Simple_FingerPrint_Matching/2.1-key-expansion"}}</script><div class="w-full flex-1"><div class="container-wrapper relative mx-auto h-full px-0"><div class="container relative mx-auto flex h-full w-full flex-col gap-0 max-md:!px-0 md:flex-row md:gap-6 lg:gap-10"><div class="border-r-border hidden max-h-screen border-r border-dashed py-6 pr-4 transition-[border-radius] md:sticky md:left-0 md:top-20 md:block md:h-[calc(100vh-82px)] md:w-64 md:flex-shrink-0 md:overflow-y-auto lg:py-9 xl:w-72"><div class="flex h-full w-full max-w-full flex-shrink-0 flex-col overflow-hidden" style="scrollbar-color:var(--color-border) transparent"><div class="flex-shrink-0 px-2"><div class="text-secondary pb-1 text-xs">Last indexed: <!-- -->19 February 2026<!-- --> (<a href="https://github.com/QinMoMeak/Simple_FingerPrint_Matching/commits/5cdd0b1a" target="_blank" rel="noopener noreferrer" class="underline-offset-2 hover:underline">5cdd0b</a>)</div></div><ul class="flex-1 flex-shrink-0 space-y-1 overflow-y-auto py-1" style="scrollbar-width:none"><li style="padding-left:0"><a data-selected="false" class="hover:bg-hover block w-full rounded px-2 py-1.5 text-left text-sm transition-none text-secondary data-[selected=true]:bg-hover data-[selected=true]:text-primary font-normal data-[selected=true]:font-normal" href="1-overview.html">Overview</a></li><li style="padding-left:12px"><a data-selected="false" class="hover:bg-hover block w-full rounded px-2 py-1.5 text-left text-sm transition-none text-secondary data-[selected=true]:bg-hover data-[selected=true]:text-primary font-normal data-[selected=true]:font-normal" href="1.1-system-architecture.html">System Architecture</a></li><li style="padding-left:12px"><a data-selected="false" class="hover:bg-hover block w-full rounded px-2 py-1.5 text-left text-sm transition-none text-secondary data-[selected=true]:bg-hover data-[selected=true]:text-primary font-normal data-[selected=true]:font-normal" href="1.2-data-files-and-dependencies.html">Data Files and Dependencies</a></li><li style="padding-left:0"><a data-selected="false" class="hover:bg-hover block w-full rounded px-2 py-1.5 text-left text-sm transition-none text-secondary data-[selected=true]:bg-hover data-[selected=true]:text-primary font-normal data-[selected=true]:font-normal" href="2-aes-encryption-system.html">AES Encryption System</a></li><li style="padding-left:12px"><a data-selected="true" class="hover:bg-hover block w-full rounded px-2 py-1.5 text-left text-sm transition-none text-secondary data-[selected=true]:bg-hover data-[selected=true]:text-primary font-normal data-[selected=true]:font-normal" href="2.1-key-expansion.html">Key Expansion</a></li><li style="padding-left:12px"><a data-selected="false" class="hover:bg-hover block w-full rounded px-2 py-1.5 text-left text-sm transition-none text-secondary data-[selected=true]:bg-hover data-[selected=true]:text-primary font-normal data-[selected=true]:font-normal" href="2.2-encryption-process.html">Encryption Process</a></li><li style="padding-left:24px"><a data-selected="false" class="hover:bg-hover block w-full rounded px-2 py-1.5 text-left text-sm transition-none text-secondary data-[selected=true]:bg-hover data-[selected=true]:text-primary font-normal data-[selected=true]:font-normal" href="2.2.1-subbytes-transformation.html">SubBytes Transformation</a></li><li style="padding-left:24px"><a data-selected="false" class="hover:bg-hover block w-full rounded px-2 py-1.5 text-left text-sm transition-none text-secondary data-[selected=true]:bg-hover data-[selected=true]:text-primary font-normal data-[selected=true]:font-normal" href="2.2.2-shiftrows-transformation.html">ShiftRows Transformation</a></li><li style="padding-left:24px"><a data-selected="false" class="hover:bg-hover block w-full rounded px-2 py-1.5 text-left text-sm transition-none text-secondary data-[selected=true]:bg-hover data-[selected=true]:text-primary font-normal data-[selected=true]:font-normal" href="2.2.3-mixcolumns-transformation.html">MixColumns Transformation</a></li><li style="padding-left:24px"><a data-selected="false" class="hover:bg-hover block w-full rounded px-2 py-1.5 text-left text-sm transition-none text-secondary data-[selected=true]:bg-hover data-[selected=true]:text-primary font-normal data-[selected=true]:font-normal" href="2.2.4-addroundkey-transformation.html">AddRoundKey Transformation</a></li><li style="padding-left:12px"><a data-selected="false" class="hover:bg-hover block w-full rounded px-2 py-1.5 text-left text-sm transition-none text-secondary data-[selected=true]:bg-hover data-[selected=true]:text-primary font-normal data-[selected=true]:font-normal" href="2.3-decryption-process.html">Decryption Process</a></li><li style="padding-left:24px"><a data-selected="false" class="hover:bg-hover block w-full rounded px-2 py-1.5 text-left text-sm transition-none text-secondary data-[selected=true]:bg-hover data-[selected=true]:text-primary font-normal data-[selected=true]:font-normal" href="2.3.1-invsubbytes-transformation.html">InvSubBytes Transformation</a></li><li style="padding-left:24px"><a data-selected="false" class="hover:bg-hover block w-full rounded px-2 py-1.5 text-left text-sm transition-none text-secondary data-[selected=true]:bg-hover data-[selected=true]:text-primary font-normal data-[selected=true]:font-normal" href="2.3.2-invshiftrows-transformation.html">InvShiftRows Transformation</a></li><li style="padding-left:24px"><a data-selected="false" class="hover:bg-hover block w-full rounded px-2 py-1.5 text-left text-sm transition-none text-secondary data-[selected=true]:bg-hover data-[selected=true]:text-primary font-normal data-[selected=true]:font-normal" href="2.3.3-invmixcolumns-transformation.html">InvMixColumns Transformation</a></li><li style="padding-left:12px"><a data-selected="false" class="hover:bg-hover block w-full rounded px-2 py-1.5 text-left text-sm transition-none text-secondary data-[selected=true]:bg-hover data-[selected=true]:text-primary font-normal data-[selected=true]:font-normal" href="2.4-galois-field-arithmetic.html">Galois Field Arithmetic</a></li><li style="padding-left:0"><a data-selected="false" class="hover:bg-hover block w-full rounded px-2 py-1.5 text-left text-sm transition-none text-secondary data-[selected=true]:bg-hover data-[selected=true]:text-primary font-normal data-[selected=true]:font-normal" href="3-fingerprint-processing-system.html">Fingerprint Processing System</a></li><li style="padding-left:12px"><a data-selected="false" class="hover:bg-hover block w-full rounded px-2 py-1.5 text-left text-sm transition-none text-secondary data-[selected=true]:bg-hover data-[selected=true]:text-primary font-normal data-[selected=true]:font-normal" href="3.1-feature-extraction-pipeline.html">Feature Extraction Pipeline</a></li><li style="padding-left:24px"><a data-selected="false" class="hover:bg-hover block w-full rounded px-2 py-1.5 text-left text-sm transition-none text-secondary data-[selected=true]:bg-hover data-[selected=true]:text-primary font-normal data-[selected=true]:font-normal" href="3.1.1-image-segmentation-and-normalization.html">Image Segmentation and Normalization</a></li><li style="padding-left:24px"><a data-selected="false" class="hover:bg-hover block w-full rounded px-2 py-1.5 text-left text-sm transition-none text-secondary data-[selected=true]:bg-hover data-[selected=true]:text-primary font-normal data-[selected=true]:font-normal" href="3.1.2-ridge-orientation-estimation.html">Ridge Orientation Estimation</a></li><li style="padding-left:24px"><a data-selected="false" class="hover:bg-hover block w-full rounded px-2 py-1.5 text-left text-sm transition-none text-secondary data-[selected=true]:bg-hover data-[selected=true]:text-primary font-normal data-[selected=true]:font-normal" href="3.1.3-ridge-frequency-estimation.html">Ridge Frequency Estimation</a></li><li style="padding-left:24px"><a data-selected="false" class="hover:bg-hover block w-full rounded px-2 py-1.5 text-left text-sm transition-none text-secondary data-[selected=true]:bg-hover data-[selected=true]:text-primary font-normal data-[selected=true]:font-normal" href="3.1.4-ridge-filter-enhancement.html">Ridge Filter Enhancement</a></li><li style="padding-left:24px"><a data-selected="false" class="hover:bg-hover block w-full rounded px-2 py-1.5 text-left text-sm transition-none text-secondary data-[selected=true]:bg-hover data-[selected=true]:text-primary font-normal data-[selected=true]:font-normal" href="3.1.5-fft-based-enhancement.html">FFT-Based Enhancement</a></li><li style="padding-left:24px"><a data-selected="false" class="hover:bg-hover block w-full rounded px-2 py-1.5 text-left text-sm transition-none text-secondary data-[selected=true]:bg-hover data-[selected=true]:text-primary font-normal data-[selected=true]:font-normal" href="3.1.6-angular-filter-banks.html">Angular Filter Banks</a></li><li style="padding-left:24px"><a data-selected="false" class="hover:bg-hover block w-full rounded px-2 py-1.5 text-left text-sm transition-none text-secondary data-[selected=true]:bg-hover data-[selected=true]:text-primary font-normal data-[selected=true]:font-normal" href="3.1.7-supporting-utility-functions.html">Supporting Utility Functions</a></li><li style="padding-left:12px"><a data-selected="false" class="hover:bg-hover block w-full rounded px-2 py-1.5 text-left text-sm transition-none text-secondary data-[selected=true]:bg-hover data-[selected=true]:text-primary font-normal data-[selected=true]:font-normal" href="3.2-fingerprint-matching.html">Fingerprint Matching</a></li><li style="padding-left:24px"><a data-selected="false" class="hover:bg-hover block w-full rounded px-2 py-1.5 text-left text-sm transition-none text-secondary data-[selected=true]:bg-hover data-[selected=true]:text-primary font-normal data-[selected=true]:font-normal" href="3.2.1-match-algorithm.html">Match Algorithm</a></li><li style="padding-left:24px"><a data-selected="false" class="hover:bg-hover block w-full rounded px-2 py-1.5 text-left text-sm transition-none text-secondary data-[selected=true]:bg-hover data-[selected=true]:text-primary font-normal data-[selected=true]:font-normal" href="3.2.2-similarity-scoring.html">Similarity Scoring</a></li></ul></div></div><div class="flex h-full flex-1 flex-col overflow-hidden"><div class="bg-background border-b-border sticky top-0 z-10 border-b border-dashed md:hidden"><div class="flex cursor-pointer items-center gap-2 p-3"><svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" viewBox="0 0 256 256" class="transition-transform"><path d="M184.49,136.49l-80,80a12,12,0,0,1-17-17L159,128,87.51,56.49a12,12,0,1,1,17-17l80,80A12,12,0,0,1,184.49,136.49Z"></path></svg><span class="truncate text-base font-normal">Menu</span></div></div><div class="relative flex-1 overflow-y-auto px-3 pt-3 md:rounded-md md:px-0 md:pt-0 [&amp;_::selection]:bg-purple-500/40" style="scrollbar-color:var(--color-night) transparent"><div class="pb-30 mx-auto max-w-2xl md:pb-40 md:pt-6 lg:pt-8"><div class="prose prose-invert dark:prose-invert prose-headings:text-inherit prose-p:text-inherit max-w-none"><div><div class="prose-custom prose-custom-md prose-custom-gray !max-w-none text-neutral-300 [overflow-wrap:anywhere]"><h1 id="key-expansion" class="group" data-header="true">Key Expansion<button class="relative ml-2 cursor-pointer align-baseline text-gray-400 opacity-0 transition-opacity hover:text-blue-400 focus:opacity-100 group-hover:opacity-100" aria-label="Copy link to header"><svg xmlns="http://www.w3.org/2000/svg" width="1em" height="1em" fill="currentColor" viewBox="0 0 256 256" class="h-4 w-4"><path d="M117.18,188.74a12,12,0,0,1,0,17l-5.12,5.12A58.26,58.26,0,0,1,70.6,228h0A58.62,58.62,0,0,1,29.14,127.92L63.89,93.17a58.64,58.64,0,0,1,98.56,28.11,12,12,0,1,1-23.37,5.44,34.65,34.65,0,0,0-58.22-16.58L46.11,144.89A34.62,34.62,0,0,0,70.57,204h0a34.41,34.41,0,0,0,24.49-10.14l5.11-5.12A12,12,0,0,1,117.18,188.74ZM226.83,45.17a58.65,58.65,0,0,0-82.93,0l-5.11,5.11a12,12,0,0,0,17,17l5.12-5.12a34.63,34.63,0,1,1,49,49L175.1,145.86A34.39,34.39,0,0,1,150.61,156h0a34.63,34.63,0,0,1-33.69-26.72,12,12,0,0,0-23.38,5.44A58.64,58.64,0,0,0,150.56,180h.05a58.28,58.28,0,0,0,41.47-17.17l34.75-34.75a58.62,58.62,0,0,0,0-82.91Z"></path></svg></button></h1>
<details>
<summary>Relevant source files</summary>
<ul>
<li><a href="https://github.com/QinMoMeak/Simple_FingerPrint_Matching/blob/5cdd0b1a/AES_update/KeyExpansion.m" target="_blank" rel="noopener noreferrer" class="mb-1 mr-1 inline-flex items-stretch font-mono text-xs !no-underline transition-opacity hover:opacity-75"><span class="flex items-center break-all rounded-l px-2 py-1.5 bg-[#e5e5e5] text-[#333333] dark:bg-[#252525] dark:text-[#e4e4e4] rounded-r"><svg class="mr-1.5 hidden h-3.5 w-3.5 flex-shrink-0 opacity-40 md:block" fill="currentColor" viewBox="0 0 24 24"><path d="M12 0c-6.626 0-12 5.373-12 12 0 5.302 3.438 9.8 8.207 11.387.599.111.793-.261.793-.577v-2.234c-3.338.726-4.033-1.416-4.033-1.416-.546-1.387-1.333-1.756-1.333-1.756-1.089-.745.083-.729.083-.729 1.205.084 1.839 1.237 1.839 1.237 1.07 1.834 2.807 1.304 3.492.997.107-.775.418-1.305.762-1.604-2.665-.305-5.467-1.334-5.467-5.931 0-1.311.469-2.381 1.236-3.221-.124-.303-.535-1.524.117-3.176 0 0 1.008-.322 3.301 1.23.957-.266 1.983-.399 3.003-.404 1.02.005 2.047.138 3.006.404 2.291-1.552 3.297-1.23 3.297-1.23.653 1.653.242 2.874.118 3.176.77.84 1.235 1.911 1.235 3.221 0 4.609-2.807 5.624-5.479 5.921.43.372.823 1.102.823 2.222v3.293c0 .319.192.694.801.576 4.765-1.589 8.199-6.086 8.199-11.386 0-6.627-5.373-12-12-12z"></path></svg>AES_update/KeyExpansion.m</span></a></li>
<li><a href="https://github.com/QinMoMeak/Simple_FingerPrint_Matching/blob/5cdd0b1a/AES_update/SubBytes.m" target="_blank" rel="noopener noreferrer" class="mb-1 mr-1 inline-flex items-stretch font-mono text-xs !no-underline transition-opacity hover:opacity-75"><span class="flex items-center break-all rounded-l px-2 py-1.5 bg-[#e5e5e5] text-[#333333] dark:bg-[#252525] dark:text-[#e4e4e4] rounded-r"><svg class="mr-1.5 hidden h-3.5 w-3.5 flex-shrink-0 opacity-40 md:block" fill="currentColor" viewBox="0 0 24 24"><path d="M12 0c-6.626 0-12 5.373-12 12 0 5.302 3.438 9.8 8.207 11.387.599.111.793-.261.793-.577v-2.234c-3.338.726-4.033-1.416-4.033-1.416-.546-1.387-1.333-1.756-1.333-1.756-1.089-.745.083-.729.083-.729 1.205.084 1.839 1.237 1.839 1.237 1.07 1.834 2.807 1.304 3.492.997.107-.775.418-1.305.762-1.604-2.665-.305-5.467-1.334-5.467-5.931 0-1.311.469-2.381 1.236-3.221-.124-.303-.535-1.524.117-3.176 0 0 1.008-.322 3.301 1.23.957-.266 1.983-.399 3.003-.404 1.02.005 2.047.138 3.006.404 2.291-1.552 3.297-1.23 3.297-1.23.653 1.653.242 2.874.118 3.176.77.84 1.235 1.911 1.235 3.221 0 4.609-2.807 5.624-5.479 5.921.43.372.823 1.102.823 2.222v3.293c0 .319.192.694.801.576 4.765-1.589 8.199-6.086 8.199-11.386 0-6.627-5.373-12-12-12z"></path></svg>AES_update/SubBytes.m</span></a></li>
<li><a href="https://github.com/QinMoMeak/Simple_FingerPrint_Matching/blob/5cdd0b1a/AES_update/xtime.m" target="_blank" rel="noopener noreferrer" class="mb-1 mr-1 inline-flex items-stretch font-mono text-xs !no-underline transition-opacity hover:opacity-75"><span class="flex items-center break-all rounded-l px-2 py-1.5 bg-[#e5e5e5] text-[#333333] dark:bg-[#252525] dark:text-[#e4e4e4] rounded-r"><svg class="mr-1.5 hidden h-3.5 w-3.5 flex-shrink-0 opacity-40 md:block" fill="currentColor" viewBox="0 0 24 24"><path d="M12 0c-6.626 0-12 5.373-12 12 0 5.302 3.438 9.8 8.207 11.387.599.111.793-.261.793-.577v-2.234c-3.338.726-4.033-1.416-4.033-1.416-.546-1.387-1.333-1.756-1.333-1.756-1.089-.745.083-.729.083-.729 1.205.084 1.839 1.237 1.839 1.237 1.07 1.834 2.807 1.304 3.492.997.107-.775.418-1.305.762-1.604-2.665-.305-5.467-1.334-5.467-5.931 0-1.311.469-2.381 1.236-3.221-.124-.303-.535-1.524.117-3.176 0 0 1.008-.322 3.301 1.23.957-.266 1.983-.399 3.003-.404 1.02.005 2.047.138 3.006.404 2.291-1.552 3.297-1.23 3.297-1.23.653 1.653.242 2.874.118 3.176.77.84 1.235 1.911 1.235 3.221 0 4.609-2.807 5.624-5.479 5.921.43.372.823 1.102.823 2.222v3.293c0 .319.192.694.801.576 4.765-1.589 8.199-6.086 8.199-11.386 0-6.627-5.373-12-12-12z"></path></svg>AES_update/xtime.m</span></a></li>
</ul>
</details>
<h2 id="purpose-and-scope" class="group" data-header="true">Purpose and Scope<button class="relative ml-2 cursor-pointer align-baseline text-gray-400 opacity-0 transition-opacity hover:text-blue-400 focus:opacity-100 group-hover:opacity-100" aria-label="Copy link to header"><svg xmlns="http://www.w3.org/2000/svg" width="1em" height="1em" fill="currentColor" viewBox="0 0 256 256" class="h-4 w-4"><path d="M117.18,188.74a12,12,0,0,1,0,17l-5.12,5.12A58.26,58.26,0,0,1,70.6,228h0A58.62,58.62,0,0,1,29.14,127.92L63.89,93.17a58.64,58.64,0,0,1,98.56,28.11,12,12,0,1,1-23.37,5.44,34.65,34.65,0,0,0-58.22-16.58L46.11,144.89A34.62,34.62,0,0,0,70.57,204h0a34.41,34.41,0,0,0,24.49-10.14l5.11-5.12A12,12,0,0,1,117.18,188.74ZM226.83,45.17a58.65,58.65,0,0,0-82.93,0l-5.11,5.11a12,12,0,0,0,17,17l5.12-5.12a34.63,34.63,0,1,1,49,49L175.1,145.86A34.39,34.39,0,0,1,150.61,156h0a34.63,34.63,0,0,1-33.69-26.72,12,12,0,0,0-23.38,5.44A58.64,58.64,0,0,0,150.56,180h.05a58.28,58.28,0,0,0,41.47-17.17l34.75-34.75a58.62,58.62,0,0,0,0-82.91Z"></path></svg></button></h2>
<p>This document explains the AES key expansion algorithm implemented in <a href="https://github.com/QinMoMeak/Simple_FingerPrint_Matching/blob/5cdd0b1a/AES_update/KeyExpansion.m" target="_blank" rel="noopener noreferrer" class="mb-1 mr-1 inline-flex items-stretch font-mono text-xs !no-underline transition-opacity hover:opacity-75"><span class="flex items-center break-all rounded-l px-2 py-1.5 bg-[#e5e5e5] text-[#333333] dark:bg-[#252525] dark:text-[#e4e4e4] rounded-r"><svg class="mr-1.5 hidden h-3.5 w-3.5 flex-shrink-0 opacity-40 md:block" fill="currentColor" viewBox="0 0 24 24"><path d="M12 0c-6.626 0-12 5.373-12 12 0 5.302 3.438 9.8 8.207 11.387.599.111.793-.261.793-.577v-2.234c-3.338.726-4.033-1.416-4.033-1.416-.546-1.387-1.333-1.756-1.333-1.756-1.089-.745.083-.729.083-.729 1.205.084 1.839 1.237 1.839 1.237 1.07 1.834 2.807 1.304 3.492.997.107-.775.418-1.305.762-1.604-2.665-.305-5.467-1.334-5.467-5.931 0-1.311.469-2.381 1.236-3.221-.124-.303-.535-1.524.117-3.176 0 0 1.008-.322 3.301 1.23.957-.266 1.983-.399 3.003-.404 1.02.005 2.047.138 3.006.404 2.291-1.552 3.297-1.23 3.297-1.23.653 1.653.242 2.874.118 3.176.77.84 1.235 1.911 1.235 3.221 0 4.609-2.807 5.624-5.479 5.921.43.372.823 1.102.823 2.222v3.293c0 .319.192.694.801.576 4.765-1.589 8.199-6.086 8.199-11.386 0-6.627-5.373-12-12-12z"></path></svg>AES_update/KeyExpansion.m</span></a> The key expansion process transforms an original cipher key (128, 192, or 256 bits) into a schedule of round keys used during encryption and decryption. Each round of AES requires a separate round key, and this function generates all necessary round keys from the initial key.</p>
<p>For information about how these round keys are used during encryption, see <a href="2.2-encryption-process.html" class="text-neutral-300 hover:text-neutral-200 hover:underline">Encryption Process</a>. For details on the inverse cipher that also uses these expanded keys, see <a href="2.3-decryption-process.html" class="text-neutral-300 hover:text-neutral-200 hover:underline">Decryption Process</a>. For background on the Galois field multiplication used in round constant generation, see <a href="2.4-galois-field-arithmetic.html" class="text-neutral-300 hover:text-neutral-200 hover:underline">Galois Field Arithmetic</a>.</p>
<hr/>
<h2 id="overview" class="group" data-header="true">Overview<button class="relative ml-2 cursor-pointer align-baseline text-gray-400 opacity-0 transition-opacity hover:text-blue-400 focus:opacity-100 group-hover:opacity-100" aria-label="Copy link to header"><svg xmlns="http://www.w3.org/2000/svg" width="1em" height="1em" fill="currentColor" viewBox="0 0 256 256" class="h-4 w-4"><path d="M117.18,188.74a12,12,0,0,1,0,17l-5.12,5.12A58.26,58.26,0,0,1,70.6,228h0A58.62,58.62,0,0,1,29.14,127.92L63.89,93.17a58.64,58.64,0,0,1,98.56,28.11,12,12,0,1,1-23.37,5.44,34.65,34.65,0,0,0-58.22-16.58L46.11,144.89A34.62,34.62,0,0,0,70.57,204h0a34.41,34.41,0,0,0,24.49-10.14l5.11-5.12A12,12,0,0,1,117.18,188.74ZM226.83,45.17a58.65,58.65,0,0,0-82.93,0l-5.11,5.11a12,12,0,0,0,17,17l5.12-5.12a34.63,34.63,0,1,1,49,49L175.1,145.86A34.39,34.39,0,0,1,150.61,156h0a34.63,34.63,0,0,1-33.69-26.72,12,12,0,0,0-23.38,5.44A58.64,58.64,0,0,0,150.56,180h.05a58.28,58.28,0,0,0,41.47-17.17l34.75-34.75a58.62,58.62,0,0,0,0-82.91Z"></path></svg></button></h2>
<p>The <code class="rounded-sm bg-[#e5e5e5] px-[0.25rem] py-[0.20rem] text-xs font-normal leading-[15px] before:hidden after:hidden dark:bg-[#484848]/30">KeyExpansion</code> function generates 44 words (176 bytes) for AES-128, 52 words (208 bytes) for AES-192, or 60 words (240 bytes) for AES-256. The first <code class="rounded-sm bg-[#e5e5e5] px-[0.25rem] py-[0.20rem] text-xs font-normal leading-[15px] before:hidden after:hidden dark:bg-[#484848]/30">Nk</code> words contain the original key, and subsequent words are derived through iterative transformations involving rotation, substitution, and XOR operations with round constants.</p>
<p><strong>Sources:</strong> <a href="https://github.com/QinMoMeak/Simple_FingerPrint_Matching/blob/5cdd0b1a/AES_update/KeyExpansion.m#L1-L20" target="_blank" rel="noopener noreferrer" class="mb-1 mr-1 inline-flex items-stretch font-mono text-xs !no-underline transition-opacity hover:opacity-75"><span class="flex items-center break-all rounded-l px-2 py-1.5 bg-[#e5e5e5] text-[#333333] dark:bg-[#252525] dark:text-[#e4e4e4]"><svg class="mr-1.5 hidden h-3.5 w-3.5 flex-shrink-0 opacity-40 md:block" fill="currentColor" viewBox="0 0 24 24"><path d="M12 0c-6.626 0-12 5.373-12 12 0 5.302 3.438 9.8 8.207 11.387.599.111.793-.261.793-.577v-2.234c-3.338.726-4.033-1.416-4.033-1.416-.546-1.387-1.333-1.756-1.333-1.756-1.089-.745.083-.729.083-.729 1.205.084 1.839 1.237 1.839 1.237 1.07 1.834 2.807 1.304 3.492.997.107-.775.418-1.305.762-1.604-2.665-.305-5.467-1.334-5.467-5.931 0-1.311.469-2.381 1.236-3.221-.124-.303-.535-1.524.117-3.176 0 0 1.008-.322 3.301 1.23.957-.266 1.983-.399 3.003-.404 1.02.005 2.047.138 3.006.404 2.291-1.552 3.297-1.23 3.297-1.23.653 1.653.242 2.874.118 3.176.77.84 1.235 1.911 1.235 3.221 0 4.609-2.807 5.624-5.479 5.921.43.372.823 1.102.823 2.222v3.293c0 .319.192.694.801.576 4.765-1.589 8.199-6.086 8.199-11.386 0-6.627-5.373-12-12-12z"></path></svg>AES_update/KeyExpansion.m</span><span class="flex flex-shrink-0 items-center rounded-r border-l px-2 py-1.5 border-[#dddddd] bg-[#d8d8d8] text-[#666666] dark:border-[#333333] dark:bg-[#2a2a2a] dark:text-[#888888]">1-20</span></a></p>
<hr/>
<h2 id="function-signature-and-parameters" class="group" data-header="true">Function Signature and Parameters<button class="relative ml-2 cursor-pointer align-baseline text-gray-400 opacity-0 transition-opacity hover:text-blue-400 focus:opacity-100 group-hover:opacity-100" aria-label="Copy link to header"><svg xmlns="http://www.w3.org/2000/svg" width="1em" height="1em" fill="currentColor" viewBox="0 0 256 256" class="h-4 w-4"><path d="M117.18,188.74a12,12,0,0,1,0,17l-5.12,5.12A58.26,58.26,0,0,1,70.6,228h0A58.62,58.62,0,0,1,29.14,127.92L63.89,93.17a58.64,58.64,0,0,1,98.56,28.11,12,12,0,1,1-23.37,5.44,34.65,34.65,0,0,0-58.22-16.58L46.11,144.89A34.62,34.62,0,0,0,70.57,204h0a34.41,34.41,0,0,0,24.49-10.14l5.11-5.12A12,12,0,0,1,117.18,188.74ZM226.83,45.17a58.65,58.65,0,0,0-82.93,0l-5.11,5.11a12,12,0,0,0,17,17l5.12-5.12a34.63,34.63,0,1,1,49,49L175.1,145.86A34.39,34.39,0,0,1,150.61,156h0a34.63,34.63,0,0,1-33.69-26.72,12,12,0,0,0-23.38,5.44A58.64,58.64,0,0,0,150.56,180h.05a58.28,58.28,0,0,0,41.47-17.17l34.75-34.75a58.62,58.62,0,0,0,0-82.91Z"></path></svg></button></h2>
<pre class="px-2 py-1.5 has-[code]:rounded-md has-[code]:!bg-[#e5e5e5] has-[div]:bg-transparent has-[div]:!p-0 has-[code]:text-stone-900 dark:has-[code]:!bg-[#242424] has-[code]:dark:text-white [&amp;_code]:block [&amp;_code]:border-none [&amp;_code]:bg-transparent [&amp;_code]:p-0"><div class="rounded-sm border border-[#8F8F8F]/30 p-2 text-xs font-normal leading-[15px]" style="background-color:transparent;min-height:2em"></div></pre>

























<table><thead><tr><th>Parameter</th><th>Type</th><th>Description</th></tr></thead><tbody><tr><td><code class="rounded-sm bg-[#e5e5e5] px-[0.25rem] py-[0.20rem] text-xs font-normal leading-[15px] before:hidden after:hidden dark:bg-[#484848]/30">key</code></td><td>Hex string</td><td>The original cipher key represented as a hexadecimal string</td></tr><tr><td><code class="rounded-sm bg-[#e5e5e5] px-[0.25rem] py-[0.20rem] text-xs font-normal leading-[15px] before:hidden after:hidden dark:bg-[#484848]/30">Nk</code></td><td>Integer</td><td>Number of 32-bit words in the key: 4 (AES-128), 6 (AES-192), or 8 (AES-256)</td></tr><tr><td><strong>Returns</strong></td><td>4×N array</td><td>Expanded key schedule where N = 4×(Nk+7) columns</td></tr></tbody></table>
<p><strong>Supported Key Sizes:</strong></p>

































<table><thead><tr><th>AES Variant</th><th>Nk Value</th><th>Key Size (bits)</th><th>Output Words</th><th>Rounds</th></tr></thead><tbody><tr><td>AES-128</td><td>4</td><td>128</td><td>44</td><td>10</td></tr><tr><td>AES-192</td><td>6</td><td>192</td><td>52</td><td>12</td></tr><tr><td>AES-256</td><td>8</td><td>256</td><td>60</td><td>14</td></tr></tbody></table>
<p><strong>Sources:</strong> <a href="https://github.com/QinMoMeak/Simple_FingerPrint_Matching/blob/5cdd0b1a/AES_update/KeyExpansion.m#L1-L3" target="_blank" rel="noopener noreferrer" class="mb-1 mr-1 inline-flex items-stretch font-mono text-xs !no-underline transition-opacity hover:opacity-75"><span class="flex items-center break-all rounded-l px-2 py-1.5 bg-[#e5e5e5] text-[#333333] dark:bg-[#252525] dark:text-[#e4e4e4]"><svg class="mr-1.5 hidden h-3.5 w-3.5 flex-shrink-0 opacity-40 md:block" fill="currentColor" viewBox="0 0 24 24"><path d="M12 0c-6.626 0-12 5.373-12 12 0 5.302 3.438 9.8 8.207 11.387.599.111.793-.261.793-.577v-2.234c-3.338.726-4.033-1.416-4.033-1.416-.546-1.387-1.333-1.756-1.333-1.756-1.089-.745.083-.729.083-.729 1.205.084 1.839 1.237 1.839 1.237 1.07 1.834 2.807 1.304 3.492.997.107-.775.418-1.305.762-1.604-2.665-.305-5.467-1.334-5.467-5.931 0-1.311.469-2.381 1.236-3.221-.124-.303-.535-1.524.117-3.176 0 0 1.008-.322 3.301 1.23.957-.266 1.983-.399 3.003-.404 1.02.005 2.047.138 3.006.404 2.291-1.552 3.297-1.23 3.297-1.23.653 1.653.242 2.874.118 3.176.77.84 1.235 1.911 1.235 3.221 0 4.609-2.807 5.624-5.479 5.921.43.372.823 1.102.823 2.222v3.293c0 .319.192.694.801.576 4.765-1.589 8.199-6.086 8.199-11.386 0-6.627-5.373-12-12-12z"></path></svg>AES_update/KeyExpansion.m</span><span class="flex flex-shrink-0 items-center rounded-r border-l px-2 py-1.5 border-[#dddddd] bg-[#d8d8d8] text-[#666666] dark:border-[#333333] dark:bg-[#2a2a2a] dark:text-[#888888]">1-3</span></a></p>
<hr/>
<h2 id="key-expansion-algorithm-flow" class="group" data-header="true">Key Expansion Algorithm Flow<button class="relative ml-2 cursor-pointer align-baseline text-gray-400 opacity-0 transition-opacity hover:text-blue-400 focus:opacity-100 group-hover:opacity-100" aria-label="Copy link to header"><svg xmlns="http://www.w3.org/2000/svg" width="1em" height="1em" fill="currentColor" viewBox="0 0 256 256" class="h-4 w-4"><path d="M117.18,188.74a12,12,0,0,1,0,17l-5.12,5.12A58.26,58.26,0,0,1,70.6,228h0A58.62,58.62,0,0,1,29.14,127.92L63.89,93.17a58.64,58.64,0,0,1,98.56,28.11,12,12,0,1,1-23.37,5.44,34.65,34.65,0,0,0-58.22-16.58L46.11,144.89A34.62,34.62,0,0,0,70.57,204h0a34.41,34.41,0,0,0,24.49-10.14l5.11-5.12A12,12,0,0,1,117.18,188.74ZM226.83,45.17a58.65,58.65,0,0,0-82.93,0l-5.11,5.11a12,12,0,0,0,17,17l5.12-5.12a34.63,34.63,0,1,1,49,49L175.1,145.86A34.39,34.39,0,0,1,150.61,156h0a34.63,34.63,0,0,1-33.69-26.72,12,12,0,0,0-23.38,5.44A58.64,58.64,0,0,0,150.56,180h.05a58.28,58.28,0,0,0,41.47-17.17l34.75-34.75a58.62,58.62,0,0,0,0-82.91Z"></path></svg></button></h2>
<pre class="px-2 py-1.5 has-[code]:rounded-md has-[code]:!bg-[#e5e5e5] has-[div]:bg-transparent has-[div]:!p-0 has-[code]:text-stone-900 dark:has-[code]:!bg-[#242424] has-[code]:dark:text-white [&amp;_code]:block [&amp;_code]:border-none [&amp;_code]:bg-transparent [&amp;_code]:p-0"><!--$!--><template data-dgst="BAILOUT_TO_CLIENT_SIDE_RENDERING"></template><!--/$--></pre>
<p><strong>Diagram: Key Expansion Algorithm Control Flow</strong></p>
<p><strong>Sources:</strong> <a href="https://github.com/QinMoMeak/Simple_FingerPrint_Matching/blob/5cdd0b1a/AES_update/KeyExpansion.m#L2-L19" target="_blank" rel="noopener noreferrer" class="mb-1 mr-1 inline-flex items-stretch font-mono text-xs !no-underline transition-opacity hover:opacity-75"><span class="flex items-center break-all rounded-l px-2 py-1.5 bg-[#e5e5e5] text-[#333333] dark:bg-[#252525] dark:text-[#e4e4e4]"><svg class="mr-1.5 hidden h-3.5 w-3.5 flex-shrink-0 opacity-40 md:block" fill="currentColor" viewBox="0 0 24 24"><path d="M12 0c-6.626 0-12 5.373-12 12 0 5.302 3.438 9.8 8.207 11.387.599.111.793-.261.793-.577v-2.234c-3.338.726-4.033-1.416-4.033-1.416-.546-1.387-1.333-1.756-1.333-1.756-1.089-.745.083-.729.083-.729 1.205.084 1.839 1.237 1.839 1.237 1.07 1.834 2.807 1.304 3.492.997.107-.775.418-1.305.762-1.604-2.665-.305-5.467-1.334-5.467-5.931 0-1.311.469-2.381 1.236-3.221-.124-.303-.535-1.524.117-3.176 0 0 1.008-.322 3.301 1.23.957-.266 1.983-.399 3.003-.404 1.02.005 2.047.138 3.006.404 2.291-1.552 3.297-1.23 3.297-1.23.653 1.653.242 2.874.118 3.176.77.84 1.235 1.911 1.235 3.221 0 4.609-2.807 5.624-5.479 5.921.43.372.823 1.102.823 2.222v3.293c0 .319.192.694.801.576 4.765-1.589 8.199-6.086 8.199-11.386 0-6.627-5.373-12-12-12z"></path></svg>AES_update/KeyExpansion.m</span><span class="flex flex-shrink-0 items-center rounded-r border-l px-2 py-1.5 border-[#dddddd] bg-[#d8d8d8] text-[#666666] dark:border-[#333333] dark:bg-[#2a2a2a] dark:text-[#888888]">2-19</span></a></p>
<hr/>
<h2 id="input-processing" class="group" data-header="true">Input Processing<button class="relative ml-2 cursor-pointer align-baseline text-gray-400 opacity-0 transition-opacity hover:text-blue-400 focus:opacity-100 group-hover:opacity-100" aria-label="Copy link to header"><svg xmlns="http://www.w3.org/2000/svg" width="1em" height="1em" fill="currentColor" viewBox="0 0 256 256" class="h-4 w-4"><path d="M117.18,188.74a12,12,0,0,1,0,17l-5.12,5.12A58.26,58.26,0,0,1,70.6,228h0A58.62,58.62,0,0,1,29.14,127.92L63.89,93.17a58.64,58.64,0,0,1,98.56,28.11,12,12,0,1,1-23.37,5.44,34.65,34.65,0,0,0-58.22-16.58L46.11,144.89A34.62,34.62,0,0,0,70.57,204h0a34.41,34.41,0,0,0,24.49-10.14l5.11-5.12A12,12,0,0,1,117.18,188.74ZM226.83,45.17a58.65,58.65,0,0,0-82.93,0l-5.11,5.11a12,12,0,0,0,17,17l5.12-5.12a34.63,34.63,0,1,1,49,49L175.1,145.86A34.39,34.39,0,0,1,150.61,156h0a34.63,34.63,0,0,1-33.69-26.72,12,12,0,0,0-23.38,5.44A58.64,58.64,0,0,0,150.56,180h.05a58.28,58.28,0,0,0,41.47-17.17l34.75-34.75a58.62,58.62,0,0,0,0-82.91Z"></path></svg></button></h2>
<p>The function begins by converting the hexadecimal key string into a numerical array:</p>
<ol>
<li>
<p><strong>Hex to Decimal Conversion</strong> (<a href="https://github.com/QinMoMeak/Simple_FingerPrint_Matching/blob/5cdd0b1a/AES_update/KeyExpansion.m#L2-L2" target="_blank" rel="noopener noreferrer" class="mb-1 mr-1 inline-flex items-stretch font-mono text-xs !no-underline transition-opacity hover:opacity-75"><span class="flex items-center break-all rounded-l px-2 py-1.5 bg-[#e5e5e5] text-[#333333] dark:bg-[#252525] dark:text-[#e4e4e4]"><svg class="mr-1.5 hidden h-3.5 w-3.5 flex-shrink-0 opacity-40 md:block" fill="currentColor" viewBox="0 0 24 24"><path d="M12 0c-6.626 0-12 5.373-12 12 0 5.302 3.438 9.8 8.207 11.387.599.111.793-.261.793-.577v-2.234c-3.338.726-4.033-1.416-4.033-1.416-.546-1.387-1.333-1.756-1.333-1.756-1.089-.745.083-.729.083-.729 1.205.084 1.839 1.237 1.839 1.237 1.07 1.834 2.807 1.304 3.492.997.107-.775.418-1.305.762-1.604-2.665-.305-5.467-1.334-5.467-5.931 0-1.311.469-2.381 1.236-3.221-.124-.303-.535-1.524.117-3.176 0 0 1.008-.322 3.301 1.23.957-.266 1.983-.399 3.003-.404 1.02.005 2.047.138 3.006.404 2.291-1.552 3.297-1.23 3.297-1.23.653 1.653.242 2.874.118 3.176.77.84 1.235 1.911 1.235 3.221 0 4.609-2.807 5.624-5.479 5.921.43.372.823 1.102.823 2.222v3.293c0 .319.192.694.801.576 4.765-1.589 8.199-6.086 8.199-11.386 0-6.627-5.373-12-12-12z"></path></svg>AES_update/KeyExpansion.m</span><span class="flex flex-shrink-0 items-center rounded-r border-l px-2 py-1.5 border-[#dddddd] bg-[#d8d8d8] text-[#666666] dark:border-[#333333] dark:bg-[#2a2a2a] dark:text-[#888888]">2</span></a>): <code class="rounded-sm bg-[#e5e5e5] px-[0.25rem] py-[0.20rem] text-xs font-normal leading-[15px] before:hidden after:hidden dark:bg-[#484848]/30">hex2dec(reshape(key,2,[]))&#x27;</code> converts pairs of hex characters into decimal byte values.</p>
</li>
<li>
<p><strong>Array Reshaping</strong> (<a href="https://github.com/QinMoMeak/Simple_FingerPrint_Matching/blob/5cdd0b1a/AES_update/KeyExpansion.m#L3-L3" target="_blank" rel="noopener noreferrer" class="mb-1 mr-1 inline-flex items-stretch font-mono text-xs !no-underline transition-opacity hover:opacity-75"><span class="flex items-center break-all rounded-l px-2 py-1.5 bg-[#e5e5e5] text-[#333333] dark:bg-[#252525] dark:text-[#e4e4e4]"><svg class="mr-1.5 hidden h-3.5 w-3.5 flex-shrink-0 opacity-40 md:block" fill="currentColor" viewBox="0 0 24 24"><path d="M12 0c-6.626 0-12 5.373-12 12 0 5.302 3.438 9.8 8.207 11.387.599.111.793-.261.793-.577v-2.234c-3.338.726-4.033-1.416-4.033-1.416-.546-1.387-1.333-1.756-1.333-1.756-1.089-.745.083-.729.083-.729 1.205.084 1.839 1.237 1.839 1.237 1.07 1.834 2.807 1.304 3.492.997.107-.775.418-1.305.762-1.604-2.665-.305-5.467-1.334-5.467-5.931 0-1.311.469-2.381 1.236-3.221-.124-.303-.535-1.524.117-3.176 0 0 1.008-.322 3.301 1.23.957-.266 1.983-.399 3.003-.404 1.02.005 2.047.138 3.006.404 2.291-1.552 3.297-1.23 3.297-1.23.653 1.653.242 2.874.118 3.176.77.84 1.235 1.911 1.235 3.221 0 4.609-2.807 5.624-5.479 5.921.43.372.823 1.102.823 2.222v3.293c0 .319.192.694.801.576 4.765-1.589 8.199-6.086 8.199-11.386 0-6.627-5.373-12-12-12z"></path></svg>AES_update/KeyExpansion.m</span><span class="flex flex-shrink-0 items-center rounded-r border-l px-2 py-1.5 border-[#dddddd] bg-[#d8d8d8] text-[#666666] dark:border-[#333333] dark:bg-[#2a2a2a] dark:text-[#888888]">3</span></a>): <code class="rounded-sm bg-[#e5e5e5] px-[0.25rem] py-[0.20rem] text-xs font-normal leading-[15px] before:hidden after:hidden dark:bg-[#484848]/30">reshape(key,4,[])</code> organizes the bytes into a 4-row matrix where each column represents a 32-bit word. For AES-128, this produces a 4×4 matrix; for AES-192, a 4×6 matrix; for AES-256, a 4×8 matrix.</p>
</li>
</ol>
<p><strong>Sources:</strong> <a href="https://github.com/QinMoMeak/Simple_FingerPrint_Matching/blob/5cdd0b1a/AES_update/KeyExpansion.m#L2-L3" target="_blank" rel="noopener noreferrer" class="mb-1 mr-1 inline-flex items-stretch font-mono text-xs !no-underline transition-opacity hover:opacity-75"><span class="flex items-center break-all rounded-l px-2 py-1.5 bg-[#e5e5e5] text-[#333333] dark:bg-[#252525] dark:text-[#e4e4e4]"><svg class="mr-1.5 hidden h-3.5 w-3.5 flex-shrink-0 opacity-40 md:block" fill="currentColor" viewBox="0 0 24 24"><path d="M12 0c-6.626 0-12 5.373-12 12 0 5.302 3.438 9.8 8.207 11.387.599.111.793-.261.793-.577v-2.234c-3.338.726-4.033-1.416-4.033-1.416-.546-1.387-1.333-1.756-1.333-1.756-1.089-.745.083-.729.083-.729 1.205.084 1.839 1.237 1.839 1.237 1.07 1.834 2.807 1.304 3.492.997.107-.775.418-1.305.762-1.604-2.665-.305-5.467-1.334-5.467-5.931 0-1.311.469-2.381 1.236-3.221-.124-.303-.535-1.524.117-3.176 0 0 1.008-.322 3.301 1.23.957-.266 1.983-.399 3.003-.404 1.02.005 2.047.138 3.006.404 2.291-1.552 3.297-1.23 3.297-1.23.653 1.653.242 2.874.118 3.176.77.84 1.235 1.911 1.235 3.221 0 4.609-2.807 5.624-5.479 5.921.43.372.823 1.102.823 2.222v3.293c0 .319.192.694.801.576 4.765-1.589 8.199-6.086 8.199-11.386 0-6.627-5.373-12-12-12z"></path></svg>AES_update/KeyExpansion.m</span><span class="flex flex-shrink-0 items-center rounded-r border-l px-2 py-1.5 border-[#dddddd] bg-[#d8d8d8] text-[#666666] dark:border-[#333333] dark:bg-[#2a2a2a] dark:text-[#888888]">2-3</span></a></p>
<hr/>
<h2 id="iterative-word-generation" class="group" data-header="true">Iterative Word Generation<button class="relative ml-2 cursor-pointer align-baseline text-gray-400 opacity-0 transition-opacity hover:text-blue-400 focus:opacity-100 group-hover:opacity-100" aria-label="Copy link to header"><svg xmlns="http://www.w3.org/2000/svg" width="1em" height="1em" fill="currentColor" viewBox="0 0 256 256" class="h-4 w-4"><path d="M117.18,188.74a12,12,0,0,1,0,17l-5.12,5.12A58.26,58.26,0,0,1,70.6,228h0A58.62,58.62,0,0,1,29.14,127.92L63.89,93.17a58.64,58.64,0,0,1,98.56,28.11,12,12,0,1,1-23.37,5.44,34.65,34.65,0,0,0-58.22-16.58L46.11,144.89A34.62,34.62,0,0,0,70.57,204h0a34.41,34.41,0,0,0,24.49-10.14l5.11-5.12A12,12,0,0,1,117.18,188.74ZM226.83,45.17a58.65,58.65,0,0,0-82.93,0l-5.11,5.11a12,12,0,0,0,17,17l5.12-5.12a34.63,34.63,0,1,1,49,49L175.1,145.86A34.39,34.39,0,0,1,150.61,156h0a34.63,34.63,0,0,1-33.69-26.72,12,12,0,0,0-23.38,5.44A58.64,58.64,0,0,0,150.56,180h.05a58.28,58.28,0,0,0,41.47-17.17l34.75-34.75a58.62,58.62,0,0,0,0-82.91Z"></path></svg></button></h2>
<p>The expansion loop (<a href="https://github.com/QinMoMeak/Simple_FingerPrint_Matching/blob/5cdd0b1a/AES_update/KeyExpansion.m#L4-L19" target="_blank" rel="noopener noreferrer" class="mb-1 mr-1 inline-flex items-stretch font-mono text-xs !no-underline transition-opacity hover:opacity-75"><span class="flex items-center break-all rounded-l px-2 py-1.5 bg-[#e5e5e5] text-[#333333] dark:bg-[#252525] dark:text-[#e4e4e4]"><svg class="mr-1.5 hidden h-3.5 w-3.5 flex-shrink-0 opacity-40 md:block" fill="currentColor" viewBox="0 0 24 24"><path d="M12 0c-6.626 0-12 5.373-12 12 0 5.302 3.438 9.8 8.207 11.387.599.111.793-.261.793-.577v-2.234c-3.338.726-4.033-1.416-4.033-1.416-.546-1.387-1.333-1.756-1.333-1.756-1.089-.745.083-.729.083-.729 1.205.084 1.839 1.237 1.839 1.237 1.07 1.834 2.807 1.304 3.492.997.107-.775.418-1.305.762-1.604-2.665-.305-5.467-1.334-5.467-5.931 0-1.311.469-2.381 1.236-3.221-.124-.303-.535-1.524.117-3.176 0 0 1.008-.322 3.301 1.23.957-.266 1.983-.399 3.003-.404 1.02.005 2.047.138 3.006.404 2.291-1.552 3.297-1.23 3.297-1.23.653 1.653.242 2.874.118 3.176.77.84 1.235 1.911 1.235 3.221 0 4.609-2.807 5.624-5.479 5.921.43.372.823 1.102.823 2.222v3.293c0 .319.192.694.801.576 4.765-1.589 8.199-6.086 8.199-11.386 0-6.627-5.373-12-12-12z"></path></svg>AES_update/KeyExpansion.m</span><span class="flex flex-shrink-0 items-center rounded-r border-l px-2 py-1.5 border-[#dddddd] bg-[#d8d8d8] text-[#666666] dark:border-[#333333] dark:bg-[#2a2a2a] dark:text-[#888888]">4-19</span></a>) generates words <code class="rounded-sm bg-[#e5e5e5] px-[0.25rem] py-[0.20rem] text-xs font-normal leading-[15px] before:hidden after:hidden dark:bg-[#484848]/30">w[Nk]</code> through <code class="rounded-sm bg-[#e5e5e5] px-[0.25rem] py-[0.20rem] text-xs font-normal leading-[15px] before:hidden after:hidden dark:bg-[#484848]/30">w[4*(Nk+7)-1]</code>:</p>
<pre class="px-2 py-1.5 has-[code]:rounded-md has-[code]:!bg-[#e5e5e5] has-[div]:bg-transparent has-[div]:!p-0 has-[code]:text-stone-900 dark:has-[code]:!bg-[#242424] has-[code]:dark:text-white [&amp;_code]:block [&amp;_code]:border-none [&amp;_code]:bg-transparent [&amp;_code]:p-0"><!--$!--><template data-dgst="BAILOUT_TO_CLIENT_SIDE_RENDERING"></template><!--/$--></pre>
<p><strong>Diagram: Word Generation Dependencies</strong></p>
<p>Each new word <code class="rounded-sm bg-[#e5e5e5] px-[0.25rem] py-[0.20rem] text-xs font-normal leading-[15px] before:hidden after:hidden dark:bg-[#484848]/30">w[i]</code> is derived from:</p>
<ul>
<li><code class="rounded-sm bg-[#e5e5e5] px-[0.25rem] py-[0.20rem] text-xs font-normal leading-[15px] before:hidden after:hidden dark:bg-[#484848]/30">w[i-Nk]</code> (word from <code class="rounded-sm bg-[#e5e5e5] px-[0.25rem] py-[0.20rem] text-xs font-normal leading-[15px] before:hidden after:hidden dark:bg-[#484848]/30">Nk</code> positions earlier)</li>
<li><code class="rounded-sm bg-[#e5e5e5] px-[0.25rem] py-[0.20rem] text-xs font-normal leading-[15px] before:hidden after:hidden dark:bg-[#484848]/30">w[i-1]</code> (previous word, after optional transformations)</li>
</ul>
<p><strong>Sources:</strong> <a href="https://github.com/QinMoMeak/Simple_FingerPrint_Matching/blob/5cdd0b1a/AES_update/KeyExpansion.m#L4-L19" target="_blank" rel="noopener noreferrer" class="mb-1 mr-1 inline-flex items-stretch font-mono text-xs !no-underline transition-opacity hover:opacity-75"><span class="flex items-center break-all rounded-l px-2 py-1.5 bg-[#e5e5e5] text-[#333333] dark:bg-[#252525] dark:text-[#e4e4e4]"><svg class="mr-1.5 hidden h-3.5 w-3.5 flex-shrink-0 opacity-40 md:block" fill="currentColor" viewBox="0 0 24 24"><path d="M12 0c-6.626 0-12 5.373-12 12 0 5.302 3.438 9.8 8.207 11.387.599.111.793-.261.793-.577v-2.234c-3.338.726-4.033-1.416-4.033-1.416-.546-1.387-1.333-1.756-1.333-1.756-1.089-.745.083-.729.083-.729 1.205.084 1.839 1.237 1.839 1.237 1.07 1.834 2.807 1.304 3.492.997.107-.775.418-1.305.762-1.604-2.665-.305-5.467-1.334-5.467-5.931 0-1.311.469-2.381 1.236-3.221-.124-.303-.535-1.524.117-3.176 0 0 1.008-.322 3.301 1.23.957-.266 1.983-.399 3.003-.404 1.02.005 2.047.138 3.006.404 2.291-1.552 3.297-1.23 3.297-1.23.653 1.653.242 2.874.118 3.176.77.84 1.235 1.911 1.235 3.221 0 4.609-2.807 5.624-5.479 5.921.43.372.823 1.102.823 2.222v3.293c0 .319.192.694.801.576 4.765-1.589 8.199-6.086 8.199-11.386 0-6.627-5.373-12-12-12z"></path></svg>AES_update/KeyExpansion.m</span><span class="flex flex-shrink-0 items-center rounded-r border-l px-2 py-1.5 border-[#dddddd] bg-[#d8d8d8] text-[#666666] dark:border-[#333333] dark:bg-[#2a2a2a] dark:text-[#888888]">4-19</span></a></p>
<hr/>
<h2 id="core-transformations" class="group" data-header="true">Core Transformations<button class="relative ml-2 cursor-pointer align-baseline text-gray-400 opacity-0 transition-opacity hover:text-blue-400 focus:opacity-100 group-hover:opacity-100" aria-label="Copy link to header"><svg xmlns="http://www.w3.org/2000/svg" width="1em" height="1em" fill="currentColor" viewBox="0 0 256 256" class="h-4 w-4"><path d="M117.18,188.74a12,12,0,0,1,0,17l-5.12,5.12A58.26,58.26,0,0,1,70.6,228h0A58.62,58.62,0,0,1,29.14,127.92L63.89,93.17a58.64,58.64,0,0,1,98.56,28.11,12,12,0,1,1-23.37,5.44,34.65,34.65,0,0,0-58.22-16.58L46.11,144.89A34.62,34.62,0,0,0,70.57,204h0a34.41,34.41,0,0,0,24.49-10.14l5.11-5.12A12,12,0,0,1,117.18,188.74ZM226.83,45.17a58.65,58.65,0,0,0-82.93,0l-5.11,5.11a12,12,0,0,0,17,17l5.12-5.12a34.63,34.63,0,1,1,49,49L175.1,145.86A34.39,34.39,0,0,1,150.61,156h0a34.63,34.63,0,0,1-33.69-26.72,12,12,0,0,0-23.38,5.44A58.64,58.64,0,0,0,150.56,180h.05a58.28,58.28,0,0,0,41.47-17.17l34.75-34.75a58.62,58.62,0,0,0,0-82.91Z"></path></svg></button></h2>
<h3 id="rotword-cyclic-byte-rotation" class="group" data-header="true">RotWord (Cyclic Byte Rotation)<button class="relative ml-2 cursor-pointer align-baseline text-gray-400 opacity-0 transition-opacity hover:text-blue-400 focus:opacity-100 group-hover:opacity-100" aria-label="Copy link to header"><svg xmlns="http://www.w3.org/2000/svg" width="1em" height="1em" fill="currentColor" viewBox="0 0 256 256" class="h-4 w-4"><path d="M117.18,188.74a12,12,0,0,1,0,17l-5.12,5.12A58.26,58.26,0,0,1,70.6,228h0A58.62,58.62,0,0,1,29.14,127.92L63.89,93.17a58.64,58.64,0,0,1,98.56,28.11,12,12,0,1,1-23.37,5.44,34.65,34.65,0,0,0-58.22-16.58L46.11,144.89A34.62,34.62,0,0,0,70.57,204h0a34.41,34.41,0,0,0,24.49-10.14l5.11-5.12A12,12,0,0,1,117.18,188.74ZM226.83,45.17a58.65,58.65,0,0,0-82.93,0l-5.11,5.11a12,12,0,0,0,17,17l5.12-5.12a34.63,34.63,0,1,1,49,49L175.1,145.86A34.39,34.39,0,0,1,150.61,156h0a34.63,34.63,0,0,1-33.69-26.72,12,12,0,0,0-23.38,5.44A58.64,58.64,0,0,0,150.56,180h.05a58.28,58.28,0,0,0,41.47-17.17l34.75-34.75a58.62,58.62,0,0,0,0-82.91Z"></path></svg></button></h3>
<p>When <code class="rounded-sm bg-[#e5e5e5] px-[0.25rem] py-[0.20rem] text-xs font-normal leading-[15px] before:hidden after:hidden dark:bg-[#484848]/30">i mod Nk == 0</code> (<a href="https://github.com/QinMoMeak/Simple_FingerPrint_Matching/blob/5cdd0b1a/AES_update/KeyExpansion.m#L6-L6" target="_blank" rel="noopener noreferrer" class="mb-1 mr-1 inline-flex items-stretch font-mono text-xs !no-underline transition-opacity hover:opacity-75"><span class="flex items-center break-all rounded-l px-2 py-1.5 bg-[#e5e5e5] text-[#333333] dark:bg-[#252525] dark:text-[#e4e4e4]"><svg class="mr-1.5 hidden h-3.5 w-3.5 flex-shrink-0 opacity-40 md:block" fill="currentColor" viewBox="0 0 24 24"><path d="M12 0c-6.626 0-12 5.373-12 12 0 5.302 3.438 9.8 8.207 11.387.599.111.793-.261.793-.577v-2.234c-3.338.726-4.033-1.416-4.033-1.416-.546-1.387-1.333-1.756-1.333-1.756-1.089-.745.083-.729.083-.729 1.205.084 1.839 1.237 1.839 1.237 1.07 1.834 2.807 1.304 3.492.997.107-.775.418-1.305.762-1.604-2.665-.305-5.467-1.334-5.467-5.931 0-1.311.469-2.381 1.236-3.221-.124-.303-.535-1.524.117-3.176 0 0 1.008-.322 3.301 1.23.957-.266 1.983-.399 3.003-.404 1.02.005 2.047.138 3.006.404 2.291-1.552 3.297-1.23 3.297-1.23.653 1.653.242 2.874.118 3.176.77.84 1.235 1.911 1.235 3.221 0 4.609-2.807 5.624-5.479 5.921.43.372.823 1.102.823 2.222v3.293c0 .319.192.694.801.576 4.765-1.589 8.199-6.086 8.199-11.386 0-6.627-5.373-12-12-12z"></path></svg>AES_update/KeyExpansion.m</span><span class="flex flex-shrink-0 items-center rounded-r border-l px-2 py-1.5 border-[#dddddd] bg-[#d8d8d8] text-[#666666] dark:border-[#333333] dark:bg-[#2a2a2a] dark:text-[#888888]">6</span></a>), the previous word undergoes rotation:</p>
<pre class="px-2 py-1.5 has-[code]:rounded-md has-[code]:!bg-[#e5e5e5] has-[div]:bg-transparent has-[div]:!p-0 has-[code]:text-stone-900 dark:has-[code]:!bg-[#242424] has-[code]:dark:text-white [&amp;_code]:block [&amp;_code]:border-none [&amp;_code]:bg-transparent [&amp;_code]:p-0"><div class="rounded-sm border border-[#8F8F8F]/30 p-2 text-xs font-normal leading-[15px]" style="background-color:transparent;min-height:2em"></div></pre>
<p>This performs a cyclic left shift by one byte position:</p>
<ul>
<li><code class="rounded-sm bg-[#e5e5e5] px-[0.25rem] py-[0.20rem] text-xs font-normal leading-[15px] before:hidden after:hidden dark:bg-[#484848]/30">[a0, a1, a2, a3]</code> becomes <code class="rounded-sm bg-[#e5e5e5] px-[0.25rem] py-[0.20rem] text-xs font-normal leading-[15px] before:hidden after:hidden dark:bg-[#484848]/30">[a1, a2, a3, a0]</code></li>
</ul>
<p><strong>Sources:</strong> <a href="https://github.com/QinMoMeak/Simple_FingerPrint_Matching/blob/5cdd0b1a/AES_update/KeyExpansion.m#L7-L7" target="_blank" rel="noopener noreferrer" class="mb-1 mr-1 inline-flex items-stretch font-mono text-xs !no-underline transition-opacity hover:opacity-75"><span class="flex items-center break-all rounded-l px-2 py-1.5 bg-[#e5e5e5] text-[#333333] dark:bg-[#252525] dark:text-[#e4e4e4]"><svg class="mr-1.5 hidden h-3.5 w-3.5 flex-shrink-0 opacity-40 md:block" fill="currentColor" viewBox="0 0 24 24"><path d="M12 0c-6.626 0-12 5.373-12 12 0 5.302 3.438 9.8 8.207 11.387.599.111.793-.261.793-.577v-2.234c-3.338.726-4.033-1.416-4.033-1.416-.546-1.387-1.333-1.756-1.333-1.756-1.089-.745.083-.729.083-.729 1.205.084 1.839 1.237 1.839 1.237 1.07 1.834 2.807 1.304 3.492.997.107-.775.418-1.305.762-1.604-2.665-.305-5.467-1.334-5.467-5.931 0-1.311.469-2.381 1.236-3.221-.124-.303-.535-1.524.117-3.176 0 0 1.008-.322 3.301 1.23.957-.266 1.983-.399 3.003-.404 1.02.005 2.047.138 3.006.404 2.291-1.552 3.297-1.23 3.297-1.23.653 1.653.242 2.874.118 3.176.77.84 1.235 1.911 1.235 3.221 0 4.609-2.807 5.624-5.479 5.921.43.372.823 1.102.823 2.222v3.293c0 .319.192.694.801.576 4.765-1.589 8.199-6.086 8.199-11.386 0-6.627-5.373-12-12-12z"></path></svg>AES_update/KeyExpansion.m</span><span class="flex flex-shrink-0 items-center rounded-r border-l px-2 py-1.5 border-[#dddddd] bg-[#d8d8d8] text-[#666666] dark:border-[#333333] dark:bg-[#2a2a2a] dark:text-[#888888]">7</span></a></p>
<hr/>
<h3 id="subbytes-substitution" class="group" data-header="true">SubBytes Substitution<button class="relative ml-2 cursor-pointer align-baseline text-gray-400 opacity-0 transition-opacity hover:text-blue-400 focus:opacity-100 group-hover:opacity-100" aria-label="Copy link to header"><svg xmlns="http://www.w3.org/2000/svg" width="1em" height="1em" fill="currentColor" viewBox="0 0 256 256" class="h-4 w-4"><path d="M117.18,188.74a12,12,0,0,1,0,17l-5.12,5.12A58.26,58.26,0,0,1,70.6,228h0A58.62,58.62,0,0,1,29.14,127.92L63.89,93.17a58.64,58.64,0,0,1,98.56,28.11,12,12,0,1,1-23.37,5.44,34.65,34.65,0,0,0-58.22-16.58L46.11,144.89A34.62,34.62,0,0,0,70.57,204h0a34.41,34.41,0,0,0,24.49-10.14l5.11-5.12A12,12,0,0,1,117.18,188.74ZM226.83,45.17a58.65,58.65,0,0,0-82.93,0l-5.11,5.11a12,12,0,0,0,17,17l5.12-5.12a34.63,34.63,0,1,1,49,49L175.1,145.86A34.39,34.39,0,0,1,150.61,156h0a34.63,34.63,0,0,1-33.69-26.72,12,12,0,0,0-23.38,5.44A58.64,58.64,0,0,0,150.56,180h.05a58.28,58.28,0,0,0,41.47-17.17l34.75-34.75a58.62,58.62,0,0,0,0-82.91Z"></path></svg></button></h3>
<p>The <code class="rounded-sm bg-[#e5e5e5] px-[0.25rem] py-[0.20rem] text-xs font-normal leading-[15px] before:hidden after:hidden dark:bg-[#484848]/30">SubBytes</code> function (<a href="https://github.com/QinMoMeak/Simple_FingerPrint_Matching/blob/5cdd0b1a/AES_update/SubBytes.m#L1-L20" target="_blank" rel="noopener noreferrer" class="mb-1 mr-1 inline-flex items-stretch font-mono text-xs !no-underline transition-opacity hover:opacity-75"><span class="flex items-center break-all rounded-l px-2 py-1.5 bg-[#e5e5e5] text-[#333333] dark:bg-[#252525] dark:text-[#e4e4e4]"><svg class="mr-1.5 hidden h-3.5 w-3.5 flex-shrink-0 opacity-40 md:block" fill="currentColor" viewBox="0 0 24 24"><path d="M12 0c-6.626 0-12 5.373-12 12 0 5.302 3.438 9.8 8.207 11.387.599.111.793-.261.793-.577v-2.234c-3.338.726-4.033-1.416-4.033-1.416-.546-1.387-1.333-1.756-1.333-1.756-1.089-.745.083-.729.083-.729 1.205.084 1.839 1.237 1.839 1.237 1.07 1.834 2.807 1.304 3.492.997.107-.775.418-1.305.762-1.604-2.665-.305-5.467-1.334-5.467-5.931 0-1.311.469-2.381 1.236-3.221-.124-.303-.535-1.524.117-3.176 0 0 1.008-.322 3.301 1.23.957-.266 1.983-.399 3.003-.404 1.02.005 2.047.138 3.006.404 2.291-1.552 3.297-1.23 3.297-1.23.653 1.653.242 2.874.118 3.176.77.84 1.235 1.911 1.235 3.221 0 4.609-2.807 5.624-5.479 5.921.43.372.823 1.102.823 2.222v3.293c0 .319.192.694.801.576 4.765-1.589 8.199-6.086 8.199-11.386 0-6.627-5.373-12-12-12z"></path></svg>AES_update/SubBytes.m</span><span class="flex flex-shrink-0 items-center rounded-r border-l px-2 py-1.5 border-[#dddddd] bg-[#d8d8d8] text-[#666666] dark:border-[#333333] dark:bg-[#2a2a2a] dark:text-[#888888]">1-20</span></a>) is applied in two contexts:</p>
<ol>
<li><strong>Primary Path</strong> (<a href="https://github.com/QinMoMeak/Simple_FingerPrint_Matching/blob/5cdd0b1a/AES_update/KeyExpansion.m#L7-L7" target="_blank" rel="noopener noreferrer" class="mb-1 mr-1 inline-flex items-stretch font-mono text-xs !no-underline transition-opacity hover:opacity-75"><span class="flex items-center break-all rounded-l px-2 py-1.5 bg-[#e5e5e5] text-[#333333] dark:bg-[#252525] dark:text-[#e4e4e4]"><svg class="mr-1.5 hidden h-3.5 w-3.5 flex-shrink-0 opacity-40 md:block" fill="currentColor" viewBox="0 0 24 24"><path d="M12 0c-6.626 0-12 5.373-12 12 0 5.302 3.438 9.8 8.207 11.387.599.111.793-.261.793-.577v-2.234c-3.338.726-4.033-1.416-4.033-1.416-.546-1.387-1.333-1.756-1.333-1.756-1.089-.745.083-.729.083-.729 1.205.084 1.839 1.237 1.839 1.237 1.07 1.834 2.807 1.304 3.492.997.107-.775.418-1.305.762-1.604-2.665-.305-5.467-1.334-5.467-5.931 0-1.311.469-2.381 1.236-3.221-.124-.303-.535-1.524.117-3.176 0 0 1.008-.322 3.301 1.23.957-.266 1.983-.399 3.003-.404 1.02.005 2.047.138 3.006.404 2.291-1.552 3.297-1.23 3.297-1.23.653 1.653.242 2.874.118 3.176.77.84 1.235 1.911 1.235 3.221 0 4.609-2.807 5.624-5.479 5.921.43.372.823 1.102.823 2.222v3.293c0 .319.192.694.801.576 4.765-1.589 8.199-6.086 8.199-11.386 0-6.627-5.373-12-12-12z"></path></svg>AES_update/KeyExpansion.m</span><span class="flex flex-shrink-0 items-center rounded-r border-l px-2 py-1.5 border-[#dddddd] bg-[#d8d8d8] text-[#666666] dark:border-[#333333] dark:bg-[#2a2a2a] dark:text-[#888888]">7</span></a>): After RotWord when <code class="rounded-sm bg-[#e5e5e5] px-[0.25rem] py-[0.20rem] text-xs font-normal leading-[15px] before:hidden after:hidden dark:bg-[#484848]/30">i mod Nk == 0</code></li>
<li><strong>AES-256 Path</strong> (<a href="https://github.com/QinMoMeak/Simple_FingerPrint_Matching/blob/5cdd0b1a/AES_update/KeyExpansion.m#L16-L16" target="_blank" rel="noopener noreferrer" class="mb-1 mr-1 inline-flex items-stretch font-mono text-xs !no-underline transition-opacity hover:opacity-75"><span class="flex items-center break-all rounded-l px-2 py-1.5 bg-[#e5e5e5] text-[#333333] dark:bg-[#252525] dark:text-[#e4e4e4]"><svg class="mr-1.5 hidden h-3.5 w-3.5 flex-shrink-0 opacity-40 md:block" fill="currentColor" viewBox="0 0 24 24"><path d="M12 0c-6.626 0-12 5.373-12 12 0 5.302 3.438 9.8 8.207 11.387.599.111.793-.261.793-.577v-2.234c-3.338.726-4.033-1.416-4.033-1.416-.546-1.387-1.333-1.756-1.333-1.756-1.089-.745.083-.729.083-.729 1.205.084 1.839 1.237 1.839 1.237 1.07 1.834 2.807 1.304 3.492.997.107-.775.418-1.305.762-1.604-2.665-.305-5.467-1.334-5.467-5.931 0-1.311.469-2.381 1.236-3.221-.124-.303-.535-1.524.117-3.176 0 0 1.008-.322 3.301 1.23.957-.266 1.983-.399 3.003-.404 1.02.005 2.047.138 3.006.404 2.291-1.552 3.297-1.23 3.297-1.23.653 1.653.242 2.874.118 3.176.77.84 1.235 1.911 1.235 3.221 0 4.609-2.807 5.624-5.479 5.921.43.372.823 1.102.823 2.222v3.293c0 .319.192.694.801.576 4.765-1.589 8.199-6.086 8.199-11.386 0-6.627-5.373-12-12-12z"></path></svg>AES_update/KeyExpansion.m</span><span class="flex flex-shrink-0 items-center rounded-r border-l px-2 py-1.5 border-[#dddddd] bg-[#d8d8d8] text-[#666666] dark:border-[#333333] dark:bg-[#2a2a2a] dark:text-[#888888]">16</span></a>): When <code class="rounded-sm bg-[#e5e5e5] px-[0.25rem] py-[0.20rem] text-xs font-normal leading-[15px] before:hidden after:hidden dark:bg-[#484848]/30">Nk &gt; 6</code> and <code class="rounded-sm bg-[#e5e5e5] px-[0.25rem] py-[0.20rem] text-xs font-normal leading-[15px] before:hidden after:hidden dark:bg-[#484848]/30">i mod 8 == 4</code></li>
</ol>
<p>The substitution uses the AES S-box lookup table to replace each byte with a non-linear transformation. For details on the S-box structure, see <a href="2.2.1-subbytes-transformation.html" class="text-neutral-300 hover:text-neutral-200 hover:underline">SubBytes Transformation</a>.</p>
<p><strong>Sources:</strong> <a href="https://github.com/QinMoMeak/Simple_FingerPrint_Matching/blob/5cdd0b1a/AES_update/KeyExpansion.m#L7-L16" target="_blank" rel="noopener noreferrer" class="mb-1 mr-1 inline-flex items-stretch font-mono text-xs !no-underline transition-opacity hover:opacity-75"><span class="flex items-center break-all rounded-l px-2 py-1.5 bg-[#e5e5e5] text-[#333333] dark:bg-[#252525] dark:text-[#e4e4e4]"><svg class="mr-1.5 hidden h-3.5 w-3.5 flex-shrink-0 opacity-40 md:block" fill="currentColor" viewBox="0 0 24 24"><path d="M12 0c-6.626 0-12 5.373-12 12 0 5.302 3.438 9.8 8.207 11.387.599.111.793-.261.793-.577v-2.234c-3.338.726-4.033-1.416-4.033-1.416-.546-1.387-1.333-1.756-1.333-1.756-1.089-.745.083-.729.083-.729 1.205.084 1.839 1.237 1.839 1.237 1.07 1.834 2.807 1.304 3.492.997.107-.775.418-1.305.762-1.604-2.665-.305-5.467-1.334-5.467-5.931 0-1.311.469-2.381 1.236-3.221-.124-.303-.535-1.524.117-3.176 0 0 1.008-.322 3.301 1.23.957-.266 1.983-.399 3.003-.404 1.02.005 2.047.138 3.006.404 2.291-1.552 3.297-1.23 3.297-1.23.653 1.653.242 2.874.118 3.176.77.84 1.235 1.911 1.235 3.221 0 4.609-2.807 5.624-5.479 5.921.43.372.823 1.102.823 2.222v3.293c0 .319.192.694.801.576 4.765-1.589 8.199-6.086 8.199-11.386 0-6.627-5.373-12-12-12z"></path></svg>AES_update/KeyExpansion.m</span><span class="flex flex-shrink-0 items-center rounded-r border-l px-2 py-1.5 border-[#dddddd] bg-[#d8d8d8] text-[#666666] dark:border-[#333333] dark:bg-[#2a2a2a] dark:text-[#888888]">7-16</span></a> <a href="https://github.com/QinMoMeak/Simple_FingerPrint_Matching/blob/5cdd0b1a/AES_update/SubBytes.m#L1-L20" target="_blank" rel="noopener noreferrer" class="mb-1 mr-1 inline-flex items-stretch font-mono text-xs !no-underline transition-opacity hover:opacity-75"><span class="flex items-center break-all rounded-l px-2 py-1.5 bg-[#e5e5e5] text-[#333333] dark:bg-[#252525] dark:text-[#e4e4e4]"><svg class="mr-1.5 hidden h-3.5 w-3.5 flex-shrink-0 opacity-40 md:block" fill="currentColor" viewBox="0 0 24 24"><path d="M12 0c-6.626 0-12 5.373-12 12 0 5.302 3.438 9.8 8.207 11.387.599.111.793-.261.793-.577v-2.234c-3.338.726-4.033-1.416-4.033-1.416-.546-1.387-1.333-1.756-1.333-1.756-1.089-.745.083-.729.083-.729 1.205.084 1.839 1.237 1.839 1.237 1.07 1.834 2.807 1.304 3.492.997.107-.775.418-1.305.762-1.604-2.665-.305-5.467-1.334-5.467-5.931 0-1.311.469-2.381 1.236-3.221-.124-.303-.535-1.524.117-3.176 0 0 1.008-.322 3.301 1.23.957-.266 1.983-.399 3.003-.404 1.02.005 2.047.138 3.006.404 2.291-1.552 3.297-1.23 3.297-1.23.653 1.653.242 2.874.118 3.176.77.84 1.235 1.911 1.235 3.221 0 4.609-2.807 5.624-5.479 5.921.43.372.823 1.102.823 2.222v3.293c0 .319.192.694.801.576 4.765-1.589 8.199-6.086 8.199-11.386 0-6.627-5.373-12-12-12z"></path></svg>AES_update/SubBytes.m</span><span class="flex flex-shrink-0 items-center rounded-r border-l px-2 py-1.5 border-[#dddddd] bg-[#d8d8d8] text-[#666666] dark:border-[#333333] dark:bg-[#2a2a2a] dark:text-[#888888]">1-20</span></a></p>
<hr/>
<h3 id="round-constant-rcon-generation" class="group" data-header="true">Round Constant (Rcon) Generation<button class="relative ml-2 cursor-pointer align-baseline text-gray-400 opacity-0 transition-opacity hover:text-blue-400 focus:opacity-100 group-hover:opacity-100" aria-label="Copy link to header"><svg xmlns="http://www.w3.org/2000/svg" width="1em" height="1em" fill="currentColor" viewBox="0 0 256 256" class="h-4 w-4"><path d="M117.18,188.74a12,12,0,0,1,0,17l-5.12,5.12A58.26,58.26,0,0,1,70.6,228h0A58.62,58.62,0,0,1,29.14,127.92L63.89,93.17a58.64,58.64,0,0,1,98.56,28.11,12,12,0,1,1-23.37,5.44,34.65,34.65,0,0,0-58.22-16.58L46.11,144.89A34.62,34.62,0,0,0,70.57,204h0a34.41,34.41,0,0,0,24.49-10.14l5.11-5.12A12,12,0,0,1,117.18,188.74ZM226.83,45.17a58.65,58.65,0,0,0-82.93,0l-5.11,5.11a12,12,0,0,0,17,17l5.12-5.12a34.63,34.63,0,1,1,49,49L175.1,145.86A34.39,34.39,0,0,1,150.61,156h0a34.63,34.63,0,0,1-33.69-26.72,12,12,0,0,0-23.38,5.44A58.64,58.64,0,0,0,150.56,180h.05a58.28,58.28,0,0,0,41.47-17.17l34.75-34.75a58.62,58.62,0,0,0,0-82.91Z"></path></svg></button></h3>
<pre class="px-2 py-1.5 has-[code]:rounded-md has-[code]:!bg-[#e5e5e5] has-[div]:bg-transparent has-[div]:!p-0 has-[code]:text-stone-900 dark:has-[code]:!bg-[#242424] has-[code]:dark:text-white [&amp;_code]:block [&amp;_code]:border-none [&amp;_code]:bg-transparent [&amp;_code]:p-0"><!--$!--><template data-dgst="BAILOUT_TO_CLIENT_SIDE_RENDERING"></template><!--/$--></pre>
<p><strong>Diagram: Round Constant Computation Using xtime</strong></p>
<p>The round constant <code class="rounded-sm bg-[#e5e5e5] px-[0.25rem] py-[0.20rem] text-xs font-normal leading-[15px] before:hidden after:hidden dark:bg-[#484848]/30">Rcon[i/Nk]</code> is computed through repeated Galois field multiplication (<a href="https://github.com/QinMoMeak/Simple_FingerPrint_Matching/blob/5cdd0b1a/AES_update/KeyExpansion.m#L8-L14" target="_blank" rel="noopener noreferrer" class="mb-1 mr-1 inline-flex items-stretch font-mono text-xs !no-underline transition-opacity hover:opacity-75"><span class="flex items-center break-all rounded-l px-2 py-1.5 bg-[#e5e5e5] text-[#333333] dark:bg-[#252525] dark:text-[#e4e4e4]"><svg class="mr-1.5 hidden h-3.5 w-3.5 flex-shrink-0 opacity-40 md:block" fill="currentColor" viewBox="0 0 24 24"><path d="M12 0c-6.626 0-12 5.373-12 12 0 5.302 3.438 9.8 8.207 11.387.599.111.793-.261.793-.577v-2.234c-3.338.726-4.033-1.416-4.033-1.416-.546-1.387-1.333-1.756-1.333-1.756-1.089-.745.083-.729.083-.729 1.205.084 1.839 1.237 1.839 1.237 1.07 1.834 2.807 1.304 3.492.997.107-.775.418-1.305.762-1.604-2.665-.305-5.467-1.334-5.467-5.931 0-1.311.469-2.381 1.236-3.221-.124-.303-.535-1.524.117-3.176 0 0 1.008-.322 3.301 1.23.957-.266 1.983-.399 3.003-.404 1.02.005 2.047.138 3.006.404 2.291-1.552 3.297-1.23 3.297-1.23.653 1.653.242 2.874.118 3.176.77.84 1.235 1.911 1.235 3.221 0 4.609-2.807 5.624-5.479 5.921.43.372.823 1.102.823 2.222v3.293c0 .319.192.694.801.576 4.765-1.589 8.199-6.086 8.199-11.386 0-6.627-5.373-12-12-12z"></path></svg>AES_update/KeyExpansion.m</span><span class="flex flex-shrink-0 items-center rounded-r border-l px-2 py-1.5 border-[#dddddd] bg-[#d8d8d8] text-[#666666] dark:border-[#333333] dark:bg-[#2a2a2a] dark:text-[#888888]">8-14</span></a>):</p>







































































<table><thead><tr><th>Round</th><th>i/Nk</th><th>Rcon Value (hex)</th><th>Computation</th></tr></thead><tbody><tr><td>1</td><td>1</td><td>01</td><td>2^0</td></tr><tr><td>2</td><td>2</td><td>02</td><td>2^1</td></tr><tr><td>3</td><td>3</td><td>04</td><td>2^2</td></tr><tr><td>4</td><td>4</td><td>08</td><td>2^3</td></tr><tr><td>5</td><td>5</td><td>10</td><td>2^4</td></tr><tr><td>6</td><td>6</td><td>20</td><td>2^5</td></tr><tr><td>7</td><td>7</td><td>40</td><td>2^6</td></tr><tr><td>8</td><td>8</td><td>80</td><td>2^7</td></tr><tr><td>9</td><td>9</td><td>1B</td><td>2^8 mod (x^8+x^4+x^3+x+1)</td></tr><tr><td>10</td><td>10</td><td>36</td><td>2^9 mod (x^8+x^4+x^3+x+1)</td></tr></tbody></table>
<p>The <code class="rounded-sm bg-[#e5e5e5] px-[0.25rem] py-[0.20rem] text-xs font-normal leading-[15px] before:hidden after:hidden dark:bg-[#484848]/30">xtime</code> function (<a href="https://github.com/QinMoMeak/Simple_FingerPrint_Matching/blob/5cdd0b1a/AES_update/xtime.m#L1-L18" target="_blank" rel="noopener noreferrer" class="mb-1 mr-1 inline-flex items-stretch font-mono text-xs !no-underline transition-opacity hover:opacity-75"><span class="flex items-center break-all rounded-l px-2 py-1.5 bg-[#e5e5e5] text-[#333333] dark:bg-[#252525] dark:text-[#e4e4e4]"><svg class="mr-1.5 hidden h-3.5 w-3.5 flex-shrink-0 opacity-40 md:block" fill="currentColor" viewBox="0 0 24 24"><path d="M12 0c-6.626 0-12 5.373-12 12 0 5.302 3.438 9.8 8.207 11.387.599.111.793-.261.793-.577v-2.234c-3.338.726-4.033-1.416-4.033-1.416-.546-1.387-1.333-1.756-1.333-1.756-1.089-.745.083-.729.083-.729 1.205.084 1.839 1.237 1.839 1.237 1.07 1.834 2.807 1.304 3.492.997.107-.775.418-1.305.762-1.604-2.665-.305-5.467-1.334-5.467-5.931 0-1.311.469-2.381 1.236-3.221-.124-.303-.535-1.524.117-3.176 0 0 1.008-.322 3.301 1.23.957-.266 1.983-.399 3.003-.404 1.02.005 2.047.138 3.006.404 2.291-1.552 3.297-1.23 3.297-1.23.653 1.653.242 2.874.118 3.176.77.84 1.235 1.911 1.235 3.221 0 4.609-2.807 5.624-5.479 5.921.43.372.823 1.102.823 2.222v3.293c0 .319.192.694.801.576 4.765-1.589 8.199-6.086 8.199-11.386 0-6.627-5.373-12-12-12z"></path></svg>AES_update/xtime.m</span><span class="flex flex-shrink-0 items-center rounded-r border-l px-2 py-1.5 border-[#dddddd] bg-[#d8d8d8] text-[#666666] dark:border-[#333333] dark:bg-[#2a2a2a] dark:text-[#888888]">1-18</span></a>) performs multiplication in GF(2^8) using the irreducible polynomial <code class="rounded-sm bg-[#e5e5e5] px-[0.25rem] py-[0.20rem] text-xs font-normal leading-[15px] before:hidden after:hidden dark:bg-[#484848]/30">x^8 + x^4 + x^3 + x + 1</code> (represented as 0x11B). For detailed explanation of Galois field arithmetic, see <a href="2.4-galois-field-arithmetic.html" class="text-neutral-300 hover:text-neutral-200 hover:underline">Galois Field Arithmetic</a>.</p>
<p>The round constant is applied only to the first byte: <code class="rounded-sm bg-[#e5e5e5] px-[0.25rem] py-[0.20rem] text-xs font-normal leading-[15px] before:hidden after:hidden dark:bg-[#484848]/30">bitxor(temp, [n,0,0,0]&#x27;)</code></p>
<p><strong>Sources:</strong> <a href="https://github.com/QinMoMeak/Simple_FingerPrint_Matching/blob/5cdd0b1a/AES_update/KeyExpansion.m#L8-L14" target="_blank" rel="noopener noreferrer" class="mb-1 mr-1 inline-flex items-stretch font-mono text-xs !no-underline transition-opacity hover:opacity-75"><span class="flex items-center break-all rounded-l px-2 py-1.5 bg-[#e5e5e5] text-[#333333] dark:bg-[#252525] dark:text-[#e4e4e4]"><svg class="mr-1.5 hidden h-3.5 w-3.5 flex-shrink-0 opacity-40 md:block" fill="currentColor" viewBox="0 0 24 24"><path d="M12 0c-6.626 0-12 5.373-12 12 0 5.302 3.438 9.8 8.207 11.387.599.111.793-.261.793-.577v-2.234c-3.338.726-4.033-1.416-4.033-1.416-.546-1.387-1.333-1.756-1.333-1.756-1.089-.745.083-.729.083-.729 1.205.084 1.839 1.237 1.839 1.237 1.07 1.834 2.807 1.304 3.492.997.107-.775.418-1.305.762-1.604-2.665-.305-5.467-1.334-5.467-5.931 0-1.311.469-2.381 1.236-3.221-.124-.303-.535-1.524.117-3.176 0 0 1.008-.322 3.301 1.23.957-.266 1.983-.399 3.003-.404 1.02.005 2.047.138 3.006.404 2.291-1.552 3.297-1.23 3.297-1.23.653 1.653.242 2.874.118 3.176.77.84 1.235 1.911 1.235 3.221 0 4.609-2.807 5.624-5.479 5.921.43.372.823 1.102.823 2.222v3.293c0 .319.192.694.801.576 4.765-1.589 8.199-6.086 8.199-11.386 0-6.627-5.373-12-12-12z"></path></svg>AES_update/KeyExpansion.m</span><span class="flex flex-shrink-0 items-center rounded-r border-l px-2 py-1.5 border-[#dddddd] bg-[#d8d8d8] text-[#666666] dark:border-[#333333] dark:bg-[#2a2a2a] dark:text-[#888888]">8-14</span></a> <a href="https://github.com/QinMoMeak/Simple_FingerPrint_Matching/blob/5cdd0b1a/AES_update/xtime.m#L1-L18" target="_blank" rel="noopener noreferrer" class="mb-1 mr-1 inline-flex items-stretch font-mono text-xs !no-underline transition-opacity hover:opacity-75"><span class="flex items-center break-all rounded-l px-2 py-1.5 bg-[#e5e5e5] text-[#333333] dark:bg-[#252525] dark:text-[#e4e4e4]"><svg class="mr-1.5 hidden h-3.5 w-3.5 flex-shrink-0 opacity-40 md:block" fill="currentColor" viewBox="0 0 24 24"><path d="M12 0c-6.626 0-12 5.373-12 12 0 5.302 3.438 9.8 8.207 11.387.599.111.793-.261.793-.577v-2.234c-3.338.726-4.033-1.416-4.033-1.416-.546-1.387-1.333-1.756-1.333-1.756-1.089-.745.083-.729.083-.729 1.205.084 1.839 1.237 1.839 1.237 1.07 1.834 2.807 1.304 3.492.997.107-.775.418-1.305.762-1.604-2.665-.305-5.467-1.334-5.467-5.931 0-1.311.469-2.381 1.236-3.221-.124-.303-.535-1.524.117-3.176 0 0 1.008-.322 3.301 1.23.957-.266 1.983-.399 3.003-.404 1.02.005 2.047.138 3.006.404 2.291-1.552 3.297-1.23 3.297-1.23.653 1.653.242 2.874.118 3.176.77.84 1.235 1.911 1.235 3.221 0 4.609-2.807 5.624-5.479 5.921.43.372.823 1.102.823 2.222v3.293c0 .319.192.694.801.576 4.765-1.589 8.199-6.086 8.199-11.386 0-6.627-5.373-12-12-12z"></path></svg>AES_update/xtime.m</span><span class="flex flex-shrink-0 items-center rounded-r border-l px-2 py-1.5 border-[#dddddd] bg-[#d8d8d8] text-[#666666] dark:border-[#333333] dark:bg-[#2a2a2a] dark:text-[#888888]">1-18</span></a></p>
<hr/>
<h2 id="aes-256-special-case" class="group" data-header="true">AES-256 Special Case<button class="relative ml-2 cursor-pointer align-baseline text-gray-400 opacity-0 transition-opacity hover:text-blue-400 focus:opacity-100 group-hover:opacity-100" aria-label="Copy link to header"><svg xmlns="http://www.w3.org/2000/svg" width="1em" height="1em" fill="currentColor" viewBox="0 0 256 256" class="h-4 w-4"><path d="M117.18,188.74a12,12,0,0,1,0,17l-5.12,5.12A58.26,58.26,0,0,1,70.6,228h0A58.62,58.62,0,0,1,29.14,127.92L63.89,93.17a58.64,58.64,0,0,1,98.56,28.11,12,12,0,1,1-23.37,5.44,34.65,34.65,0,0,0-58.22-16.58L46.11,144.89A34.62,34.62,0,0,0,70.57,204h0a34.41,34.41,0,0,0,24.49-10.14l5.11-5.12A12,12,0,0,1,117.18,188.74ZM226.83,45.17a58.65,58.65,0,0,0-82.93,0l-5.11,5.11a12,12,0,0,0,17,17l5.12-5.12a34.63,34.63,0,1,1,49,49L175.1,145.86A34.39,34.39,0,0,1,150.61,156h0a34.63,34.63,0,0,1-33.69-26.72,12,12,0,0,0-23.38,5.44A58.64,58.64,0,0,0,150.56,180h.05a58.28,58.28,0,0,0,41.47-17.17l34.75-34.75a58.62,58.62,0,0,0,0-82.91Z"></path></svg></button></h2>
<p>For AES-256 (<code class="rounded-sm bg-[#e5e5e5] px-[0.25rem] py-[0.20rem] text-xs font-normal leading-[15px] before:hidden after:hidden dark:bg-[#484848]/30">Nk = 8</code>), an additional <code class="rounded-sm bg-[#e5e5e5] px-[0.25rem] py-[0.20rem] text-xs font-normal leading-[15px] before:hidden after:hidden dark:bg-[#484848]/30">SubBytes</code> transformation is applied (<a href="https://github.com/QinMoMeak/Simple_FingerPrint_Matching/blob/5cdd0b1a/AES_update/KeyExpansion.m#L15-L16" target="_blank" rel="noopener noreferrer" class="mb-1 mr-1 inline-flex items-stretch font-mono text-xs !no-underline transition-opacity hover:opacity-75"><span class="flex items-center break-all rounded-l px-2 py-1.5 bg-[#e5e5e5] text-[#333333] dark:bg-[#252525] dark:text-[#e4e4e4]"><svg class="mr-1.5 hidden h-3.5 w-3.5 flex-shrink-0 opacity-40 md:block" fill="currentColor" viewBox="0 0 24 24"><path d="M12 0c-6.626 0-12 5.373-12 12 0 5.302 3.438 9.8 8.207 11.387.599.111.793-.261.793-.577v-2.234c-3.338.726-4.033-1.416-4.033-1.416-.546-1.387-1.333-1.756-1.333-1.756-1.089-.745.083-.729.083-.729 1.205.084 1.839 1.237 1.839 1.237 1.07 1.834 2.807 1.304 3.492.997.107-.775.418-1.305.762-1.604-2.665-.305-5.467-1.334-5.467-5.931 0-1.311.469-2.381 1.236-3.221-.124-.303-.535-1.524.117-3.176 0 0 1.008-.322 3.301 1.23.957-.266 1.983-.399 3.003-.404 1.02.005 2.047.138 3.006.404 2.291-1.552 3.297-1.23 3.297-1.23.653 1.653.242 2.874.118 3.176.77.84 1.235 1.911 1.235 3.221 0 4.609-2.807 5.624-5.479 5.921.43.372.823 1.102.823 2.222v3.293c0 .319.192.694.801.576 4.765-1.589 8.199-6.086 8.199-11.386 0-6.627-5.373-12-12-12z"></path></svg>AES_update/KeyExpansion.m</span><span class="flex flex-shrink-0 items-center rounded-r border-l px-2 py-1.5 border-[#dddddd] bg-[#d8d8d8] text-[#666666] dark:border-[#333333] dark:bg-[#2a2a2a] dark:text-[#888888]">15-16</span></a>):</p>
<pre class="px-2 py-1.5 has-[code]:rounded-md has-[code]:!bg-[#e5e5e5] has-[div]:bg-transparent has-[div]:!p-0 has-[code]:text-stone-900 dark:has-[code]:!bg-[#242424] has-[code]:dark:text-white [&amp;_code]:block [&amp;_code]:border-none [&amp;_code]:bg-transparent [&amp;_code]:p-0"><div class="rounded-sm border border-[#8F8F8F]/30 p-2 text-xs font-normal leading-[15px]" style="background-color:transparent;min-height:2em"></div></pre>
<p>This occurs every 8 words at positions where <code class="rounded-sm bg-[#e5e5e5] px-[0.25rem] py-[0.20rem] text-xs font-normal leading-[15px] before:hidden after:hidden dark:bg-[#484848]/30">i mod 8 == 4</code>, providing additional diffusion for the longer 256-bit keys. This extra substitution is unique to AES-256 and does not occur in AES-128 or AES-192.</p>
<p><strong>Sources:</strong> <a href="https://github.com/QinMoMeak/Simple_FingerPrint_Matching/blob/5cdd0b1a/AES_update/KeyExpansion.m#L15-L16" target="_blank" rel="noopener noreferrer" class="mb-1 mr-1 inline-flex items-stretch font-mono text-xs !no-underline transition-opacity hover:opacity-75"><span class="flex items-center break-all rounded-l px-2 py-1.5 bg-[#e5e5e5] text-[#333333] dark:bg-[#252525] dark:text-[#e4e4e4]"><svg class="mr-1.5 hidden h-3.5 w-3.5 flex-shrink-0 opacity-40 md:block" fill="currentColor" viewBox="0 0 24 24"><path d="M12 0c-6.626 0-12 5.373-12 12 0 5.302 3.438 9.8 8.207 11.387.599.111.793-.261.793-.577v-2.234c-3.338.726-4.033-1.416-4.033-1.416-.546-1.387-1.333-1.756-1.333-1.756-1.089-.745.083-.729.083-.729 1.205.084 1.839 1.237 1.839 1.237 1.07 1.834 2.807 1.304 3.492.997.107-.775.418-1.305.762-1.604-2.665-.305-5.467-1.334-5.467-5.931 0-1.311.469-2.381 1.236-3.221-.124-.303-.535-1.524.117-3.176 0 0 1.008-.322 3.301 1.23.957-.266 1.983-.399 3.003-.404 1.02.005 2.047.138 3.006.404 2.291-1.552 3.297-1.23 3.297-1.23.653 1.653.242 2.874.118 3.176.77.84 1.235 1.911 1.235 3.221 0 4.609-2.807 5.624-5.479 5.921.43.372.823 1.102.823 2.222v3.293c0 .319.192.694.801.576 4.765-1.589 8.199-6.086 8.199-11.386 0-6.627-5.373-12-12-12z"></path></svg>AES_update/KeyExpansion.m</span><span class="flex flex-shrink-0 items-center rounded-r border-l px-2 py-1.5 border-[#dddddd] bg-[#d8d8d8] text-[#666666] dark:border-[#333333] dark:bg-[#2a2a2a] dark:text-[#888888]">15-16</span></a></p>
<hr/>
<h2 id="final-xor-operation" class="group" data-header="true">Final XOR Operation<button class="relative ml-2 cursor-pointer align-baseline text-gray-400 opacity-0 transition-opacity hover:text-blue-400 focus:opacity-100 group-hover:opacity-100" aria-label="Copy link to header"><svg xmlns="http://www.w3.org/2000/svg" width="1em" height="1em" fill="currentColor" viewBox="0 0 256 256" class="h-4 w-4"><path d="M117.18,188.74a12,12,0,0,1,0,17l-5.12,5.12A58.26,58.26,0,0,1,70.6,228h0A58.62,58.62,0,0,1,29.14,127.92L63.89,93.17a58.64,58.64,0,0,1,98.56,28.11,12,12,0,1,1-23.37,5.44,34.65,34.65,0,0,0-58.22-16.58L46.11,144.89A34.62,34.62,0,0,0,70.57,204h0a34.41,34.41,0,0,0,24.49-10.14l5.11-5.12A12,12,0,0,1,117.18,188.74ZM226.83,45.17a58.65,58.65,0,0,0-82.93,0l-5.11,5.11a12,12,0,0,0,17,17l5.12-5.12a34.63,34.63,0,1,1,49,49L175.1,145.86A34.39,34.39,0,0,1,150.61,156h0a34.63,34.63,0,0,1-33.69-26.72,12,12,0,0,0-23.38,5.44A58.64,58.64,0,0,0,150.56,180h.05a58.28,58.28,0,0,0,41.47-17.17l34.75-34.75a58.62,58.62,0,0,0,0-82.91Z"></path></svg></button></h2>
<p>All word generation paths converge to the final XOR operation (<a href="https://github.com/QinMoMeak/Simple_FingerPrint_Matching/blob/5cdd0b1a/AES_update/KeyExpansion.m#L18-L18" target="_blank" rel="noopener noreferrer" class="mb-1 mr-1 inline-flex items-stretch font-mono text-xs !no-underline transition-opacity hover:opacity-75"><span class="flex items-center break-all rounded-l px-2 py-1.5 bg-[#e5e5e5] text-[#333333] dark:bg-[#252525] dark:text-[#e4e4e4]"><svg class="mr-1.5 hidden h-3.5 w-3.5 flex-shrink-0 opacity-40 md:block" fill="currentColor" viewBox="0 0 24 24"><path d="M12 0c-6.626 0-12 5.373-12 12 0 5.302 3.438 9.8 8.207 11.387.599.111.793-.261.793-.577v-2.234c-3.338.726-4.033-1.416-4.033-1.416-.546-1.387-1.333-1.756-1.333-1.756-1.089-.745.083-.729.083-.729 1.205.084 1.839 1.237 1.839 1.237 1.07 1.834 2.807 1.304 3.492.997.107-.775.418-1.305.762-1.604-2.665-.305-5.467-1.334-5.467-5.931 0-1.311.469-2.381 1.236-3.221-.124-.303-.535-1.524.117-3.176 0 0 1.008-.322 3.301 1.23.957-.266 1.983-.399 3.003-.404 1.02.005 2.047.138 3.006.404 2.291-1.552 3.297-1.23 3.297-1.23.653 1.653.242 2.874.118 3.176.77.84 1.235 1.911 1.235 3.221 0 4.609-2.807 5.624-5.479 5.921.43.372.823 1.102.823 2.222v3.293c0 .319.192.694.801.576 4.765-1.589 8.199-6.086 8.199-11.386 0-6.627-5.373-12-12-12z"></path></svg>AES_update/KeyExpansion.m</span><span class="flex flex-shrink-0 items-center rounded-r border-l px-2 py-1.5 border-[#dddddd] bg-[#d8d8d8] text-[#666666] dark:border-[#333333] dark:bg-[#2a2a2a] dark:text-[#888888]">18</span></a>):</p>
<pre class="px-2 py-1.5 has-[code]:rounded-md has-[code]:!bg-[#e5e5e5] has-[div]:bg-transparent has-[div]:!p-0 has-[code]:text-stone-900 dark:has-[code]:!bg-[#242424] has-[code]:dark:text-white [&amp;_code]:block [&amp;_code]:border-none [&amp;_code]:bg-transparent [&amp;_code]:p-0"><div class="rounded-sm border border-[#8F8F8F]/30 p-2 text-xs font-normal leading-[15px]" style="background-color:transparent;min-height:2em"></div></pre>
<p>This combines:</p>
<ul>
<li><code class="rounded-sm bg-[#e5e5e5] px-[0.25rem] py-[0.20rem] text-xs font-normal leading-[15px] before:hidden after:hidden dark:bg-[#484848]/30">w[i-Nk+1]</code>: A word from <code class="rounded-sm bg-[#e5e5e5] px-[0.25rem] py-[0.20rem] text-xs font-normal leading-[15px] before:hidden after:hidden dark:bg-[#484848]/30">Nk</code> positions earlier in the schedule</li>
<li><code class="rounded-sm bg-[#e5e5e5] px-[0.25rem] py-[0.20rem] text-xs font-normal leading-[15px] before:hidden after:hidden dark:bg-[#484848]/30">temp</code>: The transformed version of <code class="rounded-sm bg-[#e5e5e5] px-[0.25rem] py-[0.20rem] text-xs font-normal leading-[15px] before:hidden after:hidden dark:bg-[#484848]/30">w[i]</code> (after RotWord, SubBytes, Rcon, or just passed through)</li>
</ul>
<p><strong>Sources:</strong> <a href="https://github.com/QinMoMeak/Simple_FingerPrint_Matching/blob/5cdd0b1a/AES_update/KeyExpansion.m#L18-L18" target="_blank" rel="noopener noreferrer" class="mb-1 mr-1 inline-flex items-stretch font-mono text-xs !no-underline transition-opacity hover:opacity-75"><span class="flex items-center break-all rounded-l px-2 py-1.5 bg-[#e5e5e5] text-[#333333] dark:bg-[#252525] dark:text-[#e4e4e4]"><svg class="mr-1.5 hidden h-3.5 w-3.5 flex-shrink-0 opacity-40 md:block" fill="currentColor" viewBox="0 0 24 24"><path d="M12 0c-6.626 0-12 5.373-12 12 0 5.302 3.438 9.8 8.207 11.387.599.111.793-.261.793-.577v-2.234c-3.338.726-4.033-1.416-4.033-1.416-.546-1.387-1.333-1.756-1.333-1.756-1.089-.745.083-.729.083-.729 1.205.084 1.839 1.237 1.839 1.237 1.07 1.834 2.807 1.304 3.492.997.107-.775.418-1.305.762-1.604-2.665-.305-5.467-1.334-5.467-5.931 0-1.311.469-2.381 1.236-3.221-.124-.303-.535-1.524.117-3.176 0 0 1.008-.322 3.301 1.23.957-.266 1.983-.399 3.003-.404 1.02.005 2.047.138 3.006.404 2.291-1.552 3.297-1.23 3.297-1.23.653 1.653.242 2.874.118 3.176.77.84 1.235 1.911 1.235 3.221 0 4.609-2.807 5.624-5.479 5.921.43.372.823 1.102.823 2.222v3.293c0 .319.192.694.801.576 4.765-1.589 8.199-6.086 8.199-11.386 0-6.627-5.373-12-12-12z"></path></svg>AES_update/KeyExpansion.m</span><span class="flex flex-shrink-0 items-center rounded-r border-l px-2 py-1.5 border-[#dddddd] bg-[#d8d8d8] text-[#666666] dark:border-[#333333] dark:bg-[#2a2a2a] dark:text-[#888888]">18</span></a></p>
<hr/>
<h2 id="code-to-algorithm-mapping" class="group" data-header="true">Code-to-Algorithm Mapping<button class="relative ml-2 cursor-pointer align-baseline text-gray-400 opacity-0 transition-opacity hover:text-blue-400 focus:opacity-100 group-hover:opacity-100" aria-label="Copy link to header"><svg xmlns="http://www.w3.org/2000/svg" width="1em" height="1em" fill="currentColor" viewBox="0 0 256 256" class="h-4 w-4"><path d="M117.18,188.74a12,12,0,0,1,0,17l-5.12,5.12A58.26,58.26,0,0,1,70.6,228h0A58.62,58.62,0,0,1,29.14,127.92L63.89,93.17a58.64,58.64,0,0,1,98.56,28.11,12,12,0,1,1-23.37,5.44,34.65,34.65,0,0,0-58.22-16.58L46.11,144.89A34.62,34.62,0,0,0,70.57,204h0a34.41,34.41,0,0,0,24.49-10.14l5.11-5.12A12,12,0,0,1,117.18,188.74ZM226.83,45.17a58.65,58.65,0,0,0-82.93,0l-5.11,5.11a12,12,0,0,0,17,17l5.12-5.12a34.63,34.63,0,1,1,49,49L175.1,145.86A34.39,34.39,0,0,1,150.61,156h0a34.63,34.63,0,0,1-33.69-26.72,12,12,0,0,0-23.38,5.44A58.64,58.64,0,0,0,150.56,180h.05a58.28,58.28,0,0,0,41.47-17.17l34.75-34.75a58.62,58.62,0,0,0,0-82.91Z"></path></svg></button></h2>
<pre class="px-2 py-1.5 has-[code]:rounded-md has-[code]:!bg-[#e5e5e5] has-[div]:bg-transparent has-[div]:!p-0 has-[code]:text-stone-900 dark:has-[code]:!bg-[#242424] has-[code]:dark:text-white [&amp;_code]:block [&amp;_code]:border-none [&amp;_code]:bg-transparent [&amp;_code]:p-0"><!--$!--><template data-dgst="BAILOUT_TO_CLIENT_SIDE_RENDERING"></template><!--/$--></pre>
<p><strong>Diagram: Mapping Between Code Lines and AES Standard Operations</strong></p>
<p><strong>Sources:</strong> <a href="https://github.com/QinMoMeak/Simple_FingerPrint_Matching/blob/5cdd0b1a/AES_update/KeyExpansion.m#L1-L20" target="_blank" rel="noopener noreferrer" class="mb-1 mr-1 inline-flex items-stretch font-mono text-xs !no-underline transition-opacity hover:opacity-75"><span class="flex items-center break-all rounded-l px-2 py-1.5 bg-[#e5e5e5] text-[#333333] dark:bg-[#252525] dark:text-[#e4e4e4]"><svg class="mr-1.5 hidden h-3.5 w-3.5 flex-shrink-0 opacity-40 md:block" fill="currentColor" viewBox="0 0 24 24"><path d="M12 0c-6.626 0-12 5.373-12 12 0 5.302 3.438 9.8 8.207 11.387.599.111.793-.261.793-.577v-2.234c-3.338.726-4.033-1.416-4.033-1.416-.546-1.387-1.333-1.756-1.333-1.756-1.089-.745.083-.729.083-.729 1.205.084 1.839 1.237 1.839 1.237 1.07 1.834 2.807 1.304 3.492.997.107-.775.418-1.305.762-1.604-2.665-.305-5.467-1.334-5.467-5.931 0-1.311.469-2.381 1.236-3.221-.124-.303-.535-1.524.117-3.176 0 0 1.008-.322 3.301 1.23.957-.266 1.983-.399 3.003-.404 1.02.005 2.047.138 3.006.404 2.291-1.552 3.297-1.23 3.297-1.23.653 1.653.242 2.874.118 3.176.77.84 1.235 1.911 1.235 3.221 0 4.609-2.807 5.624-5.479 5.921.43.372.823 1.102.823 2.222v3.293c0 .319.192.694.801.576 4.765-1.589 8.199-6.086 8.199-11.386 0-6.627-5.373-12-12-12z"></path></svg>AES_update/KeyExpansion.m</span><span class="flex flex-shrink-0 items-center rounded-r border-l px-2 py-1.5 border-[#dddddd] bg-[#d8d8d8] text-[#666666] dark:border-[#333333] dark:bg-[#2a2a2a] dark:text-[#888888]">1-20</span></a> <a href="https://github.com/QinMoMeak/Simple_FingerPrint_Matching/blob/5cdd0b1a/AES_update/SubBytes.m#L1-L20" target="_blank" rel="noopener noreferrer" class="mb-1 mr-1 inline-flex items-stretch font-mono text-xs !no-underline transition-opacity hover:opacity-75"><span class="flex items-center break-all rounded-l px-2 py-1.5 bg-[#e5e5e5] text-[#333333] dark:bg-[#252525] dark:text-[#e4e4e4]"><svg class="mr-1.5 hidden h-3.5 w-3.5 flex-shrink-0 opacity-40 md:block" fill="currentColor" viewBox="0 0 24 24"><path d="M12 0c-6.626 0-12 5.373-12 12 0 5.302 3.438 9.8 8.207 11.387.599.111.793-.261.793-.577v-2.234c-3.338.726-4.033-1.416-4.033-1.416-.546-1.387-1.333-1.756-1.333-1.756-1.089-.745.083-.729.083-.729 1.205.084 1.839 1.237 1.839 1.237 1.07 1.834 2.807 1.304 3.492.997.107-.775.418-1.305.762-1.604-2.665-.305-5.467-1.334-5.467-5.931 0-1.311.469-2.381 1.236-3.221-.124-.303-.535-1.524.117-3.176 0 0 1.008-.322 3.301 1.23.957-.266 1.983-.399 3.003-.404 1.02.005 2.047.138 3.006.404 2.291-1.552 3.297-1.23 3.297-1.23.653 1.653.242 2.874.118 3.176.77.84 1.235 1.911 1.235 3.221 0 4.609-2.807 5.624-5.479 5.921.43.372.823 1.102.823 2.222v3.293c0 .319.192.694.801.576 4.765-1.589 8.199-6.086 8.199-11.386 0-6.627-5.373-12-12-12z"></path></svg>AES_update/SubBytes.m</span><span class="flex flex-shrink-0 items-center rounded-r border-l px-2 py-1.5 border-[#dddddd] bg-[#d8d8d8] text-[#666666] dark:border-[#333333] dark:bg-[#2a2a2a] dark:text-[#888888]">1-20</span></a> <a href="https://github.com/QinMoMeak/Simple_FingerPrint_Matching/blob/5cdd0b1a/AES_update/xtime.m#L1-L18" target="_blank" rel="noopener noreferrer" class="mb-1 mr-1 inline-flex items-stretch font-mono text-xs !no-underline transition-opacity hover:opacity-75"><span class="flex items-center break-all rounded-l px-2 py-1.5 bg-[#e5e5e5] text-[#333333] dark:bg-[#252525] dark:text-[#e4e4e4]"><svg class="mr-1.5 hidden h-3.5 w-3.5 flex-shrink-0 opacity-40 md:block" fill="currentColor" viewBox="0 0 24 24"><path d="M12 0c-6.626 0-12 5.373-12 12 0 5.302 3.438 9.8 8.207 11.387.599.111.793-.261.793-.577v-2.234c-3.338.726-4.033-1.416-4.033-1.416-.546-1.387-1.333-1.756-1.333-1.756-1.089-.745.083-.729.083-.729 1.205.084 1.839 1.237 1.839 1.237 1.07 1.834 2.807 1.304 3.492.997.107-.775.418-1.305.762-1.604-2.665-.305-5.467-1.334-5.467-5.931 0-1.311.469-2.381 1.236-3.221-.124-.303-.535-1.524.117-3.176 0 0 1.008-.322 3.301 1.23.957-.266 1.983-.399 3.003-.404 1.02.005 2.047.138 3.006.404 2.291-1.552 3.297-1.23 3.297-1.23.653 1.653.242 2.874.118 3.176.77.84 1.235 1.911 1.235 3.221 0 4.609-2.807 5.624-5.479 5.921.43.372.823 1.102.823 2.222v3.293c0 .319.192.694.801.576 4.765-1.589 8.199-6.086 8.199-11.386 0-6.627-5.373-12-12-12z"></path></svg>AES_update/xtime.m</span><span class="flex flex-shrink-0 items-center rounded-r border-l px-2 py-1.5 border-[#dddddd] bg-[#d8d8d8] text-[#666666] dark:border-[#333333] dark:bg-[#2a2a2a] dark:text-[#888888]">1-18</span></a></p>
<hr/>
<h2 id="output-structure" class="group" data-header="true">Output Structure<button class="relative ml-2 cursor-pointer align-baseline text-gray-400 opacity-0 transition-opacity hover:text-blue-400 focus:opacity-100 group-hover:opacity-100" aria-label="Copy link to header"><svg xmlns="http://www.w3.org/2000/svg" width="1em" height="1em" fill="currentColor" viewBox="0 0 256 256" class="h-4 w-4"><path d="M117.18,188.74a12,12,0,0,1,0,17l-5.12,5.12A58.26,58.26,0,0,1,70.6,228h0A58.62,58.62,0,0,1,29.14,127.92L63.89,93.17a58.64,58.64,0,0,1,98.56,28.11,12,12,0,1,1-23.37,5.44,34.65,34.65,0,0,0-58.22-16.58L46.11,144.89A34.62,34.62,0,0,0,70.57,204h0a34.41,34.41,0,0,0,24.49-10.14l5.11-5.12A12,12,0,0,1,117.18,188.74ZM226.83,45.17a58.65,58.65,0,0,0-82.93,0l-5.11,5.11a12,12,0,0,0,17,17l5.12-5.12a34.63,34.63,0,1,1,49,49L175.1,145.86A34.39,34.39,0,0,1,150.61,156h0a34.63,34.63,0,0,1-33.69-26.72,12,12,0,0,0-23.38,5.44A58.64,58.64,0,0,0,150.56,180h.05a58.28,58.28,0,0,0,41.47-17.17l34.75-34.75a58.62,58.62,0,0,0,0-82.91Z"></path></svg></button></h2>
<p>The function returns a 4×N matrix where N depends on the key size:</p>

































<table><thead><tr><th>Key Size</th><th>Nk</th><th>Output Dimensions</th><th>Total Bytes</th><th>Usage</th></tr></thead><tbody><tr><td>AES-128</td><td>4</td><td>4×44</td><td>176</td><td>Initial key + 10 round keys</td></tr><tr><td>AES-192</td><td>6</td><td>4×52</td><td>208</td><td>Initial key + 12 round keys</td></tr><tr><td>AES-256</td><td>8</td><td>4×60</td><td>240</td><td>Initial key + 14 round keys</td></tr></tbody></table>
<p>Each column represents a 32-bit word (4 bytes). The round keys are extracted as contiguous 16-byte (4-word) blocks:</p>
<ul>
<li>Round 0 (initial): columns 0-3</li>
<li>Round 1: columns 4-7</li>
<li>Round 2: columns 8-11</li>
<li>...</li>
<li>Round Nr: columns 4Nr to 4Nr+3</li>
</ul>
<p><strong>Sources:</strong> <a href="https://github.com/QinMoMeak/Simple_FingerPrint_Matching/blob/5cdd0b1a/AES_update/KeyExpansion.m#L1-L20" target="_blank" rel="noopener noreferrer" class="mb-1 mr-1 inline-flex items-stretch font-mono text-xs !no-underline transition-opacity hover:opacity-75"><span class="flex items-center break-all rounded-l px-2 py-1.5 bg-[#e5e5e5] text-[#333333] dark:bg-[#252525] dark:text-[#e4e4e4]"><svg class="mr-1.5 hidden h-3.5 w-3.5 flex-shrink-0 opacity-40 md:block" fill="currentColor" viewBox="0 0 24 24"><path d="M12 0c-6.626 0-12 5.373-12 12 0 5.302 3.438 9.8 8.207 11.387.599.111.793-.261.793-.577v-2.234c-3.338.726-4.033-1.416-4.033-1.416-.546-1.387-1.333-1.756-1.333-1.756-1.089-.745.083-.729.083-.729 1.205.084 1.839 1.237 1.839 1.237 1.07 1.834 2.807 1.304 3.492.997.107-.775.418-1.305.762-1.604-2.665-.305-5.467-1.334-5.467-5.931 0-1.311.469-2.381 1.236-3.221-.124-.303-.535-1.524.117-3.176 0 0 1.008-.322 3.301 1.23.957-.266 1.983-.399 3.003-.404 1.02.005 2.047.138 3.006.404 2.291-1.552 3.297-1.23 3.297-1.23.653 1.653.242 2.874.118 3.176.77.84 1.235 1.911 1.235 3.221 0 4.609-2.807 5.624-5.479 5.921.43.372.823 1.102.823 2.222v3.293c0 .319.192.694.801.576 4.765-1.589 8.199-6.086 8.199-11.386 0-6.627-5.373-12-12-12z"></path></svg>AES_update/KeyExpansion.m</span><span class="flex flex-shrink-0 items-center rounded-r border-l px-2 py-1.5 border-[#dddddd] bg-[#d8d8d8] text-[#666666] dark:border-[#333333] dark:bg-[#2a2a2a] dark:text-[#888888]">1-20</span></a></p>
<hr/>
<h2 id="integration-with-encryption-and-decryption" class="group" data-header="true">Integration with Encryption and Decryption<button class="relative ml-2 cursor-pointer align-baseline text-gray-400 opacity-0 transition-opacity hover:text-blue-400 focus:opacity-100 group-hover:opacity-100" aria-label="Copy link to header"><svg xmlns="http://www.w3.org/2000/svg" width="1em" height="1em" fill="currentColor" viewBox="0 0 256 256" class="h-4 w-4"><path d="M117.18,188.74a12,12,0,0,1,0,17l-5.12,5.12A58.26,58.26,0,0,1,70.6,228h0A58.62,58.62,0,0,1,29.14,127.92L63.89,93.17a58.64,58.64,0,0,1,98.56,28.11,12,12,0,1,1-23.37,5.44,34.65,34.65,0,0,0-58.22-16.58L46.11,144.89A34.62,34.62,0,0,0,70.57,204h0a34.41,34.41,0,0,0,24.49-10.14l5.11-5.12A12,12,0,0,1,117.18,188.74ZM226.83,45.17a58.65,58.65,0,0,0-82.93,0l-5.11,5.11a12,12,0,0,0,17,17l5.12-5.12a34.63,34.63,0,1,1,49,49L175.1,145.86A34.39,34.39,0,0,1,150.61,156h0a34.63,34.63,0,0,1-33.69-26.72,12,12,0,0,0-23.38,5.44A58.64,58.64,0,0,0,150.56,180h.05a58.28,58.28,0,0,0,41.47-17.17l34.75-34.75a58.62,58.62,0,0,0,0-82.91Z"></path></svg></button></h2>
<p>The expanded key schedule produced by <code class="rounded-sm bg-[#e5e5e5] px-[0.25rem] py-[0.20rem] text-xs font-normal leading-[15px] before:hidden after:hidden dark:bg-[#484848]/30">KeyExpansion</code> is consumed by:</p>
<ol>
<li>
<p><strong>Cipher.m</strong> (encryption): Uses round keys in forward order during <code class="rounded-sm bg-[#e5e5e5] px-[0.25rem] py-[0.20rem] text-xs font-normal leading-[15px] before:hidden after:hidden dark:bg-[#484848]/30">AddRoundKey</code> operations. See <a href="2.2-encryption-process.html" class="text-neutral-300 hover:text-neutral-200 hover:underline">Encryption Process</a> and <a href="2.2.4-addroundkey-transformation.html" class="text-neutral-300 hover:text-neutral-200 hover:underline">AddRoundKey Transformation</a>.</p>
</li>
<li>
<p><strong>InvCipher.m</strong> (decryption): Uses round keys in reverse order, with <code class="rounded-sm bg-[#e5e5e5] px-[0.25rem] py-[0.20rem] text-xs font-normal leading-[15px] before:hidden after:hidden dark:bg-[#484848]/30">InvMixColumns</code> applied to round keys 1 through Nr-1 in the Equivalent Inverse Cipher variant. See <a href="2.3-decryption-process.html" class="text-neutral-300 hover:text-neutral-200 hover:underline">Decryption Process</a>.</p>
</li>
</ol>
<p>Both encryption and decryption rely on the same expanded key schedule, ensuring symmetric operation of the cipher.</p>
<p><strong>Sources:</strong> <a href="https://github.com/QinMoMeak/Simple_FingerPrint_Matching/blob/5cdd0b1a/AES_update/KeyExpansion.m#L1-L20" target="_blank" rel="noopener noreferrer" class="mb-1 mr-1 inline-flex items-stretch font-mono text-xs !no-underline transition-opacity hover:opacity-75"><span class="flex items-center break-all rounded-l px-2 py-1.5 bg-[#e5e5e5] text-[#333333] dark:bg-[#252525] dark:text-[#e4e4e4]"><svg class="mr-1.5 hidden h-3.5 w-3.5 flex-shrink-0 opacity-40 md:block" fill="currentColor" viewBox="0 0 24 24"><path d="M12 0c-6.626 0-12 5.373-12 12 0 5.302 3.438 9.8 8.207 11.387.599.111.793-.261.793-.577v-2.234c-3.338.726-4.033-1.416-4.033-1.416-.546-1.387-1.333-1.756-1.333-1.756-1.089-.745.083-.729.083-.729 1.205.084 1.839 1.237 1.839 1.237 1.07 1.834 2.807 1.304 3.492.997.107-.775.418-1.305.762-1.604-2.665-.305-5.467-1.334-5.467-5.931 0-1.311.469-2.381 1.236-3.221-.124-.303-.535-1.524.117-3.176 0 0 1.008-.322 3.301 1.23.957-.266 1.983-.399 3.003-.404 1.02.005 2.047.138 3.006.404 2.291-1.552 3.297-1.23 3.297-1.23.653 1.653.242 2.874.118 3.176.77.84 1.235 1.911 1.235 3.221 0 4.609-2.807 5.624-5.479 5.921.43.372.823 1.102.823 2.222v3.293c0 .319.192.694.801.576 4.765-1.589 8.199-6.086 8.199-11.386 0-6.627-5.373-12-12-12z"></path></svg>AES_update/KeyExpansion.m</span><span class="flex flex-shrink-0 items-center rounded-r border-l px-2 py-1.5 border-[#dddddd] bg-[#d8d8d8] text-[#666666] dark:border-[#333333] dark:bg-[#2a2a2a] dark:text-[#888888]">1-20</span></a></p></div></div></div></div></div></div><div class="hidden overflow-hidden transition-[border-radius] xl:sticky xl:right-0 xl:top-20 xl:block xl:h-[calc(100vh-82px)] xl:w-64 xl:flex-shrink-0 2xl:w-72" style="scrollbar-width:none"><div class="flex max-h-full w-full flex-shrink-0 flex-col py-6 pt-0 text-sm lg:pb-4 lg:pt-8 xl:w-64 2xl:w-72" style="scrollbar-color:var(--color-night) transparent"><div><div class="relative mx-4 my-4 rounded-md border border-neutral-200 bg-neutral-100 p-3 text-sm text-neutral-600 dark:border-neutral-800 dark:bg-neutral-900 dark:text-neutral-400"><button class="absolute right-2 top-2 rounded-sm p-1 opacity-70 transition-opacity hover:opacity-100 focus:outline-none focus:ring-2 focus:ring-neutral-400 focus:ring-offset-2"><svg xmlns="http://www.w3.org/2000/svg" width="1em" height="1em" fill="currentColor" viewBox="0 0 256 256" class="h-4 w-4"><path d="M205.66,194.34a8,8,0,0,1-11.32,11.32L128,139.31,61.66,205.66a8,8,0,0,1-11.32-11.32L116.69,128,50.34,61.66A8,8,0,0,1,61.66,50.34L128,116.69l66.34-66.35a8,8,0,0,1,11.32,11.32L139.31,128Z"></path></svg><span class="sr-only">Dismiss</span></button><p class="text-sm font-medium">Refresh this wiki</p><p class="mt-2 text-sm font-light text-neutral-500 dark:text-neutral-400">This wiki was recently refreshed. Please wait<!-- --> <!-- -->7<!-- --> day<!-- -->s<!-- --> to refresh again.</p></div></div><h3 class="px-4 pb-5 text-lg font-medium leading-none">On this page</h3><ul style="scrollbar-width:none" class="min-h-0 flex-1 space-y-3 overflow-y-auto p-4 pt-0"><li class=""><a href="#key-expansion" class="hover:text-primary pr-1 transition-all text-primary font-medium">Key Expansion</a></li><li class="ml-3"><a href="#purpose-and-scope" class="hover:text-primary pr-1 font-normal transition-all text-secondary">Purpose and Scope</a></li><li class="ml-3"><a href="#overview" class="hover:text-primary pr-1 font-normal transition-all text-secondary">Overview</a></li><li class="ml-3"><a href="#function-signature-and-parameters" class="hover:text-primary pr-1 font-normal transition-all text-secondary">Function Signature and Parameters</a></li><li class="ml-3"><a href="#key-expansion-algorithm-flow" class="hover:text-primary pr-1 font-normal transition-all text-secondary">Key Expansion Algorithm Flow</a></li><li class="ml-3"><a href="#input-processing" class="hover:text-primary pr-1 font-normal transition-all text-secondary">Input Processing</a></li><li class="ml-3"><a href="#iterative-word-generation" class="hover:text-primary pr-1 font-normal transition-all text-secondary">Iterative Word Generation</a></li><li class="ml-3"><a href="#core-transformations" class="hover:text-primary pr-1 font-normal transition-all text-secondary">Core Transformations</a></li><li class="ml-6"><a href="#rotword-cyclic-byte-rotation" class="hover:text-primary pr-1 font-normal transition-all text-secondary">RotWord (Cyclic Byte Rotation)</a></li><li class="ml-6"><a href="#subbytes-substitution" class="hover:text-primary pr-1 font-normal transition-all text-secondary">SubBytes Substitution</a></li><li class="ml-6"><a href="#round-constant-rcon-generation" class="hover:text-primary pr-1 font-normal transition-all text-secondary">Round Constant (Rcon) Generation</a></li><li class="ml-3"><a href="#aes-256-special-case" class="hover:text-primary pr-1 font-normal transition-all text-secondary">AES-256 Special Case</a></li><li class="ml-3"><a href="#final-xor-operation" class="hover:text-primary pr-1 font-normal transition-all text-secondary">Final XOR Operation</a></li><li class="ml-3"><a href="#code-to-algorithm-mapping" class="hover:text-primary pr-1 font-normal transition-all text-secondary">Code-to-Algorithm Mapping</a></li><li class="ml-3"><a href="#output-structure" class="hover:text-primary pr-1 font-normal transition-all text-secondary">Output Structure</a></li><li class="ml-3"><a href="#integration-with-encryption-and-decryption" class="hover:text-primary pr-1 font-normal transition-all text-secondary">Integration with Encryption and Decryption</a></li></ul></div></div><div class="pointer-events-none fixed bottom-2 left-2 right-2 mt-2 md:bottom-4 md:left-0 md:right-0"><div class="z-10 mx-auto max-w-3xl"><!--$!--><template data-dgst="BAILOUT_TO_CLIENT_SIDE_RENDERING"></template><!--/$--></div></div></div></div></div><!--$--><!--/$--></div><script>$RC("B:1","S:1")</script><script>(self.__next_f=self.__next_f||[]).push([0])</script><script>self.__next_f.push([1,"1:\"$Sreact.fragment\"\n"])</script><script>self.__next_f.push([1,"2:I[49138,[\"9453\",\"static/chunks/b1298b8d-5cac6cd7c8e952ff.js?dpl=dpl_4ju9xcz1Pq3nZ5Ni49xZwPFZX9bw\",\"8970\",\"static/chunks/378e5a93-860e027c5a5e0c0d.js?dpl=dpl_4ju9xcz1Pq3nZ5Ni49xZwPFZX9bw\",\"1585\",\"static/chunks/f7f68e2d-d8bf979db5ff4e9d.js?dpl=dpl_4ju9xcz1Pq3nZ5Ni49xZwPFZX9bw\",\"7963\",\"static/chunks/7963-2c20578d72f6c7cc.js?dpl=dpl_4ju9xcz1Pq3nZ5Ni49xZwPFZX9bw\",\"1265\",\"static/chunks/1265-fa8a95d3842768f5.js?dpl=dpl_4ju9xcz1Pq3nZ5Ni49xZwPFZX9bw\",\"9885\",\"static/chunks/9885-b57089f03806c3b8.js?dpl=dpl_4ju9xcz1Pq3nZ5Ni49xZwPFZX9bw\",\"659\",\"static/chunks/659-ee9e1e775e30dcef.js?dpl=dpl_4ju9xcz1Pq3nZ5Ni49xZwPFZX9bw\",\"7177\",\"static/chunks/app/layout-0537c2076823e553.js?dpl=dpl_4ju9xcz1Pq3nZ5Ni49xZwPFZX9bw\"],\"RootProvider\"]\n"])</script><script>self.__next_f.push([1,"3:I[85341,[],\"\"]\n4:I[90025,[],\"\"]\n7:I[41012,[],\"ClientPageRoot\"]\n"])</script><script>self.__next_f.push([1,"8:I[57456,[\"9453\",\"static/chunks/b1298b8d-5cac6cd7c8e952ff.js?dpl=dpl_4ju9xcz1Pq3nZ5Ni49xZwPFZX9bw\",\"8970\",\"static/chunks/378e5a93-860e027c5a5e0c0d.js?dpl=dpl_4ju9xcz1Pq3nZ5Ni49xZwPFZX9bw\",\"1585\",\"static/chunks/f7f68e2d-d8bf979db5ff4e9d.js?dpl=dpl_4ju9xcz1Pq3nZ5Ni49xZwPFZX9bw\",\"4129\",\"static/chunks/7bf36345-1ac10ec2f0e0c88f.js?dpl=dpl_4ju9xcz1Pq3nZ5Ni49xZwPFZX9bw\",\"2545\",\"static/chunks/c16f53c3-b390b6f98a69dcec.js?dpl=dpl_4ju9xcz1Pq3nZ5Ni49xZwPFZX9bw\",\"7963\",\"static/chunks/7963-2c20578d72f6c7cc.js?dpl=dpl_4ju9xcz1Pq3nZ5Ni49xZwPFZX9bw\",\"1265\",\"static/chunks/1265-fa8a95d3842768f5.js?dpl=dpl_4ju9xcz1Pq3nZ5Ni49xZwPFZX9bw\",\"6212\",\"static/chunks/6212-505c2fc95d1a35ae.js?dpl=dpl_4ju9xcz1Pq3nZ5Ni49xZwPFZX9bw\",\"9885\",\"static/chunks/9885-b57089f03806c3b8.js?dpl=dpl_4ju9xcz1Pq3nZ5Ni49xZwPFZX9bw\",\"4336\",\"static/chunks/4336-624d5ae6f4cc1cc7.js?dpl=dpl_4ju9xcz1Pq3nZ5Ni49xZwPFZX9bw\",\"659\",\"static/chunks/659-ee9e1e775e30dcef.js?dpl=dpl_4ju9xcz1Pq3nZ5Ni49xZwPFZX9bw\",\"8461\",\"static/chunks/8461-369a9f0c48ea2626.js?dpl=dpl_4ju9xcz1Pq3nZ5Ni49xZwPFZX9bw\",\"7198\",\"static/chunks/7198-985a49f2b6072d25.js?dpl=dpl_4ju9xcz1Pq3nZ5Ni49xZwPFZX9bw\",\"1170\",\"static/chunks/1170-02491c90c1c0890e.js?dpl=dpl_4ju9xcz1Pq3nZ5Ni49xZwPFZX9bw\",\"4429\",\"static/chunks/4429-92c77bf2d3e82e1c.js?dpl=dpl_4ju9xcz1Pq3nZ5Ni49xZwPFZX9bw\",\"9976\",\"static/chunks/9976-e70b787a4dd08fcf.js?dpl=dpl_4ju9xcz1Pq3nZ5Ni49xZwPFZX9bw\",\"1481\",\"static/chunks/1481-25d5bbc4f2d9524a.js?dpl=dpl_4ju9xcz1Pq3nZ5Ni49xZwPFZX9bw\",\"3285\",\"static/chunks/app/%5Borg%5D/%5Brepo%5D/%5B%5B...wikiRoutes%5D%5D/page-9dfe5afb3c44861e.js?dpl=dpl_4ju9xcz1Pq3nZ5Ni49xZwPFZX9bw\"],\"default\"]\n"])</script><script>self.__next_f.push([1,"b:I[15104,[],\"OutletBoundary\"]\nd:I[94777,[],\"AsyncMetadataOutlet\"]\nf:I[15104,[],\"ViewportBoundary\"]\n11:I[15104,[],\"MetadataBoundary\"]\n12:\"$Sreact.suspense\"\n14:I[34431,[],\"\"]\n:HL[\"/_next/static/media/4cf2300e9c8272f7-s.p.woff2\",\"font\",{\"crossOrigin\":\"\",\"type\":\"font/woff2\"}]\n:HL[\"/_next/static/media/93f479601ee12b01-s.p.woff2\",\"font\",{\"crossOrigin\":\"\",\"type\":\"font/woff2\"}]\n:HL[\"/_next/static/css/de70bee13400563f.css?dpl=dpl_4ju9xcz1Pq3nZ5Ni49xZwPFZX9bw\",\"style\"]\n:HL[\"/_next/static/css/b54d92a85d180acc.css?dpl=dpl_4ju9xcz1Pq3nZ5Ni49xZwPFZX9bw\",\"style\"]\n"])</script><script>self.__next_f.push([1,"0:{\"P\":null,\"b\":\"BHwr7NxeZvydIA-zpe3qC\",\"p\":\"\",\"c\":[\"\",\"QinMoMeak\",\"Simple_FingerPrint_Matching\",\"2.1-key-expansion\"],\"i\":false,\"f\":[[[\"\",{\"children\":[[\"org\",\"QinMoMeak\",\"d\"],{\"children\":[[\"repo\",\"Simple_FingerPrint_Matching\",\"d\"],{\"children\":[[\"wikiRoutes\",\"2.1-key-expansion\",\"oc\"],{\"children\":[\"__PAGE__\",{}]}]}]}]},\"$undefined\",\"$undefined\",true],[\"\",[\"$\",\"$1\",\"c\",{\"children\":[[[\"$\",\"link\",\"0\",{\"rel\":\"stylesheet\",\"href\":\"/_next/static/css/de70bee13400563f.css?dpl=dpl_4ju9xcz1Pq3nZ5Ni49xZwPFZX9bw\",\"precedence\":\"next\",\"crossOrigin\":\"$undefined\",\"nonce\":\"$undefined\"}],[\"$\",\"link\",\"1\",{\"rel\":\"stylesheet\",\"href\":\"/_next/static/css/b54d92a85d180acc.css?dpl=dpl_4ju9xcz1Pq3nZ5Ni49xZwPFZX9bw\",\"precedence\":\"next\",\"crossOrigin\":\"$undefined\",\"nonce\":\"$undefined\"}]],[\"$\",\"html\",null,{\"lang\":\"en\",\"suppressHydrationWarning\":true,\"children\":[[\"$\",\"head\",null,{}],[\"$\",\"body\",null,{\"className\":\"__variable_188709 font-geist-sans relative min-h-screen __variable_9a8899 bg-background antialiased\",\"children\":[\"$\",\"$L2\",null,{\"children\":[\"$\",\"$L3\",null,{\"parallelRouterKey\":\"children\",\"error\":\"$undefined\",\"errorStyles\":\"$undefined\",\"errorScripts\":\"$undefined\",\"template\":[\"$\",\"$L4\",null,{}],\"templateStyles\":\"$undefined\",\"templateScripts\":\"$undefined\",\"notFound\":[[[\"$\",\"title\",null,{\"children\":\"404: This page could not be found.\"}],[\"$\",\"div\",null,{\"style\":{\"fontFamily\":\"system-ui,\\\"Segoe UI\\\",Roboto,Helvetica,Arial,sans-serif,\\\"Apple Color Emoji\\\",\\\"Segoe UI Emoji\\\"\",\"height\":\"100vh\",\"textAlign\":\"center\",\"display\":\"flex\",\"flexDirection\":\"column\",\"alignItems\":\"center\",\"justifyContent\":\"center\"},\"children\":[\"$\",\"div\",null,{\"children\":[[\"$\",\"style\",null,{\"dangerouslySetInnerHTML\":{\"__html\":\"body{color:#000;background:#fff;margin:0}.next-error-h1{border-right:1px solid rgba(0,0,0,.3)}@media (prefers-color-scheme:dark){body{color:#fff;background:#000}.next-error-h1{border-right:1px solid rgba(255,255,255,.3)}}\"}}],[\"$\",\"h1\",null,{\"className\":\"next-error-h1\",\"style\":{\"display\":\"inline-block\",\"margin\":\"0 20px 0 0\",\"padding\":\"0 23px 0 0\",\"fontSize\":24,\"fontWeight\":500,\"verticalAlign\":\"top\",\"lineHeight\":\"49px\"},\"children\":404}],[\"$\",\"div\",null,{\"style\":{\"display\":\"inline-block\"},\"children\":[\"$\",\"h2\",null,{\"style\":{\"fontSize\":14,\"fontWeight\":400,\"lineHeight\":\"49px\",\"margin\":0},\"children\":\"This page could not be found.\"}]}]]}]}]],[]],\"forbidden\":\"$undefined\",\"unauthorized\":\"$undefined\"}]}]}]]}]]}],{\"children\":[[\"org\",\"QinMoMeak\",\"d\"],[\"$\",\"$1\",\"c\",{\"children\":[null,[\"$\",\"$L3\",null,{\"parallelRouterKey\":\"children\",\"error\":\"$undefined\",\"errorStyles\":\"$undefined\",\"errorScripts\":\"$undefined\",\"template\":[\"$\",\"$L4\",null,{}],\"templateStyles\":\"$undefined\",\"templateScripts\":\"$undefined\",\"notFound\":\"$undefined\",\"forbidden\":\"$undefined\",\"unauthorized\":\"$undefined\"}]]}],{\"children\":[[\"repo\",\"Simple_FingerPrint_Matching\",\"d\"],[\"$\",\"$1\",\"c\",{\"children\":[null,\"$L5\"]}],{\"children\":[[\"wikiRoutes\",\"2.1-key-expansion\",\"oc\"],[\"$\",\"$1\",\"c\",{\"children\":[null,\"$L6\"]}],{\"children\":[\"__PAGE__\",[\"$\",\"$1\",\"c\",{\"children\":[[\"$\",\"$L7\",null,{\"Component\":\"$8\",\"searchParams\":{},\"params\":{\"org\":\"QinMoMeak\",\"repo\":\"Simple_FingerPrint_Matching\",\"wikiRoutes\":[\"2.1-key-expansion\"]},\"promises\":[\"$@9\",\"$@a\"]}],null,[\"$\",\"$Lb\",null,{\"children\":[\"$Lc\",[\"$\",\"$Ld\",null,{\"promise\":\"$@e\"}]]}]]}],{},null,false]},null,false]},null,false]},null,false]},null,false],[\"$\",\"$1\",\"h\",{\"children\":[null,[[\"$\",\"$Lf\",null,{\"children\":\"$L10\"}],[\"$\",\"meta\",null,{\"name\":\"next-size-adjust\",\"content\":\"\"}]],[\"$\",\"$L11\",null,{\"children\":[\"$\",\"div\",null,{\"hidden\":true,\"children\":[\"$\",\"$12\",null,{\"fallback\":null,\"children\":\"$L13\"}]}]}]]}],false]],\"m\":\"$undefined\",\"G\":[\"$14\",[]],\"s\":false,\"S\":true}\n"])</script><script>self.__next_f.push([1,"9:{}\na:\"$0:f:0:1:2:children:2:children:2:children:2:children:1:props:children:0:props:params\"\n"])</script><script>self.__next_f.push([1,"10:[[\"$\",\"meta\",\"0\",{\"charSet\":\"utf-8\"}],[\"$\",\"meta\",\"1\",{\"name\":\"viewport\",\"content\":\"width=device-width, initial-scale=1\"}]]\nc:null\n"])</script><script>self.__next_f.push([1,"15:I[13550,[\"9453\",\"static/chunks/b1298b8d-5cac6cd7c8e952ff.js?dpl=dpl_4ju9xcz1Pq3nZ5Ni49xZwPFZX9bw\",\"8970\",\"static/chunks/378e5a93-860e027c5a5e0c0d.js?dpl=dpl_4ju9xcz1Pq3nZ5Ni49xZwPFZX9bw\",\"1585\",\"static/chunks/f7f68e2d-d8bf979db5ff4e9d.js?dpl=dpl_4ju9xcz1Pq3nZ5Ni49xZwPFZX9bw\",\"7963\",\"static/chunks/7963-2c20578d72f6c7cc.js?dpl=dpl_4ju9xcz1Pq3nZ5Ni49xZwPFZX9bw\",\"1265\",\"static/chunks/1265-fa8a95d3842768f5.js?dpl=dpl_4ju9xcz1Pq3nZ5Ni49xZwPFZX9bw\",\"6212\",\"static/chunks/6212-505c2fc95d1a35ae.js?dpl=dpl_4ju9xcz1Pq3nZ5Ni49xZwPFZX9bw\",\"4336\",\"static/chunks/4336-624d5ae6f4cc1cc7.js?dpl=dpl_4ju9xcz1Pq3nZ5Ni49xZwPFZX9bw\",\"25\",\"static/chunks/25-9f305b682cea7558.js?dpl=dpl_4ju9xcz1Pq3nZ5Ni49xZwPFZX9bw\",\"7391\",\"static/chunks/7391-cea3fe9ac7162130.js?dpl=dpl_4ju9xcz1Pq3nZ5Ni49xZwPFZX9bw\",\"6373\",\"static/chunks/6373-d56a493968555802.js?dpl=dpl_4ju9xcz1Pq3nZ5Ni49xZwPFZX9bw\",\"6375\",\"static/chunks/6375-7e0e75eb09fc9abe.js?dpl=dpl_4ju9xcz1Pq3nZ5Ni49xZwPFZX9bw\",\"9437\",\"static/chunks/9437-00f165dda9ad3a42.js?dpl=dpl_4ju9xcz1Pq3nZ5Ni49xZwPFZX9bw\",\"2933\",\"static/chunks/app/%5Borg%5D/%5Brepo%5D/layout-cecfb9eee640deb0.js?dpl=dpl_4ju9xcz1Pq3nZ5Ni49xZwPFZX9bw\"],\"HeaderWrapperWithSuspense\"]\n"])</script><script>self.__next_f.push([1,"16:I[82188,[\"9453\",\"static/chunks/b1298b8d-5cac6cd7c8e952ff.js?dpl=dpl_4ju9xcz1Pq3nZ5Ni49xZwPFZX9bw\",\"8970\",\"static/chunks/378e5a93-860e027c5a5e0c0d.js?dpl=dpl_4ju9xcz1Pq3nZ5Ni49xZwPFZX9bw\",\"1585\",\"static/chunks/f7f68e2d-d8bf979db5ff4e9d.js?dpl=dpl_4ju9xcz1Pq3nZ5Ni49xZwPFZX9bw\",\"7963\",\"static/chunks/7963-2c20578d72f6c7cc.js?dpl=dpl_4ju9xcz1Pq3nZ5Ni49xZwPFZX9bw\",\"1265\",\"static/chunks/1265-fa8a95d3842768f5.js?dpl=dpl_4ju9xcz1Pq3nZ5Ni49xZwPFZX9bw\",\"6212\",\"static/chunks/6212-505c2fc95d1a35ae.js?dpl=dpl_4ju9xcz1Pq3nZ5Ni49xZwPFZX9bw\",\"4336\",\"static/chunks/4336-624d5ae6f4cc1cc7.js?dpl=dpl_4ju9xcz1Pq3nZ5Ni49xZwPFZX9bw\",\"25\",\"static/chunks/25-9f305b682cea7558.js?dpl=dpl_4ju9xcz1Pq3nZ5Ni49xZwPFZX9bw\",\"7391\",\"static/chunks/7391-cea3fe9ac7162130.js?dpl=dpl_4ju9xcz1Pq3nZ5Ni49xZwPFZX9bw\",\"6373\",\"static/chunks/6373-d56a493968555802.js?dpl=dpl_4ju9xcz1Pq3nZ5Ni49xZwPFZX9bw\",\"6375\",\"static/chunks/6375-7e0e75eb09fc9abe.js?dpl=dpl_4ju9xcz1Pq3nZ5Ni49xZwPFZX9bw\",\"9437\",\"static/chunks/9437-00f165dda9ad3a42.js?dpl=dpl_4ju9xcz1Pq3nZ5Ni49xZwPFZX9bw\",\"2933\",\"static/chunks/app/%5Borg%5D/%5Brepo%5D/layout-cecfb9eee640deb0.js?dpl=dpl_4ju9xcz1Pq3nZ5Ni49xZwPFZX9bw\"],\"WikiContextProvider\"]\n"])</script><script>self.__next_f.push([1,"33:I[36505,[],\"IconMark\"]\n17:T336c,"])</script><script>self.__next_f.push([1,"# Overview\n\n\u003cdetails\u003e\n\u003csummary\u003eRelevant source files\u003c/summary\u003e\n\nThe following files were used as context for generating this wiki page:\n\n- [AES_update/Cipher.m](AES_update/Cipher.m)\n- [AES_update/InvCipher.m](AES_update/InvCipher.m)\n- [AES_update/license.txt](AES_update/license.txt)\n- [Copy_of_match.m](Copy_of_match.m)\n- [FExtraction/fft_enhance_cubs.m](FExtraction/fft_enhance_cubs.m)\n\n\u003c/details\u003e\n\n\n\nThis document provides an overview of the Simple_FingerPrint_Matching repository, a dual-purpose MATLAB implementation containing both an Advanced Encryption Standard (AES) cryptographic system and a fingerprint biometric matching system. The repository consists of two functionally independent subsystems that could potentially be integrated for secure biometric authentication.\n\n**Scope**: This page introduces the overall system architecture, repository organization, and the relationship between the major subsystems. For detailed information about specific subsystems, see [AES Encryption System](#2) and [Fingerprint Processing System](#3).\n\n---\n\n## Repository Purpose and Architecture\n\nThe repository implements two distinct capabilities:\n\n1. **AES Encryption/Decryption** - A complete implementation of the AES cipher supporting 128, 192, and 256-bit keys, conforming to FIPS-197 standard\n2. **Fingerprint Matching** - A biometric identification system that extracts features from fingerprint images and performs similarity-based matching\n\nThese systems are currently **independent and disconnected**, though their co-location suggests a future intent to build a privacy-preserving biometric authentication system where fingerprint data could be encrypted using AES.\n\n### Repository Directory Structure\n\n```mermaid\ngraph TB\n    ROOT[\"Repository Root\"]\n    AES[\"AES_update/\u003cbr/\u003e(11 MATLAB files)\"]\n    FEXT[\"FExtraction/\u003cbr/\u003e(15 MATLAB files)\"]\n    MATCH[\"Copy_of_match.m\"]\n    SCORE[\"Copy_of_score.m\"]\n    DB[\"db.mat\u003cbr/\u003e(Fingerprint Database)\"]\n    FILTERS[\"angular_filters_*.mat\u003cbr/\u003e(Precomputed Filters)\"]\n    \n    ROOT --\u003e AES\n    ROOT --\u003e FEXT\n    ROOT --\u003e MATCH\n    ROOT --\u003e SCORE\n    ROOT --\u003e DB\n    ROOT --\u003e FILTERS\n    \n    AES -.-\u003e|\"No direct connection\"| FEXT\n    AES -.-\u003e|\"No direct connection\"| MATCH\n    \n    FEXT --\u003e MATCH\n    MATCH --\u003e SCORE\n    \n    DB --\u003e MATCH\n    FILTERS --\u003e FEXT\n```\n\n**Sources**: Repository structure inferred from [AES_update/Cipher.m:1-28](), [Copy_of_match.m:1-411](), [FExtraction/fft_enhance_cubs.m:1-275]()\n\n---\n\n## System Components\n\n### AES Encryption System (`AES_update/`)\n\nThe AES subsystem provides complete encryption and decryption capabilities through a modular implementation of the AES block cipher algorithm.\n\n| Component | File | Purpose |\n|-----------|------|---------|\n| Encryption Entry Point | `Cipher.m` | Main encryption function implementing forward AES cipher |\n| Decryption Entry Point | `InvCipher.m` | Main decryption function implementing inverse AES cipher |\n| Key Schedule | `KeyExpansion.m` | Generates round keys from input key |\n| Forward Transformations | `SubBytes.m`, `ShiftRows.m`, `MixColumns.m`, `AddRoundKey.m` | Round transformation functions |\n| Inverse Transformations | `InvSubBytes.m`, `InvShiftRows.m`, `InvMixColumns.m` | Inverse round transformation functions |\n| Utility | `xtime.m` | Galois field GF(2^8) multiplication |\n\nThe system accepts hexadecimal key inputs of length 32 (AES-128), 48 (AES-192), or 64 (AES-256) characters, corresponding to 128, 192, or 256 bits. Input messages must be 128-bit hexadecimal strings (32 characters).\n\n**Key Implementation Details**:\n- Key length determines number of rounds: `Nk=length(key)/8` at [AES_update/Cipher.m:11]()\n- Round count: `(Nk+6)` iterations at [AES_update/Cipher.m:16]()\n- State matrix: 4x4 byte array reshaped from input at [AES_update/Cipher.m:14]()\n\nFor detailed AES implementation, see [AES Encryption System](#2).\n\n**Sources**: [AES_update/Cipher.m:1-28](), [AES_update/InvCipher.m:1-28](), [AES_update/license.txt:1-28]()\n\n---\n\n### Fingerprint Processing System\n\nThe fingerprint subsystem consists of two major components: feature extraction and matching.\n\n#### Feature Extraction Pipeline (`FExtraction/`)\n\nThe feature extraction pipeline transforms raw fingerprint images into enhanced representations suitable for matching:\n\n```mermaid\ngraph LR\n    RAW[\"Raw Image\u003cbr/\u003e(grayscale)\"]\n    \n    subgraph \"FExtraction/ Functions\"\n        SEG[\"ridgesegment.m\u003cbr/\u003eNormalization\"]\n        ORIENT[\"ridgeorient.m\u003cbr/\u003eOrientation\"]\n        FREQ[\"ridgefreq.m\u003cbr/\u003eFrequency\"]\n        FILT[\"ridgefilter.m\u003cbr/\u003eEnhancement\"]\n        FFT[\"fft_enhance_cubs.m\u003cbr/\u003eFFT Enhancement\"]\n    end\n    \n    MINUTIAE[\"Minutiae Features\u003cbr/\u003e(x, y, theta, type)\"]\n    \n    RAW --\u003e SEG\n    SEG --\u003e ORIENT\n    ORIENT --\u003e FREQ\n    FREQ --\u003e FILT\n    FILT --\u003e MINUTIAE\n    \n    RAW -.-\u003e|\"Alternative path\"| FFT\n    FFT -.-\u003e MINUTIAE\n```\n\nThe `fft_enhance_cubs.m` function provides an alternative enhancement approach using FFT-based block processing with adaptive angular filtering at [FExtraction/fft_enhance_cubs.m:22](), producing multiple feature maps including orientation (`oimg`), frequency (`fimg`), coherence (`cimg`), bandwidth (`bwimg`), and energy (`eimg`).\n\nFor detailed feature extraction documentation, see [Feature Extraction Pipeline](#3.1).\n\n**Sources**: [FExtraction/fft_enhance_cubs.m:1-275]()\n\n---\n\n#### Fingerprint Matching System\n\nThe matching system compares minutiae extracted from fingerprint images to determine similarity:\n\n```mermaid\ngraph TB\n    subgraph \"Matching Entry Point\"\n        MATCH_FUNC[\"Copy_of_match(Index, Number, display_flag)\u003cbr/\u003eMain matching orchestrator\"]\n    end\n    \n    subgraph \"Data Sources\"\n        DB_MAT[\"db.mat\u003cbr/\u003eff{} cell array\u003cbr/\u003eContains minutiae sets\"]\n        REF[\"Reference Fingerprint\u003cbr/\u003eM1 = ff{Index*8-7}\"]\n        CAND[\"Candidate Fingerprints\u003cbr/\u003eM2-M6 = ff{random}\"]\n    end\n    \n    subgraph \"Transformation Functions\"\n        TRANS[\"transform(M, i)\u003cbr/\u003eTranslation to origin\"]\n        TRANS2[\"transform2(T, alpha)\u003cbr/\u003eRotation by angle alpha\"]\n    end\n    \n    subgraph \"Scoring\"\n        SCORE_FUNC[\"score(T1, T2)\u003cbr/\u003eReturns similarity measure\"]\n    end\n    \n    DB_MAT --\u003e REF\n    DB_MAT --\u003e CAND\n    \n    MATCH_FUNC --\u003e REF\n    MATCH_FUNC --\u003e CAND\n    \n    REF --\u003e TRANS\n    CAND --\u003e TRANS\n    \n    TRANS --\u003e TRANS2\n    TRANS2 --\u003e SCORE_FUNC\n    \n    SCORE_FUNC --\u003e RESULT[\"Similarity Scores\u003cbr/\u003eS2, S3, S4, S5, S6\"]\n```\n\nThe matching algorithm at [Copy_of_match.m:17]() loads a reference fingerprint using the formula `Index*8-7` and compares it against multiple randomly selected candidates. It performs brute-force alignment search by testing multiple translation and rotation transformations, calling the `score` function from [Copy_of_score.m]() to compute similarity measures.\n\n**Key Matching Parameters**:\n- Rotation range: -10° to +10° for some comparisons, -5° to +5° for others (varies by candidate)\n- Minutiae filtering: Only uses minutiae where `column 3 \u003c 5` at [Copy_of_match.m:31-36]()\n- Multiple candidates: Tests 5 random candidates per matching operation\n\nFor detailed matching algorithm documentation, see [Fingerprint Matching](#3.2).\n\n**Sources**: [Copy_of_match.m:1-411]()\n\n---\n\n## Data Files and Dependencies\n\n### Fingerprint Database (`db.mat`)\n\nThe system depends on a pre-existing MATLAB data file `db.mat` which contains:\n- Variable `ff`: Cell array storing minutiae sets\n- Each minutiae set: Nx7 matrix where columns represent (x, y, theta, type, ..., ...)\n- Indexed access pattern: `ff{Index*8-7}` loads reference at [Copy_of_match.m:19-25]()\n\n### Angular Filter Banks\n\nThe FFT-based enhancement algorithm requires precomputed angular filters:\n- `angular_filters_pi_4.mat`: Filters with π/4 bandwidth\n- `angular_filters_pi_2.mat`: Filters with π/2 bandwidth\n\nThese are loaded at [FExtraction/fft_enhance_cubs.m:73-76]() and contain the variable `angf` which stores filter coefficients for different orientations. The filters are selected based on block orientation and coherence, as computed by `get_angular_filter` at [FExtraction/fft_enhance_cubs.m:211-225]().\n\nFor more details on data dependencies, see [Data Files and Dependencies](#1.2).\n\n**Sources**: [Copy_of_match.m:18](), [FExtraction/fft_enhance_cubs.m:73-76]()\n\n---\n\n## System Integration and Future Direction\n\n### Current State: Independent Subsystems\n\nThe following diagram illustrates the **absence** of integration between the two major subsystems:\n\n```mermaid\ngraph TB\n    subgraph \"AES Subsystem (Standalone)\"\n        AES_CIPHER[\"Cipher.m\u003cbr/\u003eInvCipher.m\"]\n        AES_KEYS[\"KeyExpansion.m\"]\n        AES_TRANS[\"SubBytes, ShiftRows,\u003cbr/\u003eMixColumns, AddRoundKey\"]\n        AES_INV[\"InvSubBytes, InvShiftRows,\u003cbr/\u003eInvMixColumns\"]\n        AES_UTIL[\"xtime.m\"]\n        \n        AES_CIPHER --\u003e AES_KEYS\n        AES_CIPHER --\u003e AES_TRANS\n        AES_CIPHER --\u003e AES_INV\n        AES_TRANS --\u003e AES_UTIL\n        AES_INV --\u003e AES_UTIL\n    end\n    \n    subgraph \"Fingerprint Subsystem\"\n        FP_EXTRACT[\"FExtraction/\u003cbr/\u003eFeature extraction functions\"]\n        FP_MATCH[\"Copy_of_match.m\"]\n        FP_SCORE[\"Copy_of_score.m\"]\n        FP_DB[\"db.mat\"]\n        FP_FILTERS[\"angular_filters_*.mat\"]\n        \n        FP_EXTRACT --\u003e FP_MATCH\n        FP_MATCH --\u003e FP_SCORE\n        FP_DB --\u003e FP_MATCH\n        FP_FILTERS --\u003e FP_EXTRACT\n    end\n    \n    AES_CIPHER -.-\u003e|\"No integration\"| FP_DB\n    AES_CIPHER -.-\u003e|\"No integration\"| FP_MATCH\n```\n\n**Observations**:\n1. No function in the fingerprint subsystem calls any AES function\n2. No AES function references fingerprint data structures\n3. No shared utility functions or data formats between subsystems\n4. The systems operate on different data types (hexadecimal strings vs. numeric arrays)\n\n**Sources**: [AES_update/Cipher.m:1-28](), [Copy_of_match.m:1-411]()\n\n---\n\n### Potential Integration Points\n\nWhile currently disconnected, the co-location of these systems suggests potential future integration scenarios:\n\n| Integration Point | AES Component | Fingerprint Component | Purpose |\n|-------------------|---------------|----------------------|---------|\n| Database Encryption | `Cipher.m` | `db.mat` minutiae data | Protect stored biometric templates |\n| Match Result Encryption | `Cipher.m` | Match score outputs | Secure transmission of authentication results |\n| Template Protection | `Cipher.m` / `InvCipher.m` | Extracted minutiae | Privacy-preserving biometric matching |\n\nSuch integration would require:\n- Data serialization layer to convert minutiae matrices to hexadecimal format\n- Key management system for encryption keys\n- Modified matching algorithm to work with encrypted templates (or decrypt-then-match workflow)\n\n**Sources**: Analysis based on [AES_update/Cipher.m:1-28](), [Copy_of_match.m:17-411]()\n\n---\n\n## Technology Stack\n\nThe entire system is implemented in **MATLAB** and depends on the following built-in capabilities:\n\n| Category | Dependencies | Used By |\n|----------|-------------|---------|\n| Image Processing | `imfilter`, `imresize` | Feature extraction functions |\n| Signal Processing | `fft2`, `ifft2` | [FExtraction/fft_enhance_cubs.m:103]() |\n| Matrix Operations | `reshape`, `meshgrid` | All subsystems |\n| File I/O | `load`, `save` | [Copy_of_match.m:18]() |\n| Data Type Conversion | `hex2dec`, `dec2hex` | [AES_update/Cipher.m:12](), [AES_update/Cipher.m:26]() |\n\nNo external libraries or toolboxes beyond standard MATLAB are required.\n\n**Sources**: [AES_update/Cipher.m:12-26](), [FExtraction/fft_enhance_cubs.m:103](), [Copy_of_match.m:18]()\n\n---\n\n## Quick Reference: Main Entry Points\n\nFor developers looking to use or modify the system, the following are the primary entry points:\n\n### AES Operations\n- **Encryption**: `Out = Cipher(key, In)` at [AES_update/Cipher.m:1]()\n  - `key`: 32/48/64 character hexadecimal string\n  - `In`: 32 character hexadecimal string (128 bits)\n  - `Out`: 32 character encrypted hexadecimal string\n\n- **Decryption**: `Out = InvCipher(key, In)` at [AES_update/InvCipher.m:1]()\n  - Same parameters as `Cipher`\n\n### Fingerprint Operations\n- **Feature Extraction**: `[enhimg, cimg, oimg, fimg, bwimg, eimg] = fft_enhance_cubs(img, BLKSZ)` at [FExtraction/fft_enhance_cubs.m:22]()\n  - `img`: Double-type grayscale fingerprint image\n  - Returns: Enhanced image and multiple feature maps\n\n- **Matching**: `[result, result_r] = Copy_of_match(Index, Number, display_flag)` at [Copy_of_match.m:17]()\n  - `Index`: Reference fingerprint index in database\n  - `Number`: Number of matching iterations\n  - `display_flag`: Set to 1 for distance calculations\n  - Returns: Distance metrics and candidate indices\n\n**Sources**: [AES_update/Cipher.m:1](), [AES_update/InvCipher.m:1](), [FExtraction/fft_enhance_cubs.m:22](), [Copy_of_match.m:17]()\n\n---\n\n## License\n\nThe AES implementation is licensed under a BSD-style license, copyright (c) 2020 by David Hill of Brigham Young University. See [AES_update/license.txt:1-28]() for full license terms. The fingerprint matching system is attributed to Vahid. K. Alilou of the University of Semnan, dated July 2013, as noted in [Copy_of_match.m:11-15]().\n\n**Sources**: [AES_update/license.txt:1-28](), [Copy_of_match.m:11-15]()"])</script><script>self.__next_f.push([1,"18:T357b,"])</script><script>self.__next_f.push([1,"# System Architecture\n\n\u003cdetails\u003e\n\u003csummary\u003eRelevant source files\u003c/summary\u003e\n\nThe following files were used as context for generating this wiki page:\n\n- [AES_update/Cipher.m](AES_update/Cipher.m)\n- [AES_update/KeyExpansion.m](AES_update/KeyExpansion.m)\n- [Copy_of_match.m](Copy_of_match.m)\n- [FExtraction/ridgeorient.m](FExtraction/ridgeorient.m)\n\n\u003c/details\u003e\n\n\n\n## Purpose and Scope\n\nThis document describes the high-level architecture of the Simple Fingerprint Matching system, which consists of two largely independent subsystems: an **AES encryption implementation** and a **fingerprint processing pipeline**. The architecture demonstrates a modular design where encryption and biometric processing exist as separate, self-contained components with potential for future integration.\n\nThis page focuses on the structural organization and relationships between major subsystems. For detailed information about individual components, see:\n- AES encryption implementation details: [AES Encryption System](#2)\n- Fingerprint feature extraction details: [Feature Extraction Pipeline](#3.1)\n- Fingerprint matching algorithms: [Fingerprint Matching](#3.2)\n- Data file specifications: [Data Files and Dependencies](#1.2)\n\n---\n\n## Overall System Structure\n\nThe system consists of three primary subsystems organized into distinct directories, with minimal coupling between them:\n\n```mermaid\ngraph TB\n    subgraph Root[\"Repository Root\"]\n        subgraph AES[\"AES_update/\"]\n            C[\"Cipher.m\"]\n            IC[\"InvCipher.m\"]\n            KE[\"KeyExpansion.m\"]\n            SB[\"SubBytes.m\"]\n            SR[\"ShiftRows.m\"]\n            MC[\"MixColumns.m\"]\n            ARK[\"AddRoundKey.m\"]\n            ISB[\"InvSubBytes.m\"]\n            ISR[\"InvShiftRows.m\"]\n            IMC[\"InvMixColumns.m\"]\n            XT[\"xtime.m\"]\n        end\n        \n        subgraph FEXT[\"FExtraction/\"]\n            RS[\"ridgesegment.m\"]\n            RO[\"ridgeorient.m\"]\n            RF[\"ridgefreq.m\"]\n            RFILT[\"ridgefilter.m\"]\n            FFT[\"fft_enhance_cubs.m\"]\n            AFB[\"angular_filter_bank.m\"]\n            UTILS[\"Supporting utilities\u003cbr/\u003esmoothen_*.m\u003cbr/\u003ecompute_coherence.m\"]\n        end\n        \n        subgraph MATCH[\"Matching Files (Root)\"]\n            CM[\"Copy_of_match.m\"]\n            CS[\"Copy_of_score.m\"]\n            TRANS[\"transform.m\"]\n            TRANS2[\"transform2.m\"]\n        end\n        \n        subgraph DATA[\"Data Files (Root)\"]\n            DB[(\"db.mat\u003cbr/\u003e(minutiae database)\")]\n            FILT[(\"angular_filters_*.mat\u003cbr/\u003e(precomputed filters)\")]\n        end\n    end\n    \n    C --\u003e KE\n    C --\u003e SB\n    C --\u003e SR\n    C --\u003e MC\n    C --\u003e ARK\n    IC --\u003e KE\n    IC --\u003e ISB\n    IC --\u003e ISR\n    IC --\u003e IMC\n    IC --\u003e ARK\n    MC --\u003e XT\n    IMC --\u003e XT\n    KE --\u003e XT\n    \n    RS --\u003e RO\n    RO --\u003e RF\n    RF --\u003e RFILT\n    FFT --\u003e AFB\n    \n    CM --\u003e DB\n    CM --\u003e CS\n    CM --\u003e TRANS\n    CM --\u003e TRANS2\n    \n    FEXT -.-\u003e|\"produces minutiae\u003cbr/\u003e(not visible in code)\"| DB\n    \n    style AES fill:#f9f9f9\n    style FEXT fill:#f9f9f9\n    style MATCH fill:#f9f9f9\n    style DATA fill:#f9f9f9\n```\n\n**Sources:** Repository structure, [AES_update/Cipher.m:1-28](), [FExtraction/ridgeorient.m:1-97](), [Copy_of_match.m:1-411]()\n\n---\n\n## Component Directory Organization\n\nThe system uses a clear directory-based separation of concerns:\n\n| Directory | Purpose | File Count | Key Functions |\n|-----------|---------|------------|---------------|\n| `AES_update/` | AES encryption/decryption implementation | 11 | `Cipher`, `InvCipher`, `KeyExpansion` |\n| `FExtraction/` | Fingerprint image enhancement and feature extraction | ~15 | `ridgesegment`, `ridgeorient`, `ridgefreq`, `ridgefilter`, `fft_enhance_cubs` |\n| Root | Fingerprint matching and transformation | 4 | `Copy_of_match`, `Copy_of_score`, `transform`, `transform2` |\n| Data files | Database and precomputed filter banks | Variable | `db.mat`, `angular_filters_*.mat` |\n\n**Sources:** Repository structure\n\n---\n\n## AES Encryption Subsystem\n\nThe AES subsystem implements a complete, self-contained Advanced Encryption Standard cipher with no dependencies on the fingerprint processing components:\n\n```mermaid\ngraph LR\n    subgraph Encryption[\"Encryption Path\"]\n        KEY1[\"Encryption Key\u003cbr/\u003e(128/192/256-bit)\"]\n        KEY1 --\u003e Cipher[\"Cipher.m\u003cbr/\u003eLines 1-28\"]\n        \n        Cipher --\u003e KE1[\"KeyExpansion.m\u003cbr/\u003eGenerates round keys\"]\n        Cipher --\u003e RoundOps1[\"Round Operations:\u003cbr/\u003eSubBytes.m\u003cbr/\u003eShiftRows.m\u003cbr/\u003eMixColumns.m\u003cbr/\u003eAddRoundKey.m\"]\n        \n        RoundOps1 --\u003e XT1[\"xtime.m\u003cbr/\u003eGF(2^8) multiplication\"]\n        KE1 --\u003e XT1\n    end\n    \n    subgraph Decryption[\"Decryption Path\"]\n        KEY2[\"Decryption Key\u003cbr/\u003e(128/192/256-bit)\"]\n        KEY2 --\u003e InvCipher[\"InvCipher.m\u003cbr/\u003eInverse cipher\"]\n        \n        InvCipher --\u003e KE2[\"KeyExpansion.m\u003cbr/\u003e(shared)\"]\n        InvCipher --\u003e RoundOps2[\"Inverse Operations:\u003cbr/\u003eInvSubBytes.m\u003cbr/\u003eInvShiftRows.m\u003cbr/\u003eInvMixColumns.m\u003cbr/\u003eAddRoundKey.m\"]\n        \n        RoundOps2 --\u003e XT2[\"xtime.m\u003cbr/\u003e(shared)\"]\n        KE2 --\u003e XT2\n    end\n    \n    Cipher --\u003e CTEXT[\"Ciphertext\"]\n    InvCipher --\u003e PTEXT[\"Plaintext\"]\n```\n\n### Key Characteristics\n\n- **Standalone Operation**: No integration with fingerprint processing\n- **Standard Compliance**: Implements FIPS-197 specification [AES_update/Cipher.m:3-4]()\n- **Key Sizes**: Supports AES-128, AES-192, and AES-256 determined by `Nk` parameter [AES_update/Cipher.m:11]()\n- **Round Count**: `Nk+6` rounds based on key size [AES_update/Cipher.m:16]()\n- **Shared Components**: `KeyExpansion.m`, `AddRoundKey.m`, and `xtime.m` are used by both encryption and decryption\n\nFor detailed implementation, see [AES Encryption System](#2).\n\n**Sources:** [AES_update/Cipher.m:1-28](), [AES_update/KeyExpansion.m:1-20]()\n\n---\n\n## Fingerprint Processing Subsystem\n\nThe fingerprint processing subsystem operates in two stages: feature extraction and matching.\n\n```mermaid\ngraph TB\n    subgraph Stage1[\"Stage 1: Feature Extraction (FExtraction/)\"]\n        RAW[\"Raw Fingerprint Image\"]\n        \n        RAW --\u003e SEG[\"ridgesegment.m\u003cbr/\u003eNormalization \u0026 Segmentation\"]\n        SEG --\u003e NORM[\"Normalized image\u003cbr/\u003e+ Binary mask\"]\n        \n        NORM --\u003e ORI[\"ridgeorient.m\u003cbr/\u003eOrientation estimation\"]\n        ORI --\u003e OIMG[\"Orientation image\u003cbr/\u003e+ Reliability map\"]\n        \n        NORM --\u003e FREQ[\"ridgefreq.m\u003cbr/\u003eFrequency analysis\"]\n        OIMG --\u003e FREQ\n        FREQ --\u003e FIMG[\"Frequency image\u003cbr/\u003e+ Median frequency\"]\n        \n        NORM --\u003e FILT[\"ridgefilter.m\u003cbr/\u003eGabor filtering\"]\n        OIMG --\u003e FILT\n        FIMG --\u003e FILT\n        \n        FILT --\u003e ENH[\"Enhanced fingerprint\"]\n        \n        RAW -.-\u003e|\"Alternative path\"| FFT[\"fft_enhance_cubs.m\u003cbr/\u003eFFT-based enhancement\"]\n        FFT --\u003e ENH2[\"Enhanced + feature maps\"]\n        \n        AFB[\"angular_filter_bank.m\"] -.-\u003e|\"Precomputed filters\"| FFT\n        AFB -.-\u003e|\"Stored in .mat files\"| AFILT[(\"angular_filters_*.mat\")]\n    end\n    \n    subgraph Stage2[\"Stage 2: Matching (Root directory)\"]\n        DB[(\"db.mat\u003cbr/\u003eMinutiae database\u003cbr/\u003eff cell array\")]\n        \n        ENH -.-\u003e|\"Minutiae extraction\u003cbr/\u003e(not in codebase)\"| DB\n        ENH2 -.-\u003e|\"Minutiae extraction\u003cbr/\u003e(not in codebase)\"| DB\n        \n        DB --\u003e MATCH[\"Copy_of_match.m\u003cbr/\u003eMain matching engine\"]\n        \n        MATCH --\u003e TRANS[\"transform.m\u003cbr/\u003eTranslation\"]\n        MATCH --\u003e TRANS2[\"transform2.m\u003cbr/\u003eRotation\"]\n        MATCH --\u003e SCORE[\"Copy_of_score.m\u003cbr/\u003eSimilarity scoring\"]\n        \n        SCORE --\u003e RESULT[\"Match results\u003cbr/\u003eDistance metrics\"]\n    end\n```\n\n### Key Characteristics\n\n- **Pipeline Architecture**: Sequential processing from raw image to enhanced features\n- **Dual Enhancement Paths**: Standard Gabor filtering and alternative FFT-based approach\n- **Database-Driven Matching**: Loads minutiae from `db.mat` [Copy_of_match.m:18]()\n- **Brute-Force Alignment**: Tests multiple translations and rotations [Copy_of_match.m:63-137]()\n- **Missing Link**: Minutiae extraction code not present in repository (gap between enhancement and matching)\n\nFor detailed implementation, see [Feature Extraction Pipeline](#3.1) and [Fingerprint Matching](#3.2).\n\n**Sources:** [FExtraction/ridgeorient.m:1-97](), [Copy_of_match.m:1-411]()\n\n---\n\n## Data Dependencies and Flow\n\n```mermaid\ngraph TB\n    subgraph External[\"External Inputs\"]\n        RAWIMG[\"Raw fingerprint images\u003cbr/\u003e(not in repository)\"]\n        KEYS[\"AES keys\u003cbr/\u003e(128/192/256-bit hex)\"]\n    end\n    \n    subgraph Precomputed[\"Precomputed Data Files\"]\n        AFILT[(\"angular_filters_*.mat\")]\n        DB[(\"db.mat\")]\n    end\n    \n    subgraph Processing[\"Processing Systems\"]\n        AFB[\"angular_filter_bank.m\u003cbr/\u003eGenerates filters\"]\n        \n        FEXT[\"Feature Extraction\u003cbr/\u003e(FExtraction/)\"]\n        \n        MINEXT[\"Minutiae Extraction\u003cbr/\u003e(external tool)\"]\n        \n        MATCH[\"Copy_of_match.m\u003cbr/\u003eMatching engine\"]\n        \n        AES[\"AES System\u003cbr/\u003e(AES_update/)\"]\n    end\n    \n    subgraph Outputs[\"Outputs\"]\n        ENHANCED[\"Enhanced images\"]\n        MATCHRES[\"Match results\u003cbr/\u003eDistance metrics\"]\n        CIPHER[\"Encrypted data\"]\n    end\n    \n    AFB --\u003e|\"Saves to\"| AFILT\n    AFILT --\u003e|\"Loaded by\"| FEXT\n    \n    RAWIMG --\u003e|\"Processed by\"| FEXT\n    FEXT --\u003e|\"Produces\"| ENHANCED\n    \n    ENHANCED -.-\u003e|\"External processing\"| MINEXT\n    MINEXT -.-\u003e|\"Stores in\"| DB\n    \n    DB --\u003e|\"Loaded at line 18\"| MATCH\n    MATCH --\u003e|\"Produces\"| MATCHRES\n    \n    KEYS --\u003e|\"Input to\"| AES\n    AES --\u003e|\"Produces\"| CIPHER\n    \n    AES -.-\u003e|\"No integration\u003cbr/\u003e(potential future)\"| DB\n    AES -.-\u003e|\"No integration\u003cbr/\u003e(potential future)\"| MATCHRES\n```\n\n### Data Flow Characteristics\n\n1. **Filter Bank Generation**: `angular_filter_bank.m` creates and saves filter sets to `.mat` files for reuse\n2. **Database Loading**: `Copy_of_match.m` loads the entire minutiae database into memory via `load('db.mat')` [Copy_of_match.m:18]()\n3. **Cell Array Structure**: Database uses `ff` cell array indexing: `ff{Index*8-7}` for reference fingerprint [Copy_of_match.m:19,25]()\n4. **No Direct Integration**: AES subsystem operates independently with no data exchange with fingerprint pipeline\n\n**Sources:** [Copy_of_match.m:18-25]()\n\n---\n\n## Integration Points and System Boundaries\n\nThe architecture reveals clear boundaries between subsystems:\n\n```mermaid\ngraph TB\n    subgraph MATLAB[\"MATLAB Runtime Environment\"]\n        \n        subgraph AES_SYS[\"AES Subsystem\u003cbr/\u003e(Complete \u0026 Isolated)\"]\n            AES_IN[\"Hexadecimal input\"]\n            AES_PROC[\"Cipher/InvCipher\u003cbr/\u003e11 function files\"]\n            AES_OUT[\"Hexadecimal output\"]\n            \n            AES_IN --\u003e AES_PROC\n            AES_PROC --\u003e AES_OUT\n        end\n        \n        subgraph FP_SYS[\"Fingerprint Subsystem\u003cbr/\u003e(Two-Stage Pipeline)\"]\n            FP_IN[\"Raw images\"]\n            FP_EXTRACT[\"Feature Extraction\u003cbr/\u003eFExtraction/\"]\n            FP_GAP[\"Missing: Minutiae\u003cbr/\u003eextraction code\"]\n            FP_MATCH[\"Matching\u003cbr/\u003eCopy_of_match.m\"]\n            FP_OUT[\"Distance metrics\"]\n            \n            FP_IN --\u003e FP_EXTRACT\n            FP_EXTRACT -.-\u003e|\"Gap\"| FP_GAP\n            FP_GAP -.-\u003e|\"db.mat\"| FP_MATCH\n            FP_MATCH --\u003e FP_OUT\n        end\n        \n        MATLAB_FUNCS[\"MATLAB Built-ins:\u003cbr/\u003efft2, filter2, imfilter\u003cbr/\u003efspecial, hex2dec, bitxor\"]\n        \n        AES_PROC -.-\u003e|\"Uses\"| MATLAB_FUNCS\n        FP_EXTRACT -.-\u003e|\"Uses\"| MATLAB_FUNCS\n    end\n    \n    subgraph Future[\"Potential Integration (Not Implemented)\"]\n        SEC_DB[\"Encrypted db.mat\u003cbr/\u003eusing AES\"]\n        SEC_RES[\"Encrypted results\u003cbr/\u003eusing AES\"]\n    end\n    \n    AES_SYS -.-\u003e|\"Could encrypt\"| SEC_DB\n    AES_SYS -.-\u003e|\"Could encrypt\"| SEC_RES\n    FP_SYS -.-\u003e|\"Could use\"| SEC_DB\n    FP_SYS -.-\u003e|\"Could produce\"| SEC_RES\n```\n\n### System Boundary Analysis\n\n| Boundary | Status | Evidence |\n|----------|--------|----------|\n| AES ↔ Fingerprint | **No integration** | No function calls between subsystems |\n| Feature Extraction ↔ Matching | **Indirect via file** | `db.mat` bridges the gap |\n| Code ↔ MATLAB Runtime | **Strong dependency** | Extensive use of MATLAB built-ins |\n| Enhancement ↔ Minutiae | **External gap** | Minutiae extraction not in codebase |\n\n### Potential Integration Scenarios\n\nThe presence of both subsystems suggests three possible integration approaches:\n\n1. **Database Encryption**: Encrypt `db.mat` using `Cipher.m` before storage, decrypt with `InvCipher.m` before matching\n2. **Result Encryption**: Encrypt match results from `Copy_of_match.m` for secure transmission\n3. **Secure Storage**: Encrypt angular filter banks and other precomputed data\n\nNone of these integrations are currently implemented in the codebase.\n\n**Sources:** Repository structure, [AES_update/Cipher.m:1-28](), [Copy_of_match.m:18]()\n\n---\n\n## Architecture Summary\n\n| Characteristic | Description |\n|----------------|-------------|\n| **Primary Pattern** | Independent subsystems with modular organization |\n| **AES Subsystem** | 11 files, self-contained, FIPS-197 compliant |\n| **Fingerprint Subsystem** | ~19 files across extraction and matching |\n| **Coupling** | Minimal - only via `db.mat` between extraction/matching |\n| **Missing Components** | Minutiae extraction, explicit AES integration |\n| **Data Flow** | File-based (`.mat` files) rather than API-based |\n| **Extensibility** | High - modular structure allows independent development |\n\nThe architecture demonstrates a **\"components awaiting integration\"** pattern, where two complete subsystems exist side-by-side with clear potential for security enhancements but no explicit coupling in the current implementation.\n\n**Sources:** Repository structure, [AES_update/Cipher.m:1-28](), [FExtraction/ridgeorient.m:1-97](), [Copy_of_match.m:1-411]()"])</script><script>self.__next_f.push([1,"19:T32e6,"])</script><script>self.__next_f.push([1,"# Data Files and Dependencies\n\n\u003cdetails\u003e\n\u003csummary\u003eRelevant source files\u003c/summary\u003e\n\nThe following files were used as context for generating this wiki page:\n\n- [Copy_of_match.m](Copy_of_match.m)\n- [FExtraction/angular_filter_bank.m](FExtraction/angular_filter_bank.m)\n- [FExtraction/angular_filters_pi_2.mat](FExtraction/angular_filters_pi_2.mat)\n- [FExtraction/angular_filters_pi_4.mat](FExtraction/angular_filters_pi_4.mat)\n\n\u003c/details\u003e\n\n\n\nThis page documents the external data files and runtime dependencies required by the Simple Fingerprint Matching system. The system relies on precomputed data files in MATLAB `.mat` format and depends on standard MATLAB built-in functions for numerical computations and image processing operations.\n\nFor information about how these data files are used in the fingerprint matching workflow, see [Fingerprint Matching](#3.2). For details on how angular filter banks are generated, see [Angular Filter Banks](#3.1.6).\n\n---\n\n## Overview\n\nThe system requires two categories of external dependencies:\n\n1. **Data Files**: Binary MATLAB data files (`.mat` format) containing precomputed fingerprint features and filter coefficients\n2. **MATLAB Runtime**: Built-in MATLAB functions for mathematical operations, image processing, and file I/O\n\n```mermaid\ngraph TB\n    subgraph \"Data Files\"\n        DB[\"db.mat\u003cbr/\u003eFingerprint Database\"]\n        FILTERS[\"angular_filters_*.mat\u003cbr/\u003eFilter Bank Files\"]\n    end\n    \n    subgraph \"MATLAB Runtime Dependencies\"\n        MATH[\"Mathematical Functions\u003cbr/\u003esqrt, cos, sin, atan2\"]\n        IMAGE[\"Image Processing\u003cbr/\u003eimfilter, fft2, ifft2\"]\n        IO[\"File I/O\u003cbr/\u003eload, save\"]\n        ARRAY[\"Array Operations\u003cbr/\u003emeshgrid, transpose\"]\n    end\n    \n    subgraph \"System Components\"\n        MATCH[\"Copy_of_match.m\u003cbr/\u003eMatching Engine\"]\n        FILTER_GEN[\"angular_filter_bank.m\u003cbr/\u003eFilter Generator\"]\n        ENHANCE[\"fft_enhance_cubs.m\u003cbr/\u003eEnhancement\"]\n    end\n    \n    DB --\u003e MATCH\n    FILTERS --\u003e ENHANCE\n    \n    IO --\u003e MATCH\n    IO --\u003e FILTER_GEN\n    MATH --\u003e FILTER_GEN\n    ARRAY --\u003e FILTER_GEN\n    IMAGE --\u003e ENHANCE\n```\n\n**Sources:** [Copy_of_match.m:18](), [FExtraction/angular_filter_bank.m:1-97]()\n\n---\n\n## Fingerprint Database File (db.mat)\n\nThe fingerprint database is stored in a file named `db.mat` located in the repository root directory. This file contains a cell array variable `ff` that stores minutiae feature sets for multiple fingerprint images.\n\n### Database Structure\n\nThe `db.mat` file contains the following MATLAB variable:\n\n| Variable Name | Type | Description |\n|---------------|------|-------------|\n| `ff` | Cell array | Collection of minutiae feature matrices, one per fingerprint sample |\n\nEach cell in the `ff` array contains a numeric matrix representing the minutiae points extracted from one fingerprint image. The matrix structure is:\n\n| Column | Data Type | Description |\n|--------|-----------|-------------|\n| 1 | double | X-coordinate of minutia point (pixels) |\n| 2 | double | Y-coordinate of minutia point (pixels) |\n| 3 | double | Minutia type/quality indicator (filtered if ≥ 5) |\n| 4 | double | Orientation angle (radians) |\n| 5+ | double | Additional feature attributes |\n\n**Sources:** [Copy_of_match.m:18-36]()\n\n### Database Access Pattern\n\nThe matching engine accesses the database using a specific indexing scheme:\n\n```mermaid\ngraph LR\n    INDEX[\"Input Index\u003cbr/\u003eFingerprint ID\"]\n    CALC[\"Index Calculation\u003cbr/\u003eIndex*8-7\"]\n    LOAD[\"Load from ff{Index}\"]\n    FILTER[\"Filter Minutiae\u003cbr/\u003ecolumn 3 \u003c 5\"]\n    USE[\"Use in Matching\"]\n    \n    INDEX --\u003e CALC\n    CALC --\u003e LOAD\n    LOAD --\u003e FILTER\n    FILTER --\u003e USE\n```\n\nThe matching function loads fingerprints using the formula `Index*8-7` to compute the cell array index, suggesting the database is organized in groups of 8 samples per fingerprint identity (likely representing different impressions or transformations of the same finger).\n\n**Example:**\n- Input Index = 1 → Cell index = 1*8-7 = 1 (first sample of first fingerprint)\n- Input Index = 2 → Cell index = 2*8-7 = 9 (first sample of second fingerprint)\n\nThe system loads one reference fingerprint and selects 5 random candidates from the same group using `randperm(7,5)+Index` to generate indices within the 8-sample group.\n\n**Sources:** [Copy_of_match.m:17-30]()\n\n### Minutiae Filtering\n\nBefore use, minutiae are filtered based on quality metrics:\n\n```\nM1 = M1(M1(:,3)\u003c5,:);\n```\n\nThis operation removes minutiae points where column 3 (quality/type indicator) has a value ≥ 5, retaining only high-confidence feature points for matching operations.\n\n**Sources:** [Copy_of_match.m:31-36]()\n\n---\n\n## Angular Filter Bank Files\n\nAngular filter banks are precomputed frequency-domain filters used for fingerprint image enhancement. These filters are stored as `.mat` files and must be generated before use in the enhancement pipeline.\n\n### Filter File Naming Convention\n\nThe filter files follow the naming pattern:\n\n```\nangular_filters_\u003cdescription\u003e.mat\n```\n\nWhere `\u003cdescription\u003e` typically indicates the filter bandwidth or configuration. Examples might include:\n- `angular_filters_bw1.mat`\n- `angular_filters_bw2.mat`\n- `angular_filters_default.mat`\n\n### Filter Generation Process\n\n```mermaid\ngraph TD\n    PARAMS[\"Input Parameters\u003cbr/\u003eBW: bandwidth\u003cbr/\u003efname: filename\"]\n    MESHGRID[\"meshgrid\u003cbr/\u003eGenerate 32x32 grid\"]\n    POLAR[\"Convert to Polar\u003cbr/\u003er = sqrt(x²+y²)\u003cbr/\u003eth = atan2(y,x)\"]\n    \n    subgraph \"For each angle t0\"\n        LOBE1[\"First Lobe\u003cbr/\u003ed = angular_distance(th,t0)\u003cbr/\u003emsk = 1+cos(d*pi/BW)\"]\n        LOBE2[\"Second Lobe\u003cbr/\u003et1 = t0+pi\u003cbr/\u003ed = angular_distance(th,t1)\u003cbr/\u003emsk = 1+cos(d*pi/BW)\"]\n        COMBINE[\"Combine Lobes\u003cbr/\u003ermsk = lobe1 + lobe2\"]\n    end\n    \n    COLLECT[\"Collect All Filters\u003cbr/\u003e12 orientations\"]\n    SAVE[\"save(fname, 'angf')\"]\n    CHEADER[\"Generate C Header\u003cbr/\u003efname.h\"]\n    \n    PARAMS --\u003e MESHGRID\n    MESHGRID --\u003e POLAR\n    POLAR --\u003e LOBE1\n    LOBE1 --\u003e LOBE2\n    LOBE2 --\u003e COMBINE\n    COMBINE --\u003e COLLECT\n    COLLECT --\u003e SAVE\n    COLLECT --\u003e CHEADER\n```\n\n**Sources:** [FExtraction/angular_filter_bank.m:21-97]()\n\n### Filter Structure\n\nThe angular filter bank file contains a single MATLAB variable:\n\n| Variable Name | Type | Dimensions | Description |\n|---------------|------|------------|-------------|\n| `angf` | double matrix | 1024 × 12 | Filter coefficients for 12 angular orientations |\n\nThe matrix dimensions are derived from:\n- **Rows:** FFTN² = 32² = 1024 (flattened 32×32 filter coefficients)\n- **Columns:** TSTEPS = 12 (number of angular steps, 15° intervals covering 180°)\n\nEach column represents a raised cosine filter oriented at a specific angle with two symmetric lobes separated by 180°.\n\n**Sources:** [FExtraction/angular_filter_bank.m:26-67]()\n\n### Filter Generation Parameters\n\nThe `angular_filter_bank` function accepts two parameters:\n\n| Parameter | Type | Description |\n|-----------|------|-------------|\n| `BW` | double | Bandwidth of the raised cosine filter (radians) |\n| `fname` | string | Output filename (without `.mat` extension) |\n\nKey constants:\n- `FFTN = 32`: Filter size (32×32 pixels)\n- `TSTEPS = 12`: Number of angular steps (15° intervals)\n- `DELTAT = π/TSTEPS`: Angular increment between filters\n\n**Sources:** [FExtraction/angular_filter_bank.m:21-28]()\n\n### Angular Distance Computation\n\nThe filters use an angular distance metric that computes the acute angle between two orientations:\n\n```\nd = abs(th - t0)\nd = min(d, 2π - d)\n```\n\nThis ensures the distance wraps correctly at the 0°/360° boundary and always represents the shortest angular path.\n\n**Sources:** [FExtraction/angular_filter_bank.m:93-96]()\n\n### C Header Generation\n\nThe filter generation function also produces a C header file (`fname.h`) containing the filter coefficients formatted as C arrays. This enables integration with C/C++ implementations of the fingerprint enhancement algorithm. The header file structure follows standard C array initialization syntax with nested braces.\n\n**Sources:** [FExtraction/angular_filter_bank.m:71-86]()\n\n---\n\n## MATLAB Runtime Dependencies\n\nThe system relies on standard MATLAB built-in functions across several categories. These dependencies require a compatible MATLAB environment (R2010a or later recommended based on syntax patterns).\n\n### Mathematical Functions\n\n| Function | Purpose | Used By |\n|----------|---------|---------|\n| `sqrt` | Square root calculation | Distance computations, polar conversion |\n| `cos`, `sin` | Trigonometric operations | Filter generation, rotation transforms |\n| `atan2` | Four-quadrant inverse tangent | Polar angle computation |\n| `abs` | Absolute value | Distance metrics, angular distance |\n| `min`, `max` | Extrema finding | Statistical analysis, angular distance |\n\n**Sources:** [FExtraction/angular_filter_bank.m:33-95](), [Copy_of_match.m:253-389]()\n\n### Array Operations\n\n| Function | Purpose | Used By |\n|----------|---------|---------|\n| `meshgrid` | Generate 2D coordinate grids | Filter generation |\n| `transpose` | Matrix transposition | Filter reshaping |\n| `size` | Array dimensions | Loop bounds, validation |\n| `randperm` | Random permutation | Candidate selection |\n\n**Sources:** [FExtraction/angular_filter_bank.m:32-60](), [Copy_of_match.m:22]()\n\n### File I/O Functions\n\n```mermaid\ngraph LR\n    LOAD[\"load('db.mat')\"]\n    SAVE[\"save(fname, 'angf')\"]\n    FOPEN[\"fopen(fname.h, 'w')\"]\n    FPRINTF[\"fprintf(fp, ...)\"]\n    FCLOSE[\"fclose(fp)\"]\n    \n    LOAD --\u003e DB[\"Database Access\"]\n    SAVE --\u003e FILTERS[\"Filter Storage\"]\n    FOPEN --\u003e CHEADER[\"C Header Generation\"]\n    FPRINTF --\u003e CHEADER\n    FCLOSE --\u003e CHEADER\n```\n\n| Function | Purpose | Used By |\n|----------|---------|---------|\n| `load` | Load `.mat` files | Database loading, filter loading |\n| `save` | Save `.mat` files | Filter bank generation |\n| `fopen`, `fclose` | File handle management | C header generation |\n| `fprintf` | Formatted output | C header generation |\n| `eval`, `sprintf` | Dynamic code execution | Parameterized save operations |\n\n**Sources:** [Copy_of_match.m:18](), [FExtraction/angular_filter_bank.m:67-86]()\n\n### Image Processing Functions\n\nWhile not visible in the provided files, the broader feature extraction pipeline (referenced in [Feature Extraction Pipeline](#3.1)) depends on:\n\n| Function | Purpose |\n|----------|---------|\n| `fft2`, `ifft2` | 2D Fast Fourier Transform |\n| `imfilter` | Image filtering operations |\n| `conv2` | 2D convolution |\n| `imresize` | Image resizing |\n\n---\n\n## Dependency Summary\n\n```mermaid\ngraph TB\n    subgraph \"Required Data Files\"\n        DB_FILE[\"db.mat\u003cbr/\u003e\u003cb\u003eRequired\u003c/b\u003e\u003cbr/\u003eMinutiae database\u003cbr/\u003eff cell array\"]\n        FILTER_FILES[\"angular_filters_*.mat\u003cbr/\u003e\u003cb\u003eOptional\u003c/b\u003e\u003cbr/\u003ePrecomputed filters\u003cbr/\u003eangf matrix\"]\n    end\n    \n    subgraph \"MATLAB Environment\"\n        MATLAB_VER[\"MATLAB R2010a+\"]\n        CORE_TB[\"Core Toolbox\"]\n        IMG_TB[\"Image Processing Toolbox\u003cbr/\u003e(for enhancement)\"]\n    end\n    \n    subgraph \"System Components\"\n        MATCH_SYS[\"Matching System\u003cbr/\u003eCopy_of_match.m\"]\n        EXTRACT_SYS[\"Feature Extraction\u003cbr/\u003eFExtraction/\"]\n    end\n    \n    DB_FILE --\u003e MATCH_SYS\n    FILTER_FILES --\u003e EXTRACT_SYS\n    \n    MATLAB_VER --\u003e CORE_TB\n    MATLAB_VER --\u003e IMG_TB\n    \n    CORE_TB --\u003e MATCH_SYS\n    CORE_TB --\u003e EXTRACT_SYS\n    IMG_TB --\u003e EXTRACT_SYS\n    \n    style DB_FILE fill:#fee\n    style FILTER_FILES fill:#efe\n```\n\n### Critical Dependencies\n\n| Component | Type | Required | Location |\n|-----------|------|----------|----------|\n| `db.mat` | Data file | **Yes** | Repository root |\n| Angular filter `.mat` files | Data file | No* | Repository root or specified path |\n| MATLAB Core | Runtime | **Yes** | System installation |\n| Image Processing Toolbox | Runtime | No* | System installation |\n\n\\* Required only for feature extraction and enhancement; not needed for matching operations with pre-extracted features.\n\n**Sources:** [Copy_of_match.m:18](), [FExtraction/angular_filter_bank.m:67]()\n\n---\n\n## File Regeneration\n\n### Regenerating Angular Filters\n\nTo regenerate angular filter bank files:\n\n```matlab\nangular_filter_bank(BW, 'angular_filters_output')\n```\n\nParameters:\n- `BW`: Bandwidth in radians (typical values: 0.5 to 1.5)\n- Second argument: Output filename prefix\n\nThis creates:\n- `angular_filters_output.mat` - MATLAB filter bank\n- `angular_filters_output.h` - C header file\n\nThe function displays each filter visualization during generation (pauses between filters).\n\n**Sources:** [FExtraction/angular_filter_bank.m:21-67]()\n\n### Database File Requirements\n\nThe `db.mat` file must be created externally through the feature extraction pipeline (see [Feature Extraction Pipeline](#3.1)). The file should contain:\n\n- Variable name: `ff`\n- Type: Cell array\n- Each cell: Numeric matrix with columns representing minutiae attributes\n- Organization: Groups of 8 samples per fingerprint identity\n\nThe matching system does not provide functionality to create or modify the database file; it is read-only during matching operations.\n\n**Sources:** [Copy_of_match.m:18-26]()"])</script><script>self.__next_f.push([1,"1a:T4304,"])</script><script>self.__next_f.push([1,"# AES Encryption System\n\n\u003cdetails\u003e\n\u003csummary\u003eRelevant source files\u003c/summary\u003e\n\nThe following files were used as context for generating this wiki page:\n\n- [AES_update/AddRoundKey.m](AES_update/AddRoundKey.m)\n- [AES_update/Cipher.m](AES_update/Cipher.m)\n- [AES_update/InvCipher.m](AES_update/InvCipher.m)\n- [AES_update/KeyExpansion.m](AES_update/KeyExpansion.m)\n\n\u003c/details\u003e\n\n\n\n## Purpose and Scope\n\nThis document provides a comprehensive overview of the **Advanced Encryption Standard (AES)** implementation located in the `AES_update/` directory. The system provides encryption and decryption capabilities supporting 128-bit, 192-bit, and 256-bit key sizes as specified in FIPS-197.\n\nThis implementation is a standalone subsystem within the repository and is currently independent of the fingerprint processing pipeline. For information about how this encryption system could potentially integrate with fingerprint data, see the overall system architecture in [Overview](#1).\n\nThe AES system consists of 11 function files organized into encryption, decryption, and supporting utility operations. This page covers the system-level architecture and data flow. For detailed explanations of individual transformations, see:\n- [Key Expansion](#2.1) - Round key generation algorithm\n- [Encryption Process](#2.2) - Forward cipher implementation\n- [Decryption Process](#2.3) - Inverse cipher implementation\n- [Galois Field Arithmetic](#2.4) - GF(2^8) multiplication operations\n\n---\n\n## System Architecture\n\nThe AES implementation follows a modular design with separate functions for each transformation step. The two main entry points are `Cipher.m` for encryption and `InvCipher.m` for decryption, both of which orchestrate calls to lower-level transformation functions.\n\n```mermaid\ngraph TB\n    subgraph Input[\"Input Layer\"]\n        KEY[\"Encryption/Decryption Key\u003cbr/\u003e(128/192/256-bit hex)\"]\n        PLAINTEXT[\"Plaintext\u003cbr/\u003e(128-bit hex)\"]\n        CIPHERTEXT[\"Ciphertext\u003cbr/\u003e(128-bit hex)\"]\n    end\n    \n    subgraph KeySched[\"Key Schedule Layer\"]\n        KEYEXP[\"KeyExpansion.m\u003cbr/\u003eGenerates round keys\"]\n        ROUNDKEYS[\"Round Keys\u003cbr/\u003e(w matrix)\"]\n    end\n    \n    subgraph EncPath[\"Encryption Path\"]\n        CIPHER[\"Cipher.m\u003cbr/\u003eMain encryption function\"]\n        \n        subgraph EncOps[\"Encryption Round Operations\"]\n            SUBBYTES[\"SubBytes.m\u003cbr/\u003eS-box substitution\"]\n            SHIFTROWS[\"ShiftRows.m\u003cbr/\u003eRow permutation\"]\n            MIXCOLS[\"MixColumns.m\u003cbr/\u003eColumn mixing\"]\n            ADDKEY1[\"AddRoundKey.m\u003cbr/\u003eXOR with round key\"]\n        end\n    end\n    \n    subgraph DecPath[\"Decryption Path\"]\n        INVCIPHER[\"InvCipher.m\u003cbr/\u003eMain decryption function\"]\n        \n        subgraph DecOps[\"Decryption Round Operations\"]\n            INVSUBBYTES[\"InvSubBytes.m\u003cbr/\u003eInverse S-box\"]\n            INVSHIFTROWS[\"InvShiftRows.m\u003cbr/\u003eInverse row shift\"]\n            INVMIXCOLS[\"InvMixColumns.m\u003cbr/\u003eInverse column mix\"]\n            ADDKEY2[\"AddRoundKey.m\u003cbr/\u003eXOR with round key\"]\n        end\n    end\n    \n    subgraph Utils[\"Utility Layer\"]\n        XTIME[\"xtime.m\u003cbr/\u003eGF(2^8) multiplication\"]\n    end\n    \n    subgraph Output[\"Output Layer\"]\n        ENCRYPTED[\"Encrypted Output\u003cbr/\u003e(128-bit hex)\"]\n        DECRYPTED[\"Decrypted Output\u003cbr/\u003e(128-bit hex)\"]\n    end\n    \n    KEY --\u003e KEYEXP\n    KEYEXP --\u003e ROUNDKEYS\n    \n    PLAINTEXT --\u003e CIPHER\n    ROUNDKEYS --\u003e CIPHER\n    CIPHER --\u003e SUBBYTES\n    SUBBYTES --\u003e SHIFTROWS\n    SHIFTROWS --\u003e MIXCOLS\n    MIXCOLS --\u003e ADDKEY1\n    CIPHER --\u003e ENCRYPTED\n    \n    CIPHERTEXT --\u003e INVCIPHER\n    ROUNDKEYS --\u003e INVCIPHER\n    INVCIPHER --\u003e ADDKEY2\n    ADDKEY2 --\u003e INVSHIFTROWS\n    INVSHIFTROWS --\u003e INVSUBBYTES\n    INVSUBBYTES --\u003e INVMIXCOLS\n    INVCIPHER --\u003e DECRYPTED\n    \n    XTIME -.-\u003e MIXCOLS\n    XTIME -.-\u003e INVMIXCOLS\n    XTIME -.-\u003e KEYEXP\n```\n\n**Sources:** [AES_update/Cipher.m:1-28](), [AES_update/InvCipher.m:1-28](), [AES_update/KeyExpansion.m:1-20](), [AES_update/AddRoundKey.m:1-5]()\n\n---\n\n## Component Overview\n\nThe AES system is organized into three functional layers:\n\n### Main Cipher Functions\n\n| Function | Location | Purpose | Input | Output |\n|----------|----------|---------|-------|--------|\n| `Cipher` | `AES_update/Cipher.m` | AES encryption | `key` (hex string), `In` (128-bit hex) | Encrypted 128-bit hex string |\n| `InvCipher` | `AES_update/InvCipher.m` | AES decryption | `key` (hex string), `In` (128-bit hex) | Decrypted 128-bit hex string |\n| `KeyExpansion` | `AES_update/KeyExpansion.m` | Generate round keys | `key` (hex string), `Nk` (key words) | Round key matrix `w` |\n\n### Forward Transformation Functions\n\n| Function | Location | Operation | Used In |\n|----------|----------|-----------|---------|\n| `SubBytes` | `AES_update/SubBytes.m` | Non-linear byte substitution using S-box | `Cipher`, `KeyExpansion` |\n| `ShiftRows` | `AES_update/ShiftRows.m` | Cyclically shift state rows | `Cipher` |\n| `MixColumns` | `AES_update/MixColumns.m` | Linear column mixing in GF(2^8) | `Cipher` |\n| `AddRoundKey` | `AES_update/AddRoundKey.m` | XOR state with round key | `Cipher`, `InvCipher` |\n\n### Inverse Transformation Functions\n\n| Function | Location | Operation | Used In |\n|----------|----------|-----------|---------|\n| `InvSubBytes` | `AES_update/InvSubBytes.m` | Inverse S-box substitution | `InvCipher` |\n| `InvShiftRows` | `AES_update/InvShiftRows.m` | Inverse row shifting | `InvCipher` |\n| `InvMixColumns` | `AES_update/InvMixColumns.m` | Inverse column mixing | `InvCipher` |\n\n### Utility Functions\n\n| Function | Location | Purpose |\n|----------|----------|---------|\n| `xtime` | `AES_update/xtime.m` | Galois field GF(2^8) multiplication by 2 |\n\n**Sources:** Directory structure from `AES_update/`\n\n---\n\n## Supported Key Sizes\n\nThe implementation supports all three AES key sizes as defined in FIPS-197:\n\n| Key Size | Nk (32-bit words) | Nr (Rounds) | Hex String Length | Use Case |\n|----------|-------------------|-------------|-------------------|----------|\n| AES-128 | 4 | 10 | 32 characters | Standard security, faster |\n| AES-192 | 6 | 12 | 48 characters | Enhanced security |\n| AES-256 | 8 | 14 | 64 characters | Maximum security, slower |\n\nThe key size is automatically determined from the input key length: `Nk = length(key)/8` [AES_update/Cipher.m:11](), [AES_update/InvCipher.m:11](). The number of rounds is calculated as `Nk + 6`, resulting in the standard 10, 12, or 14 rounds for the three key sizes.\n\n**Sources:** [AES_update/Cipher.m:11-16](), [AES_update/InvCipher.m:11-16]()\n\n---\n\n## Encryption Data Flow\n\nThe encryption process implemented in `Cipher.m` follows this sequence:\n\n```mermaid\ngraph TD\n    START[\"Input: key, In\u003cbr/\u003e(hex strings)\"]\n    \n    CONVERT[\"hex2dec conversion\u003cbr/\u003e[Cipher.m:12]\"]\n    \n    EXPAND[\"KeyExpansion(key, Nk)\u003cbr/\u003e[Cipher.m:13]\"]\n    \n    RESHAPE[\"Reshape to 4x4 state\u003cbr/\u003e[Cipher.m:14]\"]\n    \n    INITIAL[\"Initial AddRoundKey\u003cbr/\u003e[Cipher.m:15]\"]\n    \n    ROUNDSTART{\"Round k=2 to Nk+6\"}\n    \n    SB[\"SubBytes(state)\u003cbr/\u003e[Cipher.m:17]\"]\n    SR[\"ShiftRows(state)\u003cbr/\u003e[Cipher.m:18]\"]\n    MC[\"MixColumns(state)\u003cbr/\u003e[Cipher.m:19]\"]\n    ARK[\"AddRoundKey(state, w)\u003cbr/\u003e[Cipher.m:20]\"]\n    \n    ROUNDEND{\"More rounds?\"}\n    \n    FINALSB[\"Final SubBytes\u003cbr/\u003e[Cipher.m:22]\"]\n    FINALSR[\"Final ShiftRows\u003cbr/\u003e[Cipher.m:23]\"]\n    FINALARK[\"Final AddRoundKey\u003cbr/\u003e[Cipher.m:24]\"]\n    \n    FORMATOUT[\"Convert to hex output\u003cbr/\u003e[Cipher.m:25-27]\"]\n    \n    END[\"Output: encrypted hex\"]\n    \n    START --\u003e CONVERT\n    CONVERT --\u003e EXPAND\n    EXPAND --\u003e RESHAPE\n    RESHAPE --\u003e INITIAL\n    INITIAL --\u003e ROUNDSTART\n    \n    ROUNDSTART --\u003e|\"Yes\"| SB\n    SB --\u003e SR\n    SR --\u003e MC\n    MC --\u003e ARK\n    ARK --\u003e ROUNDEND\n    \n    ROUNDEND --\u003e|\"Yes\"| ROUNDSTART\n    ROUNDEND --\u003e|\"No\"| FINALSB\n    \n    FINALSB --\u003e FINALSR\n    FINALSR --\u003e FINALARK\n    FINALARK --\u003e FORMATOUT\n    FORMATOUT --\u003e END\n```\n\n### Key Processing Steps\n\n1. **Input Conversion** [AES_update/Cipher.m:11-14](): Convert hexadecimal key and plaintext to decimal byte arrays, reshape into 4×4 state matrix\n2. **Key Expansion** [AES_update/Cipher.m:13](): Generate all round keys using `KeyExpansion` (see [Key Expansion](#2.1))\n3. **Initial Round** [AES_update/Cipher.m:15](): Apply `AddRoundKey` with first round key (whitening)\n4. **Main Rounds** [AES_update/Cipher.m:16-21](): For rounds 2 through `Nk+6`, apply in sequence:\n   - `SubBytes` - Non-linear substitution (see [SubBytes Transformation](#2.2.1))\n   - `ShiftRows` - Row permutation (see [ShiftRows Transformation](#2.2.2))\n   - `MixColumns` - Column diffusion (see [MixColumns Transformation](#2.2.3))\n   - `AddRoundKey` - XOR with round key (see [AddRoundKey Transformation](#2.2.4))\n5. **Final Round** [AES_update/Cipher.m:22-24](): Apply `SubBytes`, `ShiftRows`, and `AddRoundKey` (no `MixColumns`)\n6. **Output Formatting** [AES_update/Cipher.m:25-27](): Convert state to hexadecimal string\n\n**Sources:** [AES_update/Cipher.m:1-28]()\n\n---\n\n## Decryption Data Flow\n\nThe decryption process implemented in `InvCipher.m` reverses the encryption operations:\n\n```mermaid\ngraph TD\n    START[\"Input: key, In\u003cbr/\u003e(ciphertext hex)\"]\n    \n    CONVERT[\"hex2dec conversion\u003cbr/\u003e[InvCipher.m:12]\"]\n    \n    EXPAND[\"KeyExpansion(key, Nk)\u003cbr/\u003e[InvCipher.m:13]\"]\n    \n    RESHAPE[\"Reshape to 4x4 state\u003cbr/\u003e[InvCipher.m:14]\"]\n    \n    INITIAL[\"Initial AddRoundKey\u003cbr/\u003e[InvCipher.m:15]\"]\n    \n    ROUNDSTART{\"Round k=Nk+6 down to 2\"}\n    \n    ISR[\"InvShiftRows(state)\u003cbr/\u003e[InvCipher.m:17]\"]\n    ISB[\"InvSubBytes(state)\u003cbr/\u003e[InvCipher.m:18]\"]\n    ARK[\"AddRoundKey(state, w)\u003cbr/\u003e[InvCipher.m:19]\"]\n    IMC[\"InvMixColumns(state)\u003cbr/\u003e[InvCipher.m:20]\"]\n    \n    ROUNDEND{\"More rounds?\"}\n    \n    FINALISR[\"Final InvShiftRows\u003cbr/\u003e[InvCipher.m:22]\"]\n    FINALISB[\"Final InvSubBytes\u003cbr/\u003e[InvCipher.m:23]\"]\n    FINALARK[\"Final AddRoundKey\u003cbr/\u003e[InvCipher.m:24]\"]\n    \n    FORMATOUT[\"Convert to hex output\u003cbr/\u003e[InvCipher.m:25-27]\"]\n    \n    END[\"Output: decrypted hex\"]\n    \n    START --\u003e CONVERT\n    CONVERT --\u003e EXPAND\n    EXPAND --\u003e RESHAPE\n    RESHAPE --\u003e INITIAL\n    INITIAL --\u003e ROUNDSTART\n    \n    ROUNDSTART --\u003e|\"Yes\"| ISR\n    ISR --\u003e ISB\n    ISB --\u003e ARK\n    ARK --\u003e IMC\n    IMC --\u003e ROUNDEND\n    \n    ROUNDEND --\u003e|\"Yes\"| ROUNDSTART\n    ROUNDEND --\u003e|\"No\"| FINALISR\n    \n    FINALISR --\u003e FINALISB\n    FINALISB --\u003e FINALARK\n    FINALARK --\u003e FORMATOUT\n    FORMATOUT --\u003e END\n```\n\n### Key Processing Steps\n\n1. **Input Conversion** [AES_update/InvCipher.m:11-14](): Convert hexadecimal key and ciphertext to decimal, reshape into state matrix\n2. **Key Expansion** [AES_update/InvCipher.m:13](): Generate same round keys as encryption\n3. **Initial Round** [AES_update/InvCipher.m:15](): Apply `AddRoundKey` with **last** round key\n4. **Main Rounds** [AES_update/InvCipher.m:16-21](): For rounds `Nk+6` down to 2, apply in **reverse order**:\n   - `InvShiftRows` - Inverse row permutation (see [InvShiftRows Transformation](#2.3.2))\n   - `InvSubBytes` - Inverse S-box (see [InvSubBytes Transformation](#2.3.1))\n   - `AddRoundKey` - XOR with round key (same operation as encryption)\n   - `InvMixColumns` - Inverse column diffusion (see [InvMixColumns Transformation](#2.3.3))\n5. **Final Round** [AES_update/InvCipher.m:22-24](): Apply `InvShiftRows`, `InvSubBytes`, and `AddRoundKey` (no `InvMixColumns`)\n6. **Output Formatting** [AES_update/InvCipher.m:25-27](): Convert state to hexadecimal string\n\n**Sources:** [AES_update/InvCipher.m:1-28]()\n\n---\n\n## State Matrix Representation\n\nBoth `Cipher` and `InvCipher` operate on a 4×4 **state matrix** that holds 16 bytes (128 bits):\n\n```mermaid\ngraph LR\n    subgraph Input[\"128-bit Input Block\"]\n        HEX[\"32 hex characters\u003cbr/\u003e(e.g., '0123456789abcdef...')\"]\n    end\n    \n    subgraph Conversion[\"hex2dec + reshape\"]\n        BYTES[\"16 decimal bytes\u003cbr/\u003e[0-255]\"]\n    end\n    \n    subgraph State[\"4x4 State Matrix\"]\n        COL0[\"Column 0\u003cbr/\u003ebytes 0,1,2,3\"]\n        COL1[\"Column 1\u003cbr/\u003ebytes 4,5,6,7\"]\n        COL2[\"Column 2\u003cbr/\u003ebytes 8,9,10,11\"]\n        COL3[\"Column 3\u003cbr/\u003ebytes 12,13,14,15\"]\n    end\n    \n    HEX --\u003e BYTES\n    BYTES --\u003e COL0\n    BYTES --\u003e COL1\n    BYTES --\u003e COL2\n    BYTES --\u003e COL3\n```\n\nThe conversion from hex string to state matrix happens in [AES_update/Cipher.m:12-14]():\n```matlab\nIn=hex2dec(reshape(In,2,[])');  % Convert hex pairs to decimal bytes\nstate=reshape(In,4,[]);          % Reshape to 4xN matrix (4x4 for AES)\n```\n\n**Sources:** [AES_update/Cipher.m:12-14](), [AES_update/InvCipher.m:12-14]()\n\n---\n\n## AddRoundKey Operation\n\nThe `AddRoundKey` transformation is used in both encryption and decryption and is its own inverse. It performs a simple XOR between the state and a portion of the round key matrix:\n\n```mermaid\ngraph LR\n    subgraph Inputs[\"Inputs\"]\n        STATE[\"state matrix\u003cbr/\u003e(4x4 bytes)\"]\n        WKEYS[\"w matrix slice\u003cbr/\u003e(4x4 bytes)\"]\n    end\n    \n    subgraph Operation[\"XOR Operation\"]\n        XOR[\"bitwise XOR\u003cbr/\u003efor each column\"]\n    end\n    \n    subgraph Output[\"Output\"]\n        NEWSTATE[\"updated state\u003cbr/\u003e(4x4 bytes)\"]\n    end\n    \n    STATE --\u003e XOR\n    WKEYS --\u003e XOR\n    XOR --\u003e NEWSTATE\n```\n\nImplementation [AES_update/AddRoundKey.m:1-5]():\n```matlab\nfunction state = AddRoundKey(state,w)\nfor k=1:4\n    state(:,k)=bitxor(state(:,k),w(:,k));\nend\nend\n```\n\nThe function iterates through each of the 4 columns, XORing the state column with the corresponding column from the round key matrix `w`. This is the only operation in AES that directly incorporates the key material into the state.\n\n**Sources:** [AES_update/AddRoundKey.m:1-5]()\n\n---\n\n## Round Structure Comparison\n\nThe following table compares the round structure between encryption and decryption:\n\n| Round Type | Encryption (`Cipher`) | Decryption (`InvCipher`) |\n|------------|----------------------|--------------------------|\n| **Initial** | `AddRoundKey(w[:, 1:4])` | `AddRoundKey(w[:, end])` |\n| **Main Rounds** | `SubBytes` → `ShiftRows` → `MixColumns` → `AddRoundKey` | `InvShiftRows` → `InvSubBytes` → `AddRoundKey` → `InvMixColumns` |\n| **Round Count** | 2 to `Nk+6` | `Nk+6` down to 2 |\n| **Final Round** | `SubBytes` → `ShiftRows` → `AddRoundKey` (no `MixColumns`) | `InvShiftRows` → `InvSubBytes` → `AddRoundKey` (no `InvMixColumns`) |\n| **Key Usage** | Forward order (w[:, 1] to w[:, end]) | Reverse order (w[:, end] to w[:, 1]) |\n\nThe key observation is that decryption uses the **same round keys** but in **reverse order**, and applies the **inverse transformations** in **reverse sequence**.\n\n**Sources:** [AES_update/Cipher.m:15-24](), [AES_update/InvCipher.m:15-24]()\n\n---\n\n## Function Signatures and Usage\n\n### Encryption\n\n```matlab\nOut = Cipher(key, In)\n```\n\n**Parameters:**\n- `key`: Hexadecimal string (32, 48, or 64 characters for AES-128/192/256)\n- `In`: 128-bit plaintext as hexadecimal string (32 characters)\n\n**Returns:**\n- `Out`: 128-bit ciphertext as hexadecimal string (32 characters)\n\n**Example:**\n```matlab\nkey = '000102030405060708090a0b0c0d0e0f';  % AES-128 key\nplaintext = '00112233445566778899aabbccddeeff';\nciphertext = Cipher(key, plaintext);\n```\n\n### Decryption\n\n```matlab\nOut = InvCipher(key, In)\n```\n\n**Parameters:**\n- `key`: Same hexadecimal key used for encryption\n- `In`: 128-bit ciphertext as hexadecimal string (32 characters)\n\n**Returns:**\n- `Out`: 128-bit plaintext as hexadecimal string (32 characters)\n\n**Example:**\n```matlab\nkey = '000102030405060708090a0b0c0d0e0f';\nplaintext_recovered = InvCipher(key, ciphertext);\n```\n\n**Sources:** [AES_update/Cipher.m:1-6](), [AES_update/InvCipher.m:1-6]()\n\n---\n\n## Implementation Notes\n\n### Data Format Requirements\n\nThe implementation expects and returns data in specific formats:\n\n1. **Keys**: Hexadecimal strings with lengths:\n   - 32 characters (128-bit / 16 bytes) for AES-128\n   - 48 characters (192-bit / 24 bytes) for AES-192\n   - 64 characters (256-bit / 32 bytes) for AES-256\n\n2. **Input/Output**: 128-bit hexadecimal strings (32 characters) representing the plaintext or ciphertext block\n\n3. **Case Insensitivity**: Output is lowercase hexadecimal [AES_update/Cipher.m:26]()\n\n### No Input Validation\n\nAs noted in the code comments [AES_update/Cipher.m:4-6](), the implementation does not validate input lengths. Incorrect key or message lengths will cause MATLAB runtime errors rather than graceful error messages.\n\n### Author and Version\n\n- **Author**: David Hill\n- **Version**: 1.0.4\n- **Date**: 1-25-2021\n\n**Sources:** [AES_update/Cipher.m:7-9](), [AES_update/InvCipher.m:7-9]()\n\n---\n\n## Integration with Fingerprint System\n\nThe AES encryption system is currently **standalone** within the repository. While located in the same codebase as the fingerprint processing pipeline, there are no direct function calls or data exchanges between the two subsystems.\n\nPotential integration points for securing biometric data include:\n\n1. **Database Encryption**: Encrypting the minutiae database (`db.mat`) before storage\n2. **Result Protection**: Encrypting match scores or matching results\n3. **Template Protection**: Encrypting extracted fingerprint templates during transmission\n\nThese integration points are not currently implemented but represent future enhancement opportunities. See [Overview](#1) for architectural context.\n\n**Sources:** Repository structure analysis"])</script><script>self.__next_f.push([1,"1b:T2ac6,"])</script><script>self.__next_f.push([1,"# Key Expansion\n\n\u003cdetails\u003e\n\u003csummary\u003eRelevant source files\u003c/summary\u003e\n\nThe following files were used as context for generating this wiki page:\n\n- [AES_update/KeyExpansion.m](AES_update/KeyExpansion.m)\n- [AES_update/SubBytes.m](AES_update/SubBytes.m)\n- [AES_update/xtime.m](AES_update/xtime.m)\n\n\u003c/details\u003e\n\n\n\n## Purpose and Scope\n\nThis document explains the AES key expansion algorithm implemented in [AES_update/KeyExpansion.m](). The key expansion process transforms an original cipher key (128, 192, or 256 bits) into a schedule of round keys used during encryption and decryption. Each round of AES requires a separate round key, and this function generates all necessary round keys from the initial key.\n\nFor information about how these round keys are used during encryption, see [Encryption Process](#2.2). For details on the inverse cipher that also uses these expanded keys, see [Decryption Process](#2.3). For background on the Galois field multiplication used in round constant generation, see [Galois Field Arithmetic](#2.4).\n\n---\n\n## Overview\n\nThe `KeyExpansion` function generates 44 words (176 bytes) for AES-128, 52 words (208 bytes) for AES-192, or 60 words (240 bytes) for AES-256. The first `Nk` words contain the original key, and subsequent words are derived through iterative transformations involving rotation, substitution, and XOR operations with round constants.\n\n**Sources:** [AES_update/KeyExpansion.m:1-20]()\n\n---\n\n## Function Signature and Parameters\n\n```matlab\nfunction w = KeyExpansion(key, Nk)\n```\n\n| Parameter | Type | Description |\n|-----------|------|-------------|\n| `key` | Hex string | The original cipher key represented as a hexadecimal string |\n| `Nk` | Integer | Number of 32-bit words in the key: 4 (AES-128), 6 (AES-192), or 8 (AES-256) |\n| **Returns** | 4×N array | Expanded key schedule where N = 4×(Nk+7) columns |\n\n**Supported Key Sizes:**\n\n| AES Variant | Nk Value | Key Size (bits) | Output Words | Rounds |\n|-------------|----------|-----------------|--------------|--------|\n| AES-128 | 4 | 128 | 44 | 10 |\n| AES-192 | 6 | 192 | 52 | 12 |\n| AES-256 | 8 | 256 | 60 | 14 |\n\n**Sources:** [AES_update/KeyExpansion.m:1-3]()\n\n---\n\n## Key Expansion Algorithm Flow\n\n```mermaid\ngraph TD\n    START[\"KeyExpansion(key, Nk)\"]\n    CONVERT[\"Convert hex key to decimal\u003cbr/\u003ehex2dec(reshape(key,2,[]))\"]\n    RESHAPE[\"Reshape into 4×Nk array\u003cbr/\u003ew = reshape(key,4,[])\"]\n    LOOP{\"For i = Nk to 4*(Nk+7)-1\"}\n    GETWORD[\"temp = w(:,i)\"]\n    CHECK1{\"i mod Nk == 0?\"}\n    ROTWORD[\"RotWord: temp = circshift(temp,-1)\"]\n    SUBBYTES[\"SubBytes(temp)\"]\n    RCON[\"Calculate Rcon[i/Nk]\u003cbr/\u003eusing xtime(2,n)\"]\n    XORRCON[\"temp = bitxor(temp, [Rcon,0,0,0])\"]\n    CHECK2{\"Nk\u003e6 AND\u003cbr/\u003ei mod 8 == 4?\"}\n    SUBBYTES2[\"SubBytes(temp)\"]\n    XOR[\"w(:,i+1) = bitxor(w(:,i-Nk+1), temp)\"]\n    LOOPEND{\"More words?\"}\n    END[\"Return w\"]\n    \n    START --\u003e CONVERT\n    CONVERT --\u003e RESHAPE\n    RESHAPE --\u003e LOOP\n    LOOP --\u003e|\"Yes\"| GETWORD\n    GETWORD --\u003e CHECK1\n    CHECK1 --\u003e|\"Yes (every Nk words)\"| ROTWORD\n    CHECK1 --\u003e|\"No\"| CHECK2\n    ROTWORD --\u003e SUBBYTES\n    SUBBYTES --\u003e RCON\n    RCON --\u003e XORRCON\n    XORRCON --\u003e CHECK2\n    CHECK2 --\u003e|\"Yes (AES-256 only)\"| SUBBYTES2\n    CHECK2 --\u003e|\"No\"| XOR\n    SUBBYTES2 --\u003e XOR\n    XOR --\u003e LOOPEND\n    LOOPEND --\u003e|\"Yes\"| LOOP\n    LOOPEND --\u003e|\"No\"| END\n    LOOP --\u003e|\"No (initialization complete)\"| END\n```\n\n**Diagram: Key Expansion Algorithm Control Flow**\n\n**Sources:** [AES_update/KeyExpansion.m:2-19]()\n\n---\n\n## Input Processing\n\nThe function begins by converting the hexadecimal key string into a numerical array:\n\n1. **Hex to Decimal Conversion** ([AES_update/KeyExpansion.m:2]()): `hex2dec(reshape(key,2,[]))'` converts pairs of hex characters into decimal byte values.\n\n2. **Array Reshaping** ([AES_update/KeyExpansion.m:3]()): `reshape(key,4,[])` organizes the bytes into a 4-row matrix where each column represents a 32-bit word. For AES-128, this produces a 4×4 matrix; for AES-192, a 4×6 matrix; for AES-256, a 4×8 matrix.\n\n**Sources:** [AES_update/KeyExpansion.m:2-3]()\n\n---\n\n## Iterative Word Generation\n\nThe expansion loop ([AES_update/KeyExpansion.m:4-19]()) generates words `w[Nk]` through `w[4*(Nk+7)-1]`:\n\n```mermaid\ngraph LR\n    subgraph \"Initial Key Words\"\n        W0[\"w[0]\"]\n        W1[\"w[1]\"]\n        W2[\"w[2]\"]\n        W3[\"w[3]\"]\n        WDOTS1[\"...\"]\n        WNK[\"w[Nk-1]\"]\n    end\n    \n    subgraph \"Generated Words\"\n        WNK1[\"w[Nk]\"]\n        WNK2[\"w[Nk+1]\"]\n        WDOTS2[\"...\"]\n        WLAST[\"w[4*(Nk+7)-1]\"]\n    end\n    \n    W0 --\u003e WNK1\n    W1 --\u003e WNK2\n    WNK --\u003e WLAST\n    \n    WNK1 -.-\u003e|\"Used to generate\"| WNK\n    WNK2 -.-\u003e|\"XOR chain\"| WDOTS2\n```\n\n**Diagram: Word Generation Dependencies**\n\nEach new word `w[i]` is derived from:\n- `w[i-Nk]` (word from `Nk` positions earlier)\n- `w[i-1]` (previous word, after optional transformations)\n\n**Sources:** [AES_update/KeyExpansion.m:4-19]()\n\n---\n\n## Core Transformations\n\n### RotWord (Cyclic Byte Rotation)\n\nWhen `i mod Nk == 0` ([AES_update/KeyExpansion.m:6]()), the previous word undergoes rotation:\n\n```matlab\ntemp = circshift(temp, -1)\n```\n\nThis performs a cyclic left shift by one byte position:\n- `[a0, a1, a2, a3]` becomes `[a1, a2, a3, a0]`\n\n**Sources:** [AES_update/KeyExpansion.m:7]()\n\n---\n\n### SubBytes Substitution\n\nThe `SubBytes` function ([AES_update/SubBytes.m:1-20]()) is applied in two contexts:\n\n1. **Primary Path** ([AES_update/KeyExpansion.m:7]()): After RotWord when `i mod Nk == 0`\n2. **AES-256 Path** ([AES_update/KeyExpansion.m:16]()): When `Nk \u003e 6` and `i mod 8 == 4`\n\nThe substitution uses the AES S-box lookup table to replace each byte with a non-linear transformation. For details on the S-box structure, see [SubBytes Transformation](#2.2.1).\n\n**Sources:** [AES_update/KeyExpansion.m:7,16](), [AES_update/SubBytes.m:1-20]()\n\n---\n\n### Round Constant (Rcon) Generation\n\n```mermaid\ngraph TD\n    INIT[\"n = 1\u003cbr/\u003em = 0\"]\n    LOOP{\"m \u003c i/Nk - 1?\"}\n    XTIME[\"n = xtime(2, n)\u003cbr/\u003e(Galois field multiplication)\"]\n    INCR[\"m = m + 1\"]\n    APPLY[\"temp = bitxor(temp, [n,0,0,0])\"]\n    \n    INIT --\u003e LOOP\n    LOOP --\u003e|\"Yes\"| XTIME\n    XTIME --\u003e INCR\n    INCR --\u003e LOOP\n    LOOP --\u003e|\"No\"| APPLY\n```\n\n**Diagram: Round Constant Computation Using xtime**\n\nThe round constant `Rcon[i/Nk]` is computed through repeated Galois field multiplication ([AES_update/KeyExpansion.m:8-14]()):\n\n| Round | i/Nk | Rcon Value (hex) | Computation |\n|-------|------|------------------|-------------|\n| 1 | 1 | 01 | 2^0 |\n| 2 | 2 | 02 | 2^1 |\n| 3 | 3 | 04 | 2^2 |\n| 4 | 4 | 08 | 2^3 |\n| 5 | 5 | 10 | 2^4 |\n| 6 | 6 | 20 | 2^5 |\n| 7 | 7 | 40 | 2^6 |\n| 8 | 8 | 80 | 2^7 |\n| 9 | 9 | 1B | 2^8 mod (x^8+x^4+x^3+x+1) |\n| 10 | 10 | 36 | 2^9 mod (x^8+x^4+x^3+x+1) |\n\nThe `xtime` function ([AES_update/xtime.m:1-18]()) performs multiplication in GF(2^8) using the irreducible polynomial `x^8 + x^4 + x^3 + x + 1` (represented as 0x11B). For detailed explanation of Galois field arithmetic, see [Galois Field Arithmetic](#2.4).\n\nThe round constant is applied only to the first byte: `bitxor(temp, [n,0,0,0]')`\n\n**Sources:** [AES_update/KeyExpansion.m:8-14](), [AES_update/xtime.m:1-18]()\n\n---\n\n## AES-256 Special Case\n\nFor AES-256 (`Nk = 8`), an additional `SubBytes` transformation is applied ([AES_update/KeyExpansion.m:15-16]()):\n\n```matlab\nelseif Nk\u003e6 \u0026\u0026 mod(i,8)==4\n    temp=SubBytes(temp);\nend\n```\n\nThis occurs every 8 words at positions where `i mod 8 == 4`, providing additional diffusion for the longer 256-bit keys. This extra substitution is unique to AES-256 and does not occur in AES-128 or AES-192.\n\n**Sources:** [AES_update/KeyExpansion.m:15-16]()\n\n---\n\n## Final XOR Operation\n\nAll word generation paths converge to the final XOR operation ([AES_update/KeyExpansion.m:18]()):\n\n```matlab\nw(:,i+1) = bitxor(w(:,i-Nk+1), temp)\n```\n\nThis combines:\n- `w[i-Nk+1]`: A word from `Nk` positions earlier in the schedule\n- `temp`: The transformed version of `w[i]` (after RotWord, SubBytes, Rcon, or just passed through)\n\n**Sources:** [AES_update/KeyExpansion.m:18]()\n\n---\n\n## Code-to-Algorithm Mapping\n\n```mermaid\ngraph TB\n    subgraph \"KeyExpansion.m Implementation\"\n        FUNC[\"KeyExpansion(key, Nk)\"]\n        LINE2[\"Line 2: hex2dec + reshape\"]\n        LINE3[\"Line 3: w = reshape(key,4,[])\"]\n        LINE4[\"Line 4-19: for loop\"]\n        LINE5[\"Line 5: temp = w(:,i)\"]\n        LINE6[\"Line 6: if mod(i,Nk)==0\"]\n        LINE7[\"Line 7: SubBytes(circshift)\"]\n        LINE8_14[\"Lines 8-14: Rcon calculation\"]\n        LINE15[\"Line 15: elseif Nk\u003e6 \u0026\u0026 mod(i,8)==4\"]\n        LINE18[\"Line 18: bitxor(w(:,i-Nk+1),temp)\"]\n    end\n    \n    subgraph \"AES Standard Algorithm\"\n        PARSE[\"Key Parsing\"]\n        INIT[\"Initialize w[0..Nk-1]\"]\n        ITER[\"Iterate i = Nk to Nb*(Nr+1)-1\"]\n        ROT[\"RotWord\"]\n        SUB[\"SubWord (SubBytes)\"]\n        RCON[\"Rcon[i/Nk]\"]\n        XOR1[\"XOR with Rcon\"]\n        SUB256[\"Extra SubBytes (AES-256)\"]\n        XOR2[\"XOR with w[i-Nk]\"]\n    end\n    \n    subgraph \"External Dependencies\"\n        SUBBYTES_M[\"SubBytes.m\"]\n        XTIME_M[\"xtime.m\"]\n    end\n    \n    FUNC --\u003e LINE2\n    LINE2 --\u003e PARSE\n    LINE3 --\u003e INIT\n    LINE4 --\u003e ITER\n    LINE5 --\u003e ITER\n    LINE6 --\u003e ITER\n    LINE7 --\u003e ROT\n    LINE7 --\u003e SUB\n    LINE7 --\u003e SUBBYTES_M\n    LINE8_14 --\u003e RCON\n    LINE8_14 --\u003e XTIME_M\n    LINE8_14 --\u003e XOR1\n    LINE15 --\u003e SUB256\n    LINE15 --\u003e SUBBYTES_M\n    LINE18 --\u003e XOR2\n    \n    style FUNC fill:#f9f9f9\n    style SUBBYTES_M fill:#e8e8e8\n    style XTIME_M fill:#e8e8e8\n```\n\n**Diagram: Mapping Between Code Lines and AES Standard Operations**\n\n**Sources:** [AES_update/KeyExpansion.m:1-20](), [AES_update/SubBytes.m:1-20](), [AES_update/xtime.m:1-18]()\n\n---\n\n## Output Structure\n\nThe function returns a 4×N matrix where N depends on the key size:\n\n| Key Size | Nk | Output Dimensions | Total Bytes | Usage |\n|----------|----|-------------------|-------------|-------|\n| AES-128 | 4 | 4×44 | 176 | Initial key + 10 round keys |\n| AES-192 | 6 | 4×52 | 208 | Initial key + 12 round keys |\n| AES-256 | 8 | 4×60 | 240 | Initial key + 14 round keys |\n\nEach column represents a 32-bit word (4 bytes). The round keys are extracted as contiguous 16-byte (4-word) blocks:\n- Round 0 (initial): columns 0-3\n- Round 1: columns 4-7\n- Round 2: columns 8-11\n- ...\n- Round Nr: columns 4Nr to 4Nr+3\n\n**Sources:** [AES_update/KeyExpansion.m:1-20]()\n\n---\n\n## Integration with Encryption and Decryption\n\nThe expanded key schedule produced by `KeyExpansion` is consumed by:\n\n1. **Cipher.m** (encryption): Uses round keys in forward order during `AddRoundKey` operations. See [Encryption Process](#2.2) and [AddRoundKey Transformation](#2.2.4).\n\n2. **InvCipher.m** (decryption): Uses round keys in reverse order, with `InvMixColumns` applied to round keys 1 through Nr-1 in the Equivalent Inverse Cipher variant. See [Decryption Process](#2.3).\n\nBoth encryption and decryption rely on the same expanded key schedule, ensuring symmetric operation of the cipher.\n\n**Sources:** [AES_update/KeyExpansion.m:1-20]()"])</script><script>self.__next_f.push([1,"1c:T2344,"])</script><script>self.__next_f.push([1,"# Encryption Process\n\n\u003cdetails\u003e\n\u003csummary\u003eRelevant source files\u003c/summary\u003e\n\nThe following files were used as context for generating this wiki page:\n\n- [AES_update/AddRoundKey.m](AES_update/AddRoundKey.m)\n- [AES_update/Cipher.m](AES_update/Cipher.m)\n\n\u003c/details\u003e\n\n\n\n## Purpose and Scope\n\nThis document describes the forward cipher encryption process implemented in the AES system. It explains the structure of the `Cipher` function, the sequencing of transformation operations across multiple rounds, and how the input plaintext is converted to ciphertext. \n\nFor information about key expansion, see [Key Expansion](#2.1). For the reverse decryption process, see [Decryption Process](#2.3). For details on the individual transformation functions, see sections [SubBytes Transformation](#2.2.1), [ShiftRows Transformation](#2.2.2), [MixColumns Transformation](#2.2.3), and [AddRoundKey Transformation](#2.2.4).\n\n## Overview\n\nThe encryption process is implemented in the `Cipher` function, which accepts a hexadecimal encryption key and hexadecimal plaintext input, then produces a hexadecimal ciphertext output. The function supports three AES variants (AES-128, AES-192, and AES-256) by automatically determining the number of rounds based on key length.\n\n**Function Signature**: `Out = Cipher(key, In)`\n\n**Parameters**:\n- `key`: Hexadecimal string of length 32, 48, or 64 characters (128, 192, or 256 bits)\n- `In`: Hexadecimal string of length 32 characters (128-bit block)\n\n**Returns**:\n- `Out`: Hexadecimal string of length 32 characters (encrypted 128-bit block)\n\nSources: [AES_update/Cipher.m:1-28]()\n\n## Input Processing and Key Expansion\n\nThe encryption process begins by preprocessing the input data and generating the round keys:\n\n1. **Key Length Detection**: The function calculates `Nk` (number of 32-bit words in the key) by dividing the key string length by 8 [AES_update/Cipher.m:11]()\n2. **Input Conversion**: The hexadecimal input string is converted to decimal bytes using `hex2dec` [AES_update/Cipher.m:12]()\n3. **Key Expansion**: The `KeyExpansion` function generates all round keys from the original key [AES_update/Cipher.m:13]()\n4. **State Matrix Formation**: The input bytes are reshaped into a 4×4 state matrix [AES_update/Cipher.m:14]()\n\n```mermaid\ngraph LR\n    In[\"In\u003cbr/\u003e(hex string)\"] --\u003e hex2dec[\"hex2dec()\u003cbr/\u003eConvert to bytes\"]\n    key[\"key\u003cbr/\u003e(hex string)\"] --\u003e CalcNk[\"Nk = length(key)/8\u003cbr/\u003eDetermine key size\"]\n    CalcNk --\u003e KeyExp[\"KeyExpansion(key, Nk)\u003cbr/\u003eGenerate round keys\"]\n    hex2dec --\u003e reshape[\"reshape()\u003cbr/\u003eForm 4x4 state\"]\n    reshape --\u003e state[\"state matrix\u003cbr/\u003e(4x4 bytes)\"]\n    KeyExp --\u003e w[\"w\u003cbr/\u003e(round key array)\"]\n```\n\nSources: [AES_update/Cipher.m:11-14]()\n\n## Round Structure\n\nThe encryption process consists of three distinct phases: an initial round, main rounds, and a final round. The number of main rounds depends on the key size.\n\n### Round Count by Key Size\n\n| Key Size | Nk Value | Number of Main Rounds | Total Transformation Cycles |\n|----------|----------|------------------------|------------------------------|\n| 128-bit  | 4        | 10 (Nk+6 = 10)        | 1 initial + 9 main + 1 final = 11 |\n| 192-bit  | 6        | 12 (Nk+6 = 12)        | 1 initial + 11 main + 1 final = 13 |\n| 256-bit  | 8        | 14 (Nk+6 = 14)        | 1 initial + 13 main + 1 final = 15 |\n\nSources: [AES_update/Cipher.m:11](), [AES_update/Cipher.m:16]()\n\n### Encryption Round Sequence\n\n```mermaid\ngraph TD\n    Start[\"state = plaintext\"] --\u003e Initial[\"Initial Round:\u003cbr/\u003eAddRoundKey(state, w(:,1:4))\"]\n    \n    Initial --\u003e MainLoop[\"Main Rounds Loop\u003cbr/\u003ek=2 to (Nk+6)\"]\n    \n    MainLoop --\u003e SubBytes1[\"SubBytes(state)\"]\n    SubBytes1 --\u003e ShiftRows1[\"ShiftRows(state)\"]\n    ShiftRows1 --\u003e MixColumns1[\"MixColumns(state)\"]\n    MixColumns1 --\u003e AddRoundKey1[\"AddRoundKey(state, w(:,4*(k-1)+1:4*k))\"]\n    \n    AddRoundKey1 --\u003e Check{\"More\u003cbr/\u003erounds?\"}\n    Check --\u003e|Yes| SubBytes1\n    Check --\u003e|No| FinalRound\n    \n    FinalRound[\"Final Round\"] --\u003e SubBytes2[\"SubBytes(state)\"]\n    SubBytes2 --\u003e ShiftRows2[\"ShiftRows(state)\"]\n    ShiftRows2 --\u003e AddRoundKey2[\"AddRoundKey(state, w(:,4*(Nk+6)+1:4*(Nk+7)))\"]\n    \n    AddRoundKey2 --\u003e Output[\"state = ciphertext\"]\n```\n\nSources: [AES_update/Cipher.m:15-24]()\n\n## Transformation Sequence\n\n### Initial Round\n\nThe initial round performs only a single transformation:\n- **AddRoundKey**: XORs the state with the first round key (`w(:,1:4)`)\n\nThis operation is implemented at [AES_update/Cipher.m:15]().\n\nSources: [AES_update/Cipher.m:15]()\n\n### Main Rounds\n\nEach main round (iterations 2 through Nk+6) applies four transformations in sequence:\n\n1. **SubBytes**: Non-linear byte substitution using S-box [AES_update/Cipher.m:17]()\n2. **ShiftRows**: Cyclic shift of state rows [AES_update/Cipher.m:18]()\n3. **MixColumns**: Column-wise mixing in GF(2^8) [AES_update/Cipher.m:19]()\n4. **AddRoundKey**: XOR with round key [AES_update/Cipher.m:20]()\n\nThe round key for main round `k` is extracted from columns `4*(k-1)+1` to `4*k` of the expanded key array `w`.\n\nSources: [AES_update/Cipher.m:16-21]()\n\n### Final Round\n\nThe final round differs from main rounds by omitting the `MixColumns` transformation:\n\n1. **SubBytes**: Applied at [AES_update/Cipher.m:22]()\n2. **ShiftRows**: Applied at [AES_update/Cipher.m:23]()\n3. **AddRoundKey**: Uses the final round key `w(:,4*(Nk+6)+1:4*(Nk+7))` [AES_update/Cipher.m:24]()\n\nThe omission of `MixColumns` in the final round is specified by the AES standard (FIPS-197).\n\nSources: [AES_update/Cipher.m:22-24]()\n\n## Code Entity Mapping\n\n```mermaid\ngraph TB\n    subgraph \"Cipher.m Function Flow\"\n        CipherFunc[\"Cipher(key, In)\"]\n        \n        CipherFunc --\u003e Setup[\"Setup Phase\"]\n        Setup --\u003e NkCalc[\"Nk = length(key)/8\"]\n        Setup --\u003e HexConv[\"In_decimal = hex2dec(...)\"]\n        Setup --\u003e KeyExp[\"w = KeyExpansion(key, Nk)\"]\n        Setup --\u003e StateInit[\"state = reshape(In_decimal, 4, [])\"]\n        \n        StateInit --\u003e InitRound[\"state = AddRoundKey(state, w(:,1:4))\"]\n        \n        InitRound --\u003e ForLoop[\"for k=2:(Nk+6)\"]\n        \n        ForLoop --\u003e SubBytesCall[\"state = SubBytes(state)\"]\n        ForLoop --\u003e ShiftRowsCall[\"state = ShiftRows(state)\"]\n        ForLoop --\u003e MixColumnsCall[\"state = MixColumns(state)\"]\n        ForLoop --\u003e AddRoundKeyCall[\"state = AddRoundKey(state, w(:,cols))\"]\n        \n        AddRoundKeyCall --\u003e FinalSB[\"state = SubBytes(state)\"]\n        FinalSB --\u003e FinalSR[\"state = ShiftRows(state)\"]\n        FinalSR --\u003e FinalARK[\"state = AddRoundKey(state, w(:,final_cols))\"]\n        \n        FinalARK --\u003e OutputConv[\"Out = dec2hex(state(:))\"]\n    end\n    \n    subgraph \"Called Functions\"\n        KeyExpansionM[\"KeyExpansion.m\"]\n        AddRoundKeyM[\"AddRoundKey.m\"]\n        SubBytesM[\"SubBytes.m\"]\n        ShiftRowsM[\"ShiftRows.m\"]\n        MixColumnsM[\"MixColumns.m\"]\n    end\n    \n    KeyExp -.-\u003e KeyExpansionM\n    InitRound -.-\u003e AddRoundKeyM\n    AddRoundKeyCall -.-\u003e AddRoundKeyM\n    FinalARK -.-\u003e AddRoundKeyM\n    SubBytesCall -.-\u003e SubBytesM\n    FinalSB -.-\u003e SubBytesM\n    ShiftRowsCall -.-\u003e ShiftRowsM\n    FinalSR -.-\u003e ShiftRowsM\n    MixColumnsCall -.-\u003e MixColumnsM\n```\n\nSources: [AES_update/Cipher.m:1-28]()\n\n## Output Processing\n\nAfter the final round completes, the state matrix is converted back to hexadecimal format:\n\n1. **Vectorization**: The 4×4 state matrix is reshaped into a column vector using `state(:)` [AES_update/Cipher.m:25]()\n2. **Hex Conversion**: Decimal bytes are converted to lowercase hexadecimal using `dec2hex` [AES_update/Cipher.m:26]()\n3. **Formatting**: The output is transposed and reshaped into a row vector [AES_update/Cipher.m:27]()\n\nThe final output `Out` is a hexadecimal string with the same length as the input (32 characters for 128-bit blocks).\n\nSources: [AES_update/Cipher.m:25-27]()\n\n## AddRoundKey Implementation\n\nThe `AddRoundKey` transformation, which is used in the initial, main, and final rounds, is implemented as a simple XOR operation between the state and round key:\n\n```matlab\nfunction state = AddRoundKey(state,w)\nfor k=1:4\n    state(:,k)=bitxor(state(:,k),w(:,k));\nend\nend\n```\n\nThe function iterates through each of the four columns of the state matrix and performs a bitwise XOR with the corresponding column of the round key. This is the only transformation in AES that directly incorporates the encryption key into the state.\n\nSources: [AES_update/AddRoundKey.m:1-5]()\n\n## Round Key Selection\n\nThe expanded key array `w` generated by `KeyExpansion` contains all round keys concatenated as columns. The round key selection pattern is:\n\n| Round Type | Round Number | Key Columns Used |\n|------------|--------------|------------------|\n| Initial    | 0            | `w(:,1:4)` |\n| Main       | k (2 to Nk+6)| `w(:,4*(k-1)+1:4*k)` |\n| Final      | Nk+7         | `w(:,4*(Nk+6)+1:4*(Nk+7))` |\n\nThis indexing ensures that each round uses a unique 128-bit (4×4 byte) round key derived from the original encryption key.\n\nSources: [AES_update/Cipher.m:15](), [AES_update/Cipher.m:20](), [AES_update/Cipher.m:24]()"])</script><script>self.__next_f.push([1,"1d:T274d,"])</script><script>self.__next_f.push([1,"# SubBytes Transformation\n\n\u003cdetails\u003e\n\u003csummary\u003eRelevant source files\u003c/summary\u003e\n\nThe following files were used as context for generating this wiki page:\n\n- [AES_update/Cipher.m](AES_update/Cipher.m)\n- [AES_update/SubBytes.m](AES_update/SubBytes.m)\n\n\u003c/details\u003e\n\n\n\n## Purpose and Scope\n\nThis document describes the **SubBytes transformation** in the AES encryption implementation, which performs non-linear byte substitution using the AES S-box lookup table. SubBytes is a critical component of the AES cipher that provides confusion in the encryption process by replacing each byte in the state matrix with a corresponding byte from a fixed substitution table.\n\nFor information about the complete encryption process that uses SubBytes, see [Encryption Process](#2.2). For the inverse operation used in decryption, see [InvSubBytes Transformation](#2.3.1).\n\nSources: [AES_update/SubBytes.m:1-20](), [AES_update/Cipher.m:1-28]()\n\n---\n\n## Overview of SubBytes\n\nThe SubBytes transformation is a **non-linear substitution step** that operates independently on each byte of the AES state matrix. It replaces each byte value (0x00 to 0xFF) with another byte value according to the AES S-box (substitution box) lookup table defined in the FIPS-197 standard.\n\nThe transformation provides:\n- **Non-linearity**: Breaks linear relationships between plaintext and ciphertext\n- **Confusion**: Makes the relationship between key and ciphertext complex\n- **Resistance to cryptanalysis**: The S-box is designed to be resistant to differential and linear cryptanalysis\n\nSources: [AES_update/SubBytes.m:1-20]()\n\n---\n\n## Implementation Details\n\n### Function Signature and State Processing\n\nThe `SubBytes` function is implemented in [AES_update/SubBytes.m:1]() with the following signature:\n\n```matlab\nfunction state = SubBytes(state)\n```\n\nThe function takes a **4×4 state matrix** (or 4×Nb for AES-192/256) where each element is a byte value (0-255 in decimal), performs the S-box substitution on each byte, and returns the transformed state matrix.\n\n**Key Operation**: [AES_update/SubBytes.m:19]()\n```matlab\nstate=Sbox(state+1);\n```\n\nThe `+1` offset is required because MATLAB uses **1-based indexing** while the S-box is defined for byte values 0-255. Each byte value serves as an index into the S-box array.\n\nSources: [AES_update/SubBytes.m:1-20]()\n\n---\n\n### The S-box Lookup Table\n\nThe S-box is a **256-element lookup table** stored as a 16×16 matrix. The implementation stores it as a hexadecimal string literal for compactness and clarity.\n\n**S-box Definition**: [AES_update/SubBytes.m:2-17]()\n\nThe S-box is defined as 16 rows of 32 hexadecimal characters (representing 16 bytes per row):\n\n```\nRow 0: 63 7c 77 7b f2 6b 6f c5 30 01 67 2b fe d7 ab 76\nRow 1: ca 82 c9 7d fa 59 47 f0 ad d4 a2 af 9c a4 72 c0\n...\nRow F: 8c a1 89 0d bf e6 42 68 41 99 2d 0f b0 54 bb 16\n```\n\n**Initialization Process**: [AES_update/SubBytes.m:18]()\n1. The hex string is reshaped and transposed to separate individual bytes\n2. Converted from hexadecimal to decimal using `hex2dec`\n3. Reshaped into a 16×16 matrix where `Sbox(i,j)` contains the substitution value for input byte `(i-1)*16 + (j-1)` in hexadecimal\n\n### S-box Structure Diagram\n\n```mermaid\ngraph TB\n    subgraph \"S-box Initialization\"\n        HEXSTRING[\"Hexadecimal String\u003cbr/\u003e'637c777bf26b6fc5...'\u003cbr/\u003e512 hex characters\"]\n        RESHAPE1[\"reshape() + transpose\u003cbr/\u003eSeparate into bytes\"]\n        HEX2DEC[\"hex2dec()\u003cbr/\u003eConvert to decimal\"]\n        RESHAPE2[\"reshape(16,16)\u003cbr/\u003eCreate 16×16 matrix\"]\n        \n        HEXSTRING --\u003e RESHAPE1\n        RESHAPE1 --\u003e HEX2DEC\n        HEX2DEC --\u003e RESHAPE2\n    end\n    \n    subgraph \"Lookup Operation\"\n        INPUT[\"Input State\u003cbr/\u003e4×4 byte matrix\u003cbr/\u003eValues: 0-255\"]\n        OFFSET[\"state + 1\u003cbr/\u003eAdjust for MATLAB indexing\"]\n        LOOKUP[\"Sbox(state+1)\u003cbr/\u003eArray indexing\"]\n        OUTPUT[\"Output State\u003cbr/\u003e4×4 substituted bytes\"]\n        \n        INPUT --\u003e OFFSET\n        OFFSET --\u003e LOOKUP\n        RESHAPE2 --\u003e LOOKUP\n        LOOKUP --\u003e OUTPUT\n    end\n    \n    style HEXSTRING fill:#f9f9f9\n    style OUTPUT fill:#f9f9f9\n```\n\nSources: [AES_update/SubBytes.m:2-19]()\n\n---\n\n### Byte Substitution Logic\n\nThe substitution process for each byte follows this logic:\n\n| Step | Operation | Example |\n|------|-----------|---------|\n| 1. Input byte | Get byte value from state | `0x53` (decimal 83) |\n| 2. Add offset | Add 1 for MATLAB indexing | `84` |\n| 3. Lookup | Index into S-box array | `Sbox(84)` |\n| 4. Substitute | Replace original byte | `0xED` (decimal 237) |\n\n**Matrix Operation**: The substitution is applied element-wise to the entire state matrix simultaneously using MATLAB's array indexing:\n```matlab\nstate = Sbox(state+1)\n```\n\nThis is functionally equivalent to:\n```\nfor each row i in state:\n    for each column j in state:\n        state(i,j) = Sbox(state(i,j) + 1)\n```\n\nSources: [AES_update/SubBytes.m:19]()\n\n---\n\n## Integration in the Cipher Process\n\n### Position in Cipher Rounds\n\nThe SubBytes transformation is called **twice per encryption** in the main `Cipher` function:\n\n```mermaid\ngraph TD\n    START[\"Cipher function begins\u003cbr/\u003eAES_update/Cipher.m\"]\n    INITIAL[\"Initial Round\u003cbr/\u003eAddRoundKey only\"]\n    \n    LOOP_START[\"Standard Rounds Loop\u003cbr/\u003erounds 2 to Nk+6\"]\n    SB1[\"SubBytes(state)\u003cbr/\u003eLine 17\"]\n    SR1[\"ShiftRows(state)\u003cbr/\u003eLine 18\"]\n    MC1[\"MixColumns(state)\u003cbr/\u003eLine 19\"]\n    ARK1[\"AddRoundKey(state)\u003cbr/\u003eLine 20\"]\n    \n    FINAL[\"Final Round\u003cbr/\u003eround Nk+7\"]\n    SB2[\"SubBytes(state)\u003cbr/\u003eLine 22\"]\n    SR2[\"ShiftRows(state)\u003cbr/\u003eLine 23\"]\n    ARK2[\"AddRoundKey(state)\u003cbr/\u003eLine 24\"]\n    \n    END[\"Cipher output\"]\n    \n    START --\u003e INITIAL\n    INITIAL --\u003e LOOP_START\n    LOOP_START --\u003e SB1\n    SB1 --\u003e SR1\n    SR1 --\u003e MC1\n    MC1 --\u003e ARK1\n    ARK1 -.-\u003e|\"Next iteration\"| LOOP_START\n    ARK1 --\u003e FINAL\n    FINAL --\u003e SB2\n    SB2 --\u003e SR2\n    SR2 --\u003e ARK2\n    ARK2 --\u003e END\n```\n\nSources: [AES_update/Cipher.m:15-24]()\n\n---\n\n### Usage in Standard Rounds\n\nIn the main encryption rounds (rounds 2 through Nk+6, where Nk depends on key size):\n\n**Location**: [AES_update/Cipher.m:16-21]()\n\n```matlab\nfor k=2:(Nk+6)\n    state=SubBytes(state);      % Line 17\n    state=ShiftRows(state);\n    state=MixColumns(state);\n    state=AddRoundKey(state,w(:,4*(k-1)+1:4*k));\nend\n```\n\nSubBytes is the **first transformation** applied in each standard round, immediately after the previous round's AddRoundKey operation.\n\n| AES Variant | Nk | Standard Rounds | SubBytes Calls in Loop |\n|-------------|----|-----------------|-----------------------|\n| AES-128 | 4 | 9 rounds (k=2..10) | 9 times |\n| AES-192 | 6 | 11 rounds (k=2..12) | 11 times |\n| AES-256 | 8 | 13 rounds (k=2..14) | 13 times |\n\nSources: [AES_update/Cipher.m:16-21]()\n\n---\n\n### Usage in Final Round\n\nThe final round omits the MixColumns transformation but still includes SubBytes:\n\n**Location**: [AES_update/Cipher.m:22-24]()\n\n```matlab\nstate=SubBytes(state);          % Line 22\nstate=ShiftRows(state);\nstate=AddRoundKey(state,w(:,4*(Nk+6)+1:4*(Nk+7)));\n```\n\nThis is the **last SubBytes call** in the encryption process. The final round structure differs from standard rounds by excluding MixColumns to maintain symmetry with the decryption process.\n\n**Total SubBytes Calls per Encryption**:\n- AES-128: 9 (loop) + 1 (final) = **10 calls**\n- AES-192: 11 (loop) + 1 (final) = **12 calls**\n- AES-256: 13 (loop) + 1 (final) = **14 calls**\n\nSources: [AES_update/Cipher.m:22-24]()\n\n---\n\n## Code Entity Reference\n\n### Function Call Hierarchy\n\n```mermaid\ngraph LR\n    CIPHER[\"Cipher()\u003cbr/\u003eAES_update/Cipher.m:1\"]\n    SUBBYTES[\"SubBytes()\u003cbr/\u003eAES_update/SubBytes.m:1\"]\n    \n    KEYEXP[\"KeyExpansion()\u003cbr/\u003eAES_update/KeyExpansion.m\"]\n    SHIFTROWS[\"ShiftRows()\u003cbr/\u003eAES_update/ShiftRows.m\"]\n    MIXCOLS[\"MixColumns()\u003cbr/\u003eAES_update/MixColumns.m\"]\n    ADDKEY[\"AddRoundKey()\u003cbr/\u003eAES_update/AddRoundKey.m\"]\n    \n    CIPHER --\u003e|\"Lines 17, 22\"| SUBBYTES\n    CIPHER --\u003e|\"Line 13\"| KEYEXP\n    CIPHER --\u003e|\"Lines 18, 23\"| SHIFTROWS\n    CIPHER --\u003e|\"Line 19\"| MIXCOLS\n    CIPHER --\u003e|\"Lines 15, 20, 24\"| ADDKEY\n    \n    SBOX[\"S-box Lookup Table\u003cbr/\u003e256-byte array\"]\n    SUBBYTES --\u003e|\"Line 19\"| SBOX\n```\n\nSources: [AES_update/Cipher.m:1-28](), [AES_update/SubBytes.m:1-20]()\n\n---\n\n## Mathematical Foundation\n\n### S-box Construction (Informational)\n\nWhile the implementation uses a **pre-computed lookup table** [AES_update/SubBytes.m:2-17](), the AES S-box is mathematically constructed through two operations:\n\n1. **Multiplicative Inverse**: Each byte is replaced with its multiplicative inverse in the Galois Field GF(2⁸) (with 0x00 mapping to itself)\n2. **Affine Transformation**: An affine transformation over GF(2) is applied to the result\n\nThe pre-computed table eliminates the need to calculate these operations at runtime, providing constant-time O(1) lookup performance regardless of input values.\n\n### Security Properties\n\nThe S-box substitution provides resistance to:\n- **Linear cryptanalysis**: Maximum non-linearity in the boolean functions\n- **Differential cryptanalysis**: Low differential uniformity\n- **Algebraic attacks**: High algebraic complexity\n\nThese properties make SubBytes the primary source of **non-linearity** in the AES cipher, ensuring that the relationship between plaintext, ciphertext, and key is highly complex.\n\nSources: [AES_update/SubBytes.m:1-20]()\n\n---\n\n## Summary\n\nThe SubBytes transformation in this AES implementation:\n\n- Operates on a 4×4 state matrix (or 4×Nb for extended variants)\n- Uses a pre-computed 16×16 S-box lookup table stored in [AES_update/SubBytes.m:2-17]()\n- Applies byte substitution via array indexing: `Sbox(state+1)` at [AES_update/SubBytes.m:19]()\n- Is called in every cipher round by [AES_update/Cipher.m:17]() (standard rounds) and [AES_update/Cipher.m:22]() (final round)\n- Provides the non-linear transformation essential to AES security\n\nThe implementation is straightforward and efficient, using MATLAB's array indexing capabilities to perform all 16 byte substitutions in a single operation.\n\nSources: [AES_update/SubBytes.m:1-20](), [AES_update/Cipher.m:1-28]()"])</script><script>self.__next_f.push([1,"1e:T2378,"])</script><script>self.__next_f.push([1,"# ShiftRows Transformation\n\n\u003cdetails\u003e\n\u003csummary\u003eRelevant source files\u003c/summary\u003e\n\nThe following files were used as context for generating this wiki page:\n\n- [AES_update/Cipher.m](AES_update/Cipher.m)\n- [AES_update/ShiftRows.m](AES_update/ShiftRows.m)\n\n\u003c/details\u003e\n\n\n\n## Purpose and Scope\n\nThis document explains the **ShiftRows** transformation, one of the four fundamental operations in the AES encryption cipher. ShiftRows is a byte-transposition step that cyclically shifts the rows of the AES state matrix by different offsets, providing diffusion of data across columns.\n\nFor information about the complete encryption process, see [Encryption Process](#2.2). For the inverse operation used in decryption, see [InvShiftRows Transformation](#2.3.2). For other transformations in the cipher round, see [SubBytes Transformation](#2.2.1), [MixColumns Transformation](#2.2.3), and [AddRoundKey Transformation](#2.2.4).\n\n## Overview\n\nThe ShiftRows transformation operates on the 4×4 byte state matrix that represents the intermediate cipher state during AES encryption. This transformation performs a simple permutation by cyclically shifting each row of the state matrix to the left by a row-dependent offset. The operation provides diffusion by mixing bytes across different columns, which ensures that changes in input bytes affect multiple bytes in subsequent transformations.\n\n**Sources:** [AES_update/ShiftRows.m:1-5](), [AES_update/Cipher.m:1-28]()\n\n## Transformation Rules\n\nThe ShiftRows transformation applies the following row-wise circular left shifts to the state matrix:\n\n| Row Index | Shift Amount | Description |\n|-----------|--------------|-------------|\n| Row 1 | 0 bytes | No shift (row remains unchanged) |\n| Row 2 | 1 byte left | First byte moves to last position |\n| Row 3 | 2 bytes left | First two bytes move to end |\n| Row 4 | 3 bytes left | First three bytes move to end |\n\nThe first row (row 1 in MATLAB 1-based indexing) is not shifted. Each subsequent row is shifted left by an incrementally larger offset, with bytes wrapping around from the left edge to the right edge of the row.\n\n**Sources:** [AES_update/ShiftRows.m:2-4]()\n\n## State Transformation Visualization\n\n```mermaid\ngraph TB\n    subgraph Input[\"Input State Matrix (4x4 bytes)\"]\n        I00[\"s[1,1]\"]\n        I01[\"s[1,2]\"]\n        I02[\"s[1,3]\"]\n        I03[\"s[1,4]\"]\n        I10[\"s[2,1]\"]\n        I11[\"s[2,2]\"]\n        I12[\"s[2,3]\"]\n        I13[\"s[2,4]\"]\n        I20[\"s[3,1]\"]\n        I21[\"s[3,2]\"]\n        I22[\"s[3,3]\"]\n        I23[\"s[3,4]\"]\n        I30[\"s[4,1]\"]\n        I31[\"s[4,2]\"]\n        I32[\"s[4,3]\"]\n        I33[\"s[4,4]\"]\n    end\n    \n    subgraph Operation[\"ShiftRows Operation\"]\n        R1[\"Row 1: No shift\"]\n        R2[\"Row 2: circshift by -1\"]\n        R3[\"Row 3: circshift by -2\"]\n        R4[\"Row 4: circshift by -3\"]\n    end\n    \n    subgraph Output[\"Output State Matrix (4x4 bytes)\"]\n        O00[\"s[1,1]\"]\n        O01[\"s[1,2]\"]\n        O02[\"s[1,3]\"]\n        O03[\"s[1,4]\"]\n        O10[\"s[2,2]\"]\n        O11[\"s[2,3]\"]\n        O12[\"s[2,4]\"]\n        O13[\"s[2,1]\"]\n        O20[\"s[3,3]\"]\n        O21[\"s[3,4]\"]\n        O22[\"s[3,1]\"]\n        O23[\"s[3,2]\"]\n        O30[\"s[4,4]\"]\n        O31[\"s[4,1]\"]\n        O32[\"s[4,2]\"]\n        O33[\"s[4,3]\"]\n    end\n    \n    I00 --\u003e R1\n    I01 --\u003e R1\n    I02 --\u003e R1\n    I03 --\u003e R1\n    \n    I10 --\u003e R2\n    I11 --\u003e R2\n    I12 --\u003e R2\n    I13 --\u003e R2\n    \n    I20 --\u003e R3\n    I21 --\u003e R3\n    I22 --\u003e R3\n    I23 --\u003e R3\n    \n    I30 --\u003e R4\n    I31 --\u003e R4\n    I32 --\u003e R4\n    I33 --\u003e R4\n    \n    R1 --\u003e O00\n    R1 --\u003e O01\n    R1 --\u003e O02\n    R1 --\u003e O03\n    \n    R2 --\u003e O10\n    R2 --\u003e O11\n    R2 --\u003e O12\n    R2 --\u003e O13\n    \n    R3 --\u003e O20\n    R3 --\u003e O21\n    R3 --\u003e O22\n    R3 --\u003e O23\n    \n    R4 --\u003e O30\n    R4 --\u003e O31\n    R4 --\u003e O32\n    R4 --\u003e O33\n```\n\n**Diagram: State Matrix Transformation by ShiftRows**\n\nThis diagram illustrates how bytes are repositioned within the state matrix. Note that row 1 bytes retain their positions, while rows 2-4 undergo progressively larger leftward circular shifts.\n\n**Sources:** [AES_update/ShiftRows.m:1-5]()\n\n## Implementation Details\n\n### Function Signature\n\n```matlab\nfunction state = ShiftRows(state)\n```\n\nThe `ShiftRows` function accepts and returns a 4×4 state matrix containing the current cipher state.\n\n**Sources:** [AES_update/ShiftRows.m:1]()\n\n### Core Operations\n\nThe implementation uses MATLAB's `circshift` function to perform circular shifts on each row:\n\n```matlab\nstate(2,:) = circshift(state(2,:), [0 -1]);\nstate(3,:) = circshift(state(3,:), [0 -2]);\nstate(4,:) = circshift(state(4,:), [0 -3]);\n```\n\n| Row Operation | Code Reference | Shift Vector | Effect |\n|---------------|----------------|--------------|--------|\n| Row 2 shift | [AES_update/ShiftRows.m:2]() | `[0 -1]` | Shift left by 1 byte |\n| Row 3 shift | [AES_update/ShiftRows.m:3]() | `[0 -2]` | Shift left by 2 bytes |\n| Row 4 shift | [AES_update/ShiftRows.m:4]() | `[0 -3]` | Shift left by 3 bytes |\n\nThe `circshift` function parameters are:\n- First argument: Row vector to shift (e.g., `state(2,:)` extracts row 2)\n- Second argument: Shift amount as `[row_shift, column_shift]`\n  - Negative column values shift left\n  - The shift is circular (wrap-around)\n\nRow 1 (`state(1,:)`) is not modified, as it requires no shift according to the AES specification.\n\n**Sources:** [AES_update/ShiftRows.m:2-4]()\n\n## Integration in Cipher Process\n\nThe `ShiftRows` function is called during the AES encryption process as part of each cipher round. It appears twice in the `Cipher` function:\n\n```mermaid\ngraph TD\n    Start[\"Cipher Function Entry\"]\n    KeyExp[\"KeyExpansion\"]\n    InitState[\"Reshape input to state matrix\"]\n    InitRound[\"AddRoundKey - Initial Round\"]\n    \n    LoopStart[\"Round Loop Start\u003cbr/\u003ek = 2 to Nk+6\"]\n    SubBytes1[\"SubBytes\"]\n    ShiftRows1[\"ShiftRows\"]\n    MixColumns1[\"MixColumns\"]\n    AddRoundKey1[\"AddRoundKey\"]\n    LoopEnd[\"Round Loop End\"]\n    \n    FinalSub[\"SubBytes - Final Round\"]\n    FinalShift[\"ShiftRows - Final Round\"]\n    FinalAdd[\"AddRoundKey - Final Round\"]\n    \n    Output[\"Reshape and convert output\"]\n    \n    Start --\u003e KeyExp\n    KeyExp --\u003e InitState\n    InitState --\u003e InitRound\n    InitRound --\u003e LoopStart\n    \n    LoopStart --\u003e SubBytes1\n    SubBytes1 --\u003e ShiftRows1\n    ShiftRows1 --\u003e MixColumns1\n    MixColumns1 --\u003e AddRoundKey1\n    AddRoundKey1 --\u003e LoopEnd\n    LoopEnd --\u003e|More rounds| LoopStart\n    LoopEnd --\u003e|Rounds complete| FinalSub\n    \n    FinalSub --\u003e FinalShift\n    FinalShift --\u003e FinalAdd\n    FinalAdd --\u003e Output\n```\n\n**Diagram: ShiftRows in the Cipher Execution Flow**\n\n### Regular Round Invocation\n\nDuring rounds 2 through `Nk+6`, `ShiftRows` is called as the second transformation in the sequence:\n\n1. `SubBytes` - Byte substitution [AES_update/Cipher.m:17]()\n2. `ShiftRows` - Row shifting [AES_update/Cipher.m:18]()\n3. `MixColumns` - Column mixing [AES_update/Cipher.m:19]()\n4. `AddRoundKey` - Round key XOR [AES_update/Cipher.m:20]()\n\n**Sources:** [AES_update/Cipher.m:16-21]()\n\n### Final Round Invocation\n\nThe final round omits the `MixColumns` step but still includes `ShiftRows`:\n\n1. `SubBytes` - Byte substitution [AES_update/Cipher.m:22]()\n2. `ShiftRows` - Row shifting [AES_update/Cipher.m:23]()\n3. `AddRoundKey` - Final round key XOR [AES_update/Cipher.m:24]()\n\nThis conforms to the AES standard, which specifies that the last round excludes the `MixColumns` transformation.\n\n**Sources:** [AES_update/Cipher.m:22-24]()\n\n## Function Call Context\n\n```mermaid\ngraph LR\n    Cipher[\"Cipher.m\u003cbr/\u003eMain encryption function\"]\n    ShiftRows[\"ShiftRows.m\u003cbr/\u003eRow permutation\"]\n    State[\"state matrix\u003cbr/\u003e4x4 byte array\"]\n    \n    Cipher --\u003e|\"Line 18: state = ShiftRows(state)\"| ShiftRows\n    Cipher --\u003e|\"Line 23: state = ShiftRows(state)\"| ShiftRows\n    \n    ShiftRows --\u003e|\"Row 2: circshift by -1\"| State\n    ShiftRows --\u003e|\"Row 3: circshift by -2\"| State\n    ShiftRows --\u003e|\"Row 4: circshift by -3\"| State\n    \n    State --\u003e|Modified state| Cipher\n```\n\n**Diagram: Code Entity Relationships for ShiftRows**\n\nThe `ShiftRows` function is a pure transformation that:\n- Accepts the state matrix as input\n- Modifies specific rows in-place using circular shifts\n- Returns the modified state matrix\n- Has no dependencies on other AES functions\n- Is called exactly twice per encryption operation\n\n**Sources:** [AES_update/Cipher.m:18](), [AES_update/Cipher.m:23](), [AES_update/ShiftRows.m:1-5]()\n\n## Algorithmic Purpose\n\nThe ShiftRows transformation serves a critical role in the AES cipher by ensuring that byte changes propagate across columns. When combined with the MixColumns transformation (which operates on columns), ShiftRows guarantees that input bytes influence multiple output bytes across the entire state matrix, providing the diffusion property essential for cryptographic security.\n\nWithout ShiftRows, the cipher would process each column independently, creating vulnerabilities to cryptanalysis. The specific shift offsets (0, 1, 2, 3) were chosen to maximize diffusion efficiency within the AES round structure.\n\n**Sources:** [AES_update/ShiftRows.m:1-5](), [AES_update/Cipher.m:16-24]()"])</script><script>self.__next_f.push([1,"1f:T2453,"])</script><script>self.__next_f.push([1,"# MixColumns Transformation\n\n\u003cdetails\u003e\n\u003csummary\u003eRelevant source files\u003c/summary\u003e\n\nThe following files were used as context for generating this wiki page:\n\n- [AES_update/Cipher.m](AES_update/Cipher.m)\n- [AES_update/MixColumns.m](AES_update/MixColumns.m)\n- [AES_update/xtime.m](AES_update/xtime.m)\n\n\u003c/details\u003e\n\n\n\n## Purpose and Scope\n\nThis page documents the `MixColumns` transformation, one of the four core operations in AES encryption rounds. The MixColumns transformation provides diffusion by mixing the bytes within each column of the AES state matrix using Galois field arithmetic. This operation is applied during every encryption round except the final round.\n\nFor the inverse operation used during decryption, see [InvMixColumns Transformation](#2.3.3). For detailed explanation of the Galois field multiplication primitives, see [Galois Field Arithmetic](#2.4). For the complete encryption round structure, see [Encryption Process](#2.2).\n\nSources: [AES_update/MixColumns.m:1-9](), [AES_update/Cipher.m:1-28]()\n\n---\n\n## Role in AES Encryption\n\nThe `MixColumns` function operates on the 4×4 state matrix during each encryption round (except the final round). It is invoked after `SubBytes` and `ShiftRows` transformations and before `AddRoundKey`.\n\n### Invocation Context\n\n```mermaid\ngraph TD\n    Start[\"Encryption Round k\"] --\u003e SubBytes[\"SubBytes(state)\"]\n    SubBytes --\u003e ShiftRows[\"ShiftRows(state)\"]\n    ShiftRows --\u003e MixColumns[\"MixColumns(state)\"]\n    MixColumns --\u003e AddRoundKey[\"AddRoundKey(state, w)\"]\n    AddRoundKey --\u003e NextRound[\"Next Round or Final Round\"]\n    \n    Note1[\"Final round\u003cbr/\u003eomits MixColumns\"]\n    Note1 -.-\u003e MixColumns\n```\n\nSources: [AES_update/Cipher.m:16-21]()\n\nIn [AES_update/Cipher.m:16-21](), the encryption loop applies `MixColumns` during rounds 2 through Nk+6:\n\n| Round Stage | Operation | Line Reference |\n|-------------|-----------|----------------|\n| Round k, Step 1 | `SubBytes(state)` | [Cipher.m:17]() |\n| Round k, Step 2 | `ShiftRows(state)` | [Cipher.m:18]() |\n| Round k, Step 3 | `MixColumns(state)` | [Cipher.m:19]() |\n| Round k, Step 4 | `AddRoundKey(state, w)` | [Cipher.m:20]() |\n| Final round | Omits MixColumns | [Cipher.m:22-24]() |\n\nSources: [AES_update/Cipher.m:16-24]()\n\n---\n\n## Mathematical Foundation\n\nThe MixColumns transformation treats each column of the state matrix as a four-term polynomial over GF(2⁸) and multiplies it modulo x⁴+1 with the fixed polynomial c(x) = {03}x³ + {01}x² + {01}x + {02}.\n\n### Matrix Representation\n\nEach column [s₀, s₁, s₂, s₃]ᵀ is transformed by multiplying with the fixed circulant MDS (Maximum Distance Separable) matrix:\n\n```\n┌    ┐   ┌           ┐   ┌    ┐\n│ s₀'│   │02 03 01 01│   │ s₀ │\n│ s₁'│ = │01 02 03 01│ × │ s₁ │\n│ s₂'│   │01 01 02 03│   │ s₂ │\n│ s₃'│   │03 01 01 02│   │ s₃ │\n└    ┘   └           ┘   └    ┘\n```\n\nWhere multiplication and addition are performed in the Galois field GF(2⁸) with the irreducible polynomial m(x) = x⁸ + x⁴ + x³ + x + 1.\n\nSources: [AES_update/MixColumns.m:1-9]()\n\n---\n\n## Implementation Details\n\n### Function Signature and State Processing\n\nThe `MixColumns` function processes the 16-byte state array as four independent columns:\n\n```mermaid\ngraph LR\n    subgraph \"State Array (column-major)\"\n        S[\"state[0:15]\"]\n    end\n    \n    subgraph \"Column Processing\"\n        C0[\"Column 0\u003cbr/\u003eindices 0,1,2,3\"]\n        C1[\"Column 1\u003cbr/\u003eindices 4,5,6,7\"]\n        C2[\"Column 2\u003cbr/\u003eindices 8,9,10,11\"]\n        C3[\"Column 3\u003cbr/\u003eindices 12,13,14,15\"]\n    end\n    \n    subgraph \"Operations\"\n        MC0[\"MixColumns\u003cbr/\u003eon Column 0\"]\n        MC1[\"MixColumns\u003cbr/\u003eon Column 1\"]\n        MC2[\"MixColumns\u003cbr/\u003eon Column 2\"]\n        MC3[\"MixColumns\u003cbr/\u003eon Column 3\"]\n    end\n    \n    S --\u003e C0\n    S --\u003e C1\n    S --\u003e C2\n    S --\u003e C3\n    \n    C0 --\u003e MC0\n    C1 --\u003e MC1\n    C2 --\u003e MC2\n    C3 --\u003e MC3\n    \n    MC0 --\u003e Out[\"State[0:15]\u003cbr/\u003etransformed\"]\n    MC1 --\u003e Out\n    MC2 --\u003e Out\n    MC3 --\u003e Out\n```\n\nSources: [AES_update/MixColumns.m:3-8]()\n\n### Column-wise Loop Structure\n\nThe function [AES_update/MixColumns.m:3-8]() iterates through the state array in steps of 4, processing each column:\n\n| Loop Variable `a` | Column Index | Byte Indices | Operation |\n|-------------------|--------------|--------------|-----------|\n| 1 | Column 0 | 1, 2, 3, 4 | MixColumns on bytes 0-3 |\n| 5 | Column 1 | 5, 6, 7, 8 | MixColumns on bytes 4-7 |\n| 9 | Column 2 | 9, 10, 11, 12 | MixColumns on bytes 8-11 |\n| 13 | Column 3 | 13, 14, 15, 16 | MixColumns on bytes 12-15 |\n\n*Note: MATLAB uses 1-based indexing, so index 1 corresponds to byte 0 in standard AES notation.*\n\nSources: [AES_update/MixColumns.m:3]()\n\n---\n\n## Matrix Transformation Process\n\n### Byte-level Transformation Equations\n\nFor each column starting at index `a`, the transformation computes four output bytes. The implementation at [AES_update/MixColumns.m:4-7]() calculates:\n\n```mermaid\ngraph TD\n    subgraph \"Input Column\"\n        SA[\"state(a)\"]\n        SA1[\"state(a+1)\"]\n        SA2[\"state(a+2)\"]\n        SA3[\"state(a+3)\"]\n    end\n    \n    subgraph \"Galois Field Operations\"\n        X2A[\"xtime(state(a), 2)\"]\n        X3A1[\"xtime(state(a+1), 3)\"]\n        X2A1[\"xtime(state(a+1), 2)\"]\n        X3A2[\"xtime(state(a+2), 3)\"]\n        X2A2[\"xtime(state(a+2), 2)\"]\n        X3A3[\"xtime(state(a+3), 3)\"]\n        X2A3[\"xtime(state(a+3), 2)\"]\n        X3A[\"xtime(state(a), 3)\"]\n    end\n    \n    subgraph \"Output Column\"\n        OUT0[\"State(a) =\u003cbr/\u003e(2•a) ⊕ (3•a+1) ⊕ a+2 ⊕ a+3\"]\n        OUT1[\"State(a+1) =\u003cbr/\u003ea ⊕ (2•a+1) ⊕ (3•a+2) ⊕ a+3\"]\n        OUT2[\"State(a+2) =\u003cbr/\u003ea ⊕ a+1 ⊕ (2•a+2) ⊕ (3•a+3)\"]\n        OUT3[\"State(a+3) =\u003cbr/\u003e(3•a) ⊕ a+1 ⊕ a+2 ⊕ (2•a+3)\"]\n    end\n    \n    SA --\u003e X2A\n    SA1 --\u003e X3A1\n    SA --\u003e X3A\n    SA1 --\u003e X2A1\n    SA2 --\u003e X3A2\n    SA2 --\u003e X2A2\n    SA3 --\u003e X3A3\n    SA3 --\u003e X2A3\n    \n    X2A --\u003e OUT0\n    X3A1 --\u003e OUT0\n    SA2 --\u003e OUT0\n    SA3 --\u003e OUT0\n    \n    SA --\u003e OUT1\n    X2A1 --\u003e OUT1\n    X3A2 --\u003e OUT1\n    SA3 --\u003e OUT1\n    \n    SA --\u003e OUT2\n    SA1 --\u003e OUT2\n    X2A2 --\u003e OUT2\n    X3A3 --\u003e OUT2\n    \n    X3A --\u003e OUT3\n    SA1 --\u003e OUT3\n    SA2 --\u003e OUT3\n    X2A3 --\u003e OUT3\n```\n\nSources: [AES_update/MixColumns.m:4-7]()\n\n### Implementation Equations\n\nThe four output bytes per column are computed using nested XOR and Galois field multiplications:\n\n**State(a)** - First byte of output column:\n```\nState(a) = xtime(state(a), 2) ⊕ xtime(state(a+1), 3) ⊕ state(a+2) ⊕ state(a+3)\n```\nImplemented at [AES_update/MixColumns.m:4]()\n\n**State(a+1)** - Second byte of output column:\n```\nState(a+1) = state(a) ⊕ xtime(state(a+1), 2) ⊕ xtime(state(a+2), 3) ⊕ state(a+3)\n```\nImplemented at [AES_update/MixColumns.m:5]()\n\n**State(a+2)** - Third byte of output column:\n```\nState(a+2) = state(a) ⊕ state(a+1) ⊕ xtime(state(a+2), 2) ⊕ xtime(state(a+3), 3)\n```\nImplemented at [AES_update/MixColumns.m:6]()\n\n**State(a+3)** - Fourth byte of output column:\n```\nState(a+3) = xtime(state(a), 3) ⊕ state(a+1) ⊕ state(a+2) ⊕ xtime(state(a+3), 2)\n```\nImplemented at [AES_update/MixColumns.m:7]()\n\nSources: [AES_update/MixColumns.m:4-7]()\n\n---\n\n## Galois Field Multiplication\n\n### Dependency on xtime Function\n\nThe `MixColumns` transformation relies on the `xtime` function for all Galois field GF(2⁸) multiplications. Each transformation equation calls `xtime` to multiply state bytes by constants 2 or 3:\n\n| Multiplication | Function Call | Purpose |\n|----------------|---------------|---------|\n| state × 2 | `xtime(state, 2)` | Multiply byte by {02} in GF(2⁸) |\n| state × 3 | `xtime(state, 3)` | Multiply byte by {03} in GF(2⁸) |\n\nSources: [AES_update/MixColumns.m:4-7](), [AES_update/xtime.m:1-18]()\n\n### Integration with xtime\n\n```mermaid\ngraph TB\n    subgraph \"MixColumns.m\"\n        MC[\"MixColumns(state)\"]\n        Loop[\"for a = 1:4:13\"]\n        Compute[\"Compute State(a:a+3)\u003cbr/\u003eusing xtime calls\"]\n    end\n    \n    subgraph \"xtime.m\"\n        XT[\"xtime(x, c)\"]\n        Mult[\"Galois Field\u003cbr/\u003eMultiplication\"]\n        Reduce[\"Modular Reduction\u003cbr/\u003ewith polynomial 0x11B\"]\n    end\n    \n    MC --\u003e Loop\n    Loop --\u003e Compute\n    Compute --\u003e|\"xtime(state(a), 2)\"| XT\n    Compute --\u003e|\"xtime(state(a+1), 3)\"| XT\n    XT --\u003e Mult\n    Mult --\u003e Reduce\n    Reduce --\u003e|\"Result\"| Compute\n```\n\nSources: [AES_update/MixColumns.m:4-7](), [AES_update/xtime.m:1-18]()\n\nThe `xtime` function performs multiplication in GF(2⁸) using the irreducible polynomial x⁸ + x⁴ + x³ + x + 1 (represented as 0x11B = decimal 27 after removing the x⁸ term). For detailed explanation of the `xtime` algorithm, see [Galois Field Arithmetic](#2.4).\n\n---\n\n## Summary of Code Entities\n\n| Entity | Type | File | Purpose |\n|--------|------|------|---------|\n| `MixColumns` | Function | [AES_update/MixColumns.m]() | Main transformation function |\n| `state` | Input parameter | [AES_update/MixColumns.m:1]() | 16-byte state array (column-major) |\n| `State` | Output variable | [AES_update/MixColumns.m:2]() | Transformed state array |\n| `xtime` | Function | [AES_update/xtime.m]() | GF(2⁸) multiplication primitive |\n| `bitxor` | MATLAB built-in | Used throughout | XOR operation for GF(2⁸) addition |\n\nSources: [AES_update/MixColumns.m:1-9](), [AES_update/xtime.m:1-18]()"])</script><script>self.__next_f.push([1,"20:T2900,"])</script><script>self.__next_f.push([1,"# AddRoundKey Transformation\n\n\u003cdetails\u003e\n\u003csummary\u003eRelevant source files\u003c/summary\u003e\n\nThe following files were used as context for generating this wiki page:\n\n- [AES_update/AddRoundKey.m](AES_update/AddRoundKey.m)\n- [AES_update/Cipher.m](AES_update/Cipher.m)\n- [AES_update/InvCipher.m](AES_update/InvCipher.m)\n\n\u003c/details\u003e\n\n\n\n## Purpose and Scope\n\nThis document describes the `AddRoundKey` transformation, one of the four fundamental operations in the AES encryption algorithm. The AddRoundKey transformation combines the current state matrix with a round key through bitwise XOR operations. This is the only step in AES that incorporates the secret key material into the encryption process, making it critical to the security of the cipher.\n\nFor information about the other AES transformations, see:\n- SubBytes transformation: [2.2.1](#2.2.1)\n- ShiftRows transformation: [2.2.2](#2.2.2)\n- MixColumns transformation: [2.2.3](#2.2.3)\n\nFor details on how round keys are generated, see [2.1](#2.1) (Key Expansion).\n\n## Overview\n\nThe AddRoundKey transformation performs a column-wise XOR between the 4×4 state matrix and a 4×4 round key matrix. This operation is executed at the beginning of the cipher, after every round transformation, and as the final step of the last round. Unlike the other AES transformations, AddRoundKey is **self-inverse**, meaning the same operation is used for both encryption and decryption.\n\nSources: [AES_update/AddRoundKey.m:1-5]()\n\n## Operation Details\n\n### Mathematical Foundation\n\nThe AddRoundKey transformation performs the following operation:\n\n```\nstate[i,j] = state[i,j] ⊕ roundKey[i,j]\n```\n\nWhere:\n- `state` is the 4×4 byte matrix representing the current cipher state\n- `roundKey` is the 4×4 byte matrix containing the current round key\n- `⊕` denotes bitwise XOR operation\n\nThe XOR operation works at the byte level, combining corresponding bytes from the state and round key matrices.\n\n### State Matrix Transformation\n\n```mermaid\ngraph LR\n    subgraph \"Input State\"\n        S[\"state[4×4]\u003cbr/\u003eCurrent cipher state\"]\n    end\n    \n    subgraph \"Round Key\"\n        W[\"w[4×4]\u003cbr/\u003eRound key from\u003cbr/\u003eKeyExpansion\"]\n    end\n    \n    subgraph \"AddRoundKey Operation\"\n        XOR[\"Bitwise XOR\u003cbr/\u003eColumn-by-column\u003cbr/\u003ebitxor(state[:,k], w[:,k])\"]\n    end\n    \n    subgraph \"Output State\"\n        OUT[\"state[4×4]\u003cbr/\u003eTransformed state\"]\n    end\n    \n    S --\u003e XOR\n    W --\u003e XOR\n    XOR --\u003e OUT\n```\n\nSources: [AES_update/AddRoundKey.m:1-5]()\n\n## Implementation\n\n### Function Signature\n\n```matlab\nfunction state = AddRoundKey(state, w)\n```\n\n**Parameters:**\n| Parameter | Type | Description |\n|-----------|------|-------------|\n| `state` | 4×4 byte matrix | Current state matrix to be transformed |\n| `w` | 4×4 byte matrix | Round key matrix (4 columns from expanded key schedule) |\n\n**Returns:**\n| Return Value | Type | Description |\n|--------------|------|-------------|\n| `state` | 4×4 byte matrix | Transformed state after XOR with round key |\n\nSources: [AES_update/AddRoundKey.m:1]()\n\n### Core Logic\n\nThe implementation iterates through each column of the state matrix and applies column-wise XOR with the corresponding column of the round key:\n\n```mermaid\ngraph TD\n    START[\"AddRoundKey(state, w)\"]\n    LOOP[\"Loop k = 1 to 4\u003cbr/\u003e(for each column)\"]\n    XOR[\"state[:,k] = bitxor(state[:,k], w[:,k])\"]\n    CHECK{More columns?}\n    RETURN[\"Return state\"]\n    \n    START --\u003e LOOP\n    LOOP --\u003e XOR\n    XOR --\u003e CHECK\n    CHECK --\u003e|Yes| LOOP\n    CHECK --\u003e|No| RETURN\n```\n\nThe actual code performs the XOR operation for each of the four columns:\n\n```\nfor k=1:4\n    state(:,k) = bitxor(state(:,k), w(:,k));\nend\n```\n\nThis column-wise processing ensures that each 32-bit word (4 bytes) of the state is XORed with the corresponding 32-bit word from the round key.\n\nSources: [AES_update/AddRoundKey.m:2-4]()\n\n## Usage in AES Cipher\n\n### Encryption Process (Cipher.m)\n\nIn the encryption process, AddRoundKey is invoked at three distinct stages:\n\n1. **Initial Round**: Before any other transformations\n2. **Main Rounds**: After SubBytes, ShiftRows, and MixColumns\n3. **Final Round**: After SubBytes and ShiftRows (no MixColumns in final round)\n\n```mermaid\ngraph TD\n    START[\"Cipher begins\"]\n    INITIAL[\"AddRoundKey(state, w[:,1:4])\u003cbr/\u003eInitial round\"]\n    \n    LOOP_START[\"Main rounds loop\u003cbr/\u003ek = 2 to Nk+6\"]\n    SUB[\"SubBytes(state)\"]\n    SHIFT[\"ShiftRows(state)\"]\n    MIX[\"MixColumns(state)\"]\n    ADD[\"AddRoundKey(state, w[:,4*(k-1)+1:4*k])\"]\n    \n    FINAL_SUB[\"SubBytes(state)\u003cbr/\u003eFinal round\"]\n    FINAL_SHIFT[\"ShiftRows(state)\"]\n    FINAL_ADD[\"AddRoundKey(state, w[:,4*(Nk+6)+1:4*(Nk+7)])\"]\n    \n    OUTPUT[\"Output ciphertext\"]\n    \n    START --\u003e INITIAL\n    INITIAL --\u003e LOOP_START\n    LOOP_START --\u003e SUB\n    SUB --\u003e SHIFT\n    SHIFT --\u003e MIX\n    MIX --\u003e ADD\n    ADD --\u003e LOOP_START\n    LOOP_START --\u003e|Loop complete| FINAL_SUB\n    FINAL_SUB --\u003e FINAL_SHIFT\n    FINAL_SHIFT --\u003e FINAL_ADD\n    FINAL_ADD --\u003e OUTPUT\n```\n\n**Key Invocation Points:**\n\n| Stage | Line Reference | Round Key Columns | Purpose |\n|-------|----------------|-------------------|---------|\n| Initial | [AES_update/Cipher.m:15]() | `w(:,1:4)` | Whitening step before rounds begin |\n| Main Rounds | [AES_update/Cipher.m:20]() | `w(:,4*(k-1)+1:4*k)` | Key mixing in each round |\n| Final Round | [AES_update/Cipher.m:24]() | `w(:,4*(Nk+6)+1:4*(Nk+7))` | Final key mixing without MixColumns |\n\nSources: [AES_update/Cipher.m:15-24]()\n\n### Decryption Process (InvCipher.m)\n\nIn the decryption process, AddRoundKey is used identically to encryption (since XOR is self-inverse), but the order of operations is reversed:\n\n1. **Initial Step**: Using the last round key\n2. **Main Rounds**: After InvShiftRows and InvSubBytes, before InvMixColumns\n3. **Final Step**: Using the first round key\n\n```mermaid\ngraph TD\n    START[\"InvCipher begins\"]\n    INITIAL[\"AddRoundKey(state, w[:,4*(Nk+6)+1:4*(Nk+7)])\u003cbr/\u003eUsing last round key\"]\n    \n    LOOP_START[\"Main rounds loop\u003cbr/\u003ek = Nk+6 down to 2\"]\n    INV_SHIFT[\"InvShiftRows(state)\"]\n    INV_SUB[\"InvSubBytes(state)\"]\n    ADD[\"AddRoundKey(state, w[:,4*(k-1)+1:4*k])\"]\n    INV_MIX[\"InvMixColumns(state)\"]\n    \n    FINAL_SHIFT[\"InvShiftRows(state)\u003cbr/\u003eFinal round\"]\n    FINAL_SUB[\"InvSubBytes(state)\"]\n    FINAL_ADD[\"AddRoundKey(state, w[:,1:4])\u003cbr/\u003eUsing first round key\"]\n    \n    OUTPUT[\"Output plaintext\"]\n    \n    START --\u003e INITIAL\n    INITIAL --\u003e LOOP_START\n    LOOP_START --\u003e INV_SHIFT\n    INV_SHIFT --\u003e INV_SUB\n    INV_SUB --\u003e ADD\n    ADD --\u003e INV_MIX\n    INV_MIX --\u003e LOOP_START\n    LOOP_START --\u003e|Loop complete| FINAL_SHIFT\n    FINAL_SHIFT --\u003e FINAL_SUB\n    FINAL_SUB --\u003e FINAL_ADD\n    FINAL_ADD --\u003e OUTPUT\n```\n\n**Key Invocation Points:**\n\n| Stage | Line Reference | Round Key Columns | Purpose |\n|-------|----------------|-------------------|---------|\n| Initial | [AES_update/InvCipher.m:15]() | `w(:,4*(Nk+6)+1:4*(Nk+7))` | Start with last encryption round key |\n| Main Rounds | [AES_update/InvCipher.m:19]() | `w(:,4*(k-1)+1:4*k)` | Key unmixing in reverse order |\n| Final Step | [AES_update/InvCipher.m:24]() | `w(:,1:4)` | Final unmixing with initial round key |\n\nSources: [AES_update/InvCipher.m:15-24]()\n\n## Key Properties\n\n### Self-Inverse Property\n\nThe AddRoundKey transformation has a unique property among AES operations: it is **self-inverse**. This is because:\n\n```\nA ⊕ K ⊕ K = A\n```\n\nWhere `A` is any byte value and `K` is the key byte. Applying XOR with the same key twice returns the original value. This property means:\n- The same `AddRoundKey` function is used for both encryption and decryption\n- No separate `InvAddRoundKey` function is needed\n- The operation is symmetric: `AddRoundKey(AddRoundKey(state, key), key) = state`\n\nThis is evident in the codebase where both [AES_update/Cipher.m]() and [AES_update/InvCipher.m]() call the identical `AddRoundKey` function.\n\nSources: [AES_update/AddRoundKey.m:1-5](), [AES_update/Cipher.m:15-24](), [AES_update/InvCipher.m:15-24]()\n\n### Role in AES Security\n\nThe AddRoundKey transformation serves several critical security functions:\n\n1. **Key Material Integration**: It is the only step that directly incorporates the secret key into the encryption process\n2. **Confusion**: Combines with other transformations to obscure the relationship between plaintext, ciphertext, and key\n3. **Round Separation**: Different round keys ensure each round provides independent security\n4. **Whitening**: The initial and final AddRoundKey operations provide input/output whitening\n\nWithout AddRoundKey, the other transformations (SubBytes, ShiftRows, MixColumns) would form a fixed permutation independent of the key, providing no security.\n\n## Round Key Selection\n\nThe round key matrix passed to AddRoundKey is extracted from the expanded key schedule produced by the `KeyExpansion` function (see [2.1](#2.1)). The key schedule is organized as a sequence of 4-byte words, and AddRoundKey selects 4 consecutive words (16 bytes = 128 bits) for each invocation:\n\n```mermaid\ngraph LR\n    subgraph \"Expanded Key Schedule w\"\n        W1[\"w[:,1:4]\u003cbr/\u003eRound 0\"]\n        W2[\"w[:,5:8]\u003cbr/\u003eRound 1\"]\n        W3[\"w[:,9:12]\u003cbr/\u003eRound 2\"]\n        WDOTS[\"...\"]\n        WN[\"w[:,4*Nr+1:4*(Nr+1)]\u003cbr/\u003eRound Nr\"]\n    end\n    \n    subgraph \"AddRoundKey Invocations\"\n        A0[\"Initial AddRoundKey\"]\n        A1[\"Round 1 AddRoundKey\"]\n        A2[\"Round 2 AddRoundKey\"]\n        ADOTS[\"...\"]\n        AN[\"Final AddRoundKey\"]\n    end\n    \n    W1 --\u003e A0\n    W2 --\u003e A1\n    W3 --\u003e A2\n    WN --\u003e AN\n```\n\nFor AES-128 (Nk=4): 11 rounds, requiring w[:, 1:44]\nFor AES-192 (Nk=6): 13 rounds, requiring w[:, 1:52]\nFor AES-256 (Nk=8): 15 rounds, requiring w[:, 1:60]\n\nSources: [AES_update/Cipher.m:13-24](), [AES_update/InvCipher.m:13-24]()\n\n## Summary\n\nThe AddRoundKey transformation is a simple yet essential component of AES:\n\n| Aspect | Description |\n|--------|-------------|\n| **Operation** | Column-wise XOR of state with round key |\n| **Implementation** | 4-line loop in MATLAB using `bitxor` |\n| **Complexity** | O(16) - constant time for 16-byte state |\n| **Inverse** | Self-inverse (XOR property) |\n| **Frequency** | Nr+1 times per encryption/decryption (Nr = number of rounds) |\n| **Key Dependency** | Only transformation that uses the secret key |\n\nThe transformation's simplicity belies its importance: it is the sole mechanism by which the secret key affects the cipher output, making it indispensable to AES security.\n\nSources: [AES_update/AddRoundKey.m:1-5](), [AES_update/Cipher.m:1-28](), [AES_update/InvCipher.m:1-28]()"])</script><script>self.__next_f.push([1,"21:T2b52,"])</script><script>self.__next_f.push([1,"# Decryption Process\n\n\u003cdetails\u003e\n\u003csummary\u003eRelevant source files\u003c/summary\u003e\n\nThe following files were used as context for generating this wiki page:\n\n- [AES_update/AddRoundKey.m](AES_update/AddRoundKey.m)\n- [AES_update/InvCipher.m](AES_update/InvCipher.m)\n\n\u003c/details\u003e\n\n\n\n## Purpose and Scope\n\nThis document details the AES decryption process as implemented in the `InvCipher` function. The decryption process reverses the encryption operation to recover plaintext from ciphertext using the same encryption key. The process applies inverse transformations in reverse order compared to encryption.\n\nFor information about the forward encryption process, see [Encryption Process](#2.2). For details about individual inverse transformations, see subsections [InvSubBytes](#2.3.1), [InvShiftRows](#2.3.2), and [InvMixColumns](#2.3.3). For key expansion details, see [Key Expansion](#2.1).\n\n---\n\n## InvCipher Function Overview\n\nThe main decryption function is `InvCipher`, which implements the AES inverse cipher algorithm according to FIPS-197 specification. This function supports all three AES key sizes: 128-bit, 192-bit, and 256-bit.\n\n### Function Signature\n\nThe `InvCipher` function accepts two parameters:\n\n| Parameter | Type | Description |\n|-----------|------|-------------|\n| `key` | Hexadecimal string | Encryption key (128, 192, or 256 bits) |\n| `In` | Hexadecimal string | Ciphertext input (128 bits) |\n| **Returns** | Hexadecimal string | Decrypted plaintext (128 bits) |\n\nThe function performs the following high-level operations [AES_update/InvCipher.m:1-28]():\n\n1. Determines key size by computing `Nk = length(key)/8` [AES_update/InvCipher.m:11]()\n2. Converts hexadecimal inputs to decimal arrays [AES_update/InvCipher.m:12]()\n3. Generates round keys using `KeyExpansion` [AES_update/InvCipher.m:13]()\n4. Reshapes input into 4×4 state array [AES_update/InvCipher.m:14]()\n5. Applies initial round key addition [AES_update/InvCipher.m:15]()\n6. Executes main decryption rounds [AES_update/InvCipher.m:16-21]()\n7. Applies final round transformations [AES_update/InvCipher.m:22-24]()\n8. Converts output back to hexadecimal format [AES_update/InvCipher.m:25-27]()\n\n**Sources:** [AES_update/InvCipher.m:1-28]()\n\n---\n\n## Decryption Round Structure\n\nThe decryption process differs from encryption in both the order of rounds and the order of transformations within each round. The number of rounds depends on the key size:\n\n| Key Size (Nk) | Total Rounds | Main Rounds | Final Round |\n|---------------|--------------|-------------|-------------|\n| 4 (AES-128) | 10 | 9 (rounds 9-1) | 1 |\n| 6 (AES-192) | 12 | 11 (rounds 11-1) | 1 |\n| 8 (AES-256) | 14 | 13 (rounds 13-1) | 1 |\n\nThe round counter `k` iterates from `(Nk+6)` down to `2` [AES_update/InvCipher.m:16](), processing rounds in reverse order compared to encryption. This ensures that the inverse operations are applied in the correct sequence to undo the encryption transformations.\n\n### Decryption Flow Diagram\n\n```mermaid\ngraph TB\n    Input[\"Ciphertext Input\u003cbr/\u003e(128-bit hex string)\"]\n    HexToDec[\"hex2dec()\u003cbr/\u003eConvert to decimal array\"]\n    Reshape[\"reshape()\u003cbr/\u003eCreate 4x4 state matrix\"]\n    KeyExp[\"KeyExpansion(key, Nk)\u003cbr/\u003eGenerate round keys\"]\n    \n    InitRound[\"AddRoundKey\u003cbr/\u003ewith w(:, 4*(Nk+6)+1:4*(Nk+7))\"]\n    \n    LoopStart{\"Main Round Loop\u003cbr/\u003ek = (Nk+6) to 2\"}\n    InvShift[\"InvShiftRows(state)\"]\n    InvSub[\"InvSubBytes(state)\"]\n    AddKey[\"AddRoundKey\u003cbr/\u003ewith w(:, 4*(k-1)+1:4*k)\"]\n    InvMix[\"InvMixColumns(state)\"]\n    \n    FinalInvShift[\"InvShiftRows(state)\"]\n    FinalInvSub[\"InvSubBytes(state)\"]\n    FinalAddKey[\"AddRoundKey\u003cbr/\u003ewith w(:, 1:4)\"]\n    \n    DecToHex[\"dec2hex()\u003cbr/\u003eConvert to hexadecimal\"]\n    Output[\"Plaintext Output\u003cbr/\u003e(128-bit hex string)\"]\n    \n    Input --\u003e HexToDec\n    HexToDec --\u003e Reshape\n    Reshape --\u003e KeyExp\n    KeyExp --\u003e InitRound\n    InitRound --\u003e LoopStart\n    \n    LoopStart --\u003e|\"Next round\"| InvShift\n    InvShift --\u003e InvSub\n    InvSub --\u003e AddKey\n    AddKey --\u003e InvMix\n    InvMix --\u003e LoopStart\n    \n    LoopStart --\u003e|\"After all rounds\"| FinalInvShift\n    FinalInvShift --\u003e FinalInvSub\n    FinalInvSub --\u003e FinalAddKey\n    FinalAddKey --\u003e DecToHex\n    DecToHex --\u003e Output\n```\n\n**Sources:** [AES_update/InvCipher.m:11-27]()\n\n---\n\n## Transformation Sequence\n\nThe decryption process applies transformations in a specific sequence that reverses the encryption operations. The key characteristic is that operations are both **inverted** (using inverse transformations) and **reordered** compared to encryption.\n\n### Initial Round\n\nBefore entering the main loop, the decryption process applies an initial `AddRoundKey` operation using the **last** round key from the key schedule [AES_update/InvCipher.m:15]():\n\n```matlab\nstate = AddRoundKey(state, w(:, 4*(Nk+6)+1:4*(Nk+7)));\n```\n\nThis corresponds to undoing the final round key addition from the encryption process.\n\n### Main Rounds\n\nEach main round (rounds `Nk+6` down to `2`) applies four transformations in the following order [AES_update/InvCipher.m:16-21]():\n\n1. **InvShiftRows**: Reverses the cyclic row shifts [AES_update/InvCipher.m:17]()\n2. **InvSubBytes**: Applies inverse S-box substitution [AES_update/InvCipher.m:18]()\n3. **AddRoundKey**: XORs with the appropriate round key [AES_update/InvCipher.m:19]()\n4. **InvMixColumns**: Reverses column mixing [AES_update/InvCipher.m:20]()\n\nNote that `AddRoundKey` is the same operation in both encryption and decryption (XOR is self-inverse), but the round keys are applied in reverse order [AES_update/AddRoundKey.m:1-5]().\n\n### Final Round\n\nAfter the main loop completes, the final round applies only three transformations [AES_update/InvCipher.m:22-24]():\n\n1. **InvShiftRows** [AES_update/InvCipher.m:22]()\n2. **InvSubBytes** [AES_update/InvCipher.m:23]()\n3. **AddRoundKey** with the **first** round key `w(:,1:4)` [AES_update/InvCipher.m:24]()\n\nThe final round omits `InvMixColumns`, mirroring the encryption process where the last round omits `MixColumns`.\n\n### Code Entity Mapping\n\n```mermaid\ngraph LR\n    subgraph \"InvCipher.m Function\"\n        InvCipherFunc[\"InvCipher(key, In)\"]\n    end\n    \n    subgraph \"Input Processing\"\n        NkCalc[\"Nk = length(key)/8\u003cbr/\u003eLine 11\"]\n        HexConv[\"hex2dec(reshape(In,2,[]))\u003cbr/\u003eLine 12\"]\n        StateInit[\"state = reshape(In, 4, [])\u003cbr/\u003eLine 14\"]\n    end\n    \n    subgraph \"Key Schedule\"\n        KeyExpCall[\"w = KeyExpansion(key, Nk)\u003cbr/\u003eLine 13\"]\n    end\n    \n    subgraph \"Round Operations\"\n        InitAddKey[\"AddRoundKey(state, w(:,4*(Nk+6)+1:4*(Nk+7)))\u003cbr/\u003eLine 15\"]\n        \n        LoopRounds[\"for k=(Nk+6):-1:2\u003cbr/\u003eLines 16-21\"]\n        \n        InvShiftCall[\"InvShiftRows(state)\u003cbr/\u003eLines 17, 22\"]\n        InvSubCall[\"InvSubBytes(state)\u003cbr/\u003eLines 18, 23\"]\n        AddKeyCall[\"AddRoundKey(state, w(...))\u003cbr/\u003eLines 19, 24\"]\n        InvMixCall[\"InvMixColumns(state)\u003cbr/\u003eLine 20\"]\n    end\n    \n    subgraph \"Output Processing\"\n        OutConv[\"dec2hex(Out)\u003cbr/\u003eLine 26\"]\n        OutFormat[\"Out = lower(...)\u003cbr/\u003eLines 26-27\"]\n    end\n    \n    InvCipherFunc --\u003e NkCalc\n    InvCipherFunc --\u003e HexConv\n    NkCalc --\u003e StateInit\n    HexConv --\u003e StateInit\n    \n    StateInit --\u003e KeyExpCall\n    KeyExpCall --\u003e InitAddKey\n    \n    InitAddKey --\u003e LoopRounds\n    LoopRounds --\u003e InvShiftCall\n    LoopRounds --\u003e InvSubCall\n    LoopRounds --\u003e AddKeyCall\n    LoopRounds --\u003e InvMixCall\n    \n    LoopRounds --\u003e OutConv\n    OutConv --\u003e OutFormat\n```\n\n**Sources:** [AES_update/InvCipher.m:11-27]()\n\n---\n\n## Comparison with Encryption\n\nThe decryption process mirrors the encryption process but with critical differences:\n\n| Aspect | Encryption (Cipher) | Decryption (InvCipher) |\n|--------|-------------------|----------------------|\n| **Round order** | Forward (1 to Nr) | Reverse (Nr to 1) |\n| **Round key order** | First to last | Last to first |\n| **Substitution** | SubBytes (S-box) | InvSubBytes (inverse S-box) |\n| **Row shifting** | ShiftRows | InvShiftRows |\n| **Column mixing** | MixColumns | InvMixColumns |\n| **Round key addition** | AddRoundKey | AddRoundKey (same) |\n| **Transformation order** | Sub→Shift→Mix→AddKey | InvShift→InvSub→AddKey→InvMix |\n\nThe reordering of transformations within decryption rounds is necessary because:\n\n1. `AddRoundKey` must be applied before `InvMixColumns` to properly reverse the encryption sequence\n2. `InvShiftRows` and `InvSubBytes` can be applied in either order (they commute), but convention places `InvShiftRows` first\n3. The final round omits `InvMixColumns` just as the encryption final round omits `MixColumns`\n\nThis specific ordering ensures that `InvCipher(key, Cipher(key, plaintext))` correctly recovers the original plaintext.\n\n### Round Key Application Order\n\n```mermaid\ngraph LR\n    subgraph \"Encryption Key Usage\"\n        E_K0[\"w(:,1:4)\u003cbr/\u003eInitial Round\"]\n        E_K1[\"w(:,5:8)\u003cbr/\u003eRound 1\"]\n        E_Dots[\"...\"]\n        E_KNr[\"w(:,4*Nr+1:4*(Nr+1))\u003cbr/\u003eFinal Round\"]\n        \n        E_K0 --\u003e E_K1\n        E_K1 --\u003e E_Dots\n        E_Dots --\u003e E_KNr\n    end\n    \n    subgraph \"Decryption Key Usage\"\n        D_KNr[\"w(:,4*Nr+1:4*(Nr+1))\u003cbr/\u003eInitial Round\u003cbr/\u003e(Line 15)\"]\n        D_Dots[\"...\"]\n        D_K1[\"w(:,5:8)\u003cbr/\u003eRound Nr-1\"]\n        D_K0[\"w(:,1:4)\u003cbr/\u003eFinal Round\u003cbr/\u003e(Line 24)\"]\n        \n        D_KNr --\u003e D_Dots\n        D_Dots --\u003e D_K1\n        D_K1 --\u003e D_K0\n    end\n    \n    E_Direction[\"Encryption Direction\"]\n    D_Direction[\"Decryption Direction\"]\n    \n    E_Direction -.-\u003e E_K0\n    D_Direction -.-\u003e D_KNr\n```\n\nThe diagram shows that decryption uses the same expanded key schedule `w` generated by `KeyExpansion`, but accesses the round keys in reverse order. The initial decryption round uses `w(:,4*(Nk+6)+1:4*(Nk+7))` which corresponds to the last encryption round key, while the final decryption round uses `w(:,1:4)` which was the initial encryption round key.\n\n**Sources:** [AES_update/InvCipher.m:15-24](), [AES_update/AddRoundKey.m:1-5]()\n\n---\n\n## Implementation Details\n\n### State Management\n\nThe `state` variable maintains the 4×4 byte array throughout the decryption process. Each transformation function modifies the state in-place and returns the updated state [AES_update/InvCipher.m:14-24]().\n\n### Round Key Extraction\n\nRound keys are extracted from the expanded key schedule `w` using MATLAB's array slicing:\n\n- Initial round: `w(:, 4*(Nk+6)+1:4*(Nk+7))` [AES_update/InvCipher.m:15]()\n- Main rounds: `w(:, 4*(k-1)+1:4*k)` for `k` from `Nk+6` to `2` [AES_update/InvCipher.m:19]()\n- Final round: `w(:, 1:4)` [AES_update/InvCipher.m:24]()\n\nEach extraction retrieves four columns (16 bytes) representing one round key.\n\n### Input/Output Format Conversion\n\nThe function handles hexadecimal string inputs and outputs:\n\n1. **Input conversion** [AES_update/InvCipher.m:12](): Reshapes the hex string into 2-character chunks and converts to decimal\n2. **Output conversion** [AES_update/InvCipher.m:25-27](): Converts decimal bytes to lowercase hexadecimal and flattens to a single string\n\nThis format matches the encryption function, ensuring compatibility between `Cipher` and `InvCipher`.\n\n**Sources:** [AES_update/InvCipher.m:11-27]()"])</script><script>self.__next_f.push([1,"22:T2278,"])</script><script>self.__next_f.push([1,"# InvSubBytes Transformation\n\n\u003cdetails\u003e\n\u003csummary\u003eRelevant source files\u003c/summary\u003e\n\nThe following files were used as context for generating this wiki page:\n\n- [AES_update/InvCipher.m](AES_update/InvCipher.m)\n- [AES_update/InvSubBytes.m](AES_update/InvSubBytes.m)\n\n\u003c/details\u003e\n\n\n\n## Purpose and Scope\n\nThe InvSubBytes transformation is the inverse operation of the SubBytes transformation used during AES decryption. It performs a non-linear byte-by-byte substitution on the state array using the inverse S-box (substitution box) lookup table. This transformation is applied in every decryption round as part of the InvCipher process.\n\nFor information about the forward SubBytes operation, see [SubBytes Transformation](#2.2.1). For the complete decryption process context, see [Decryption Process](#2.3).\n\n## Role in the Decryption Process\n\nInvSubBytes is applied twice per decryption round in the InvCipher algorithm: once after InvShiftRows in each standard round, and once in the final round before the final AddRoundKey operation.\n\n### InvSubBytes Position in InvCipher\n\n```mermaid\nflowchart TD\n    Start[\"InvCipher Entry\u003cbr/\u003estate, expanded keys w\"] --\u003e InitialRound[\"AddRoundKey\u003cbr/\u003ew[:, 4*(Nk+6)+1:4*(Nk+7)]\"]\n    \n    InitialRound --\u003e RoundLoop[\"Round Loop\u003cbr/\u003ek = (Nk+6) down to 2\"]\n    \n    RoundLoop --\u003e InvShiftRows1[\"InvShiftRows(state)\"]\n    InvShiftRows1 --\u003e InvSubBytes1[\"InvSubBytes(state)\"]\n    InvSubBytes1 --\u003e AddRoundKey1[\"AddRoundKey\u003cbr/\u003ew[:, 4*(k-1)+1:4*k]\"]\n    AddRoundKey1 --\u003e InvMixColumns[\"InvMixColumns(state)\"]\n    \n    InvMixColumns --\u003e CheckLoop{More rounds?}\n    CheckLoop --\u003e|Yes| RoundLoop\n    CheckLoop --\u003e|No| FinalRound\n    \n    FinalRound[\"Final Round\"] --\u003e InvShiftRows2[\"InvShiftRows(state)\"]\n    InvShiftRows2 --\u003e InvSubBytes2[\"InvSubBytes(state)\"]\n    InvSubBytes2 --\u003e FinalKey[\"AddRoundKey\u003cbr/\u003ew[:, 1:4]\"]\n    \n    FinalKey --\u003e Output[\"Output ciphertext\"]\n    \n    style InvSubBytes1 fill:#ffeb99\n    style InvSubBytes2 fill:#ffeb99\n```\n\n**Sources:** [AES_update/InvCipher.m:1-28]()\n\nThe diagram above shows that `InvSubBytes` is called at lines [AES_update/InvCipher.m:18]() and [AES_update/InvCipher.m:23]() within the InvCipher function. It always follows the InvShiftRows transformation and precedes either AddRoundKey (in standard rounds) or the final AddRoundKey (in the final round).\n\n## Implementation\n\nThe InvSubBytes transformation is implemented in the file [AES_update/InvSubBytes.m:1-20](). The function takes a 4×4 state matrix as input and returns the transformed state.\n\n### Function Signature\n\n```\nfunction state = InvSubBytes(state)\n```\n\n### Transformation Process\n\n```mermaid\nflowchart LR\n    subgraph Input\n        StateIn[\"state array\u003cbr/\u003e(4×4 matrix)\u003cbr/\u003evalues 0-255\"]\n    end\n    \n    subgraph LookupProcess[\"Inverse S-box Lookup\"]\n        AddOne[\"Add 1 to each byte\u003cbr/\u003e(MATLAB 1-indexing)\"]\n        Lookup[\"Sbox(state+1)\u003cbr/\u003e256-element lookup\"]\n    end\n    \n    subgraph Output\n        StateOut[\"transformed state\u003cbr/\u003e(4×4 matrix)\u003cbr/\u003esubstituted values\"]\n    end\n    \n    StateIn --\u003e AddOne\n    AddOne --\u003e Lookup\n    Lookup --\u003e StateOut\n```\n\n**Sources:** [AES_update/InvSubBytes.m:1-20]()\n\nThe transformation operates as follows:\n1. Each byte value in the state (range 0-255) is used as an index into the inverse S-box\n2. MATLAB uses 1-based indexing, so 1 is added to each state value: `Sbox(state+1)` [AES_update/InvSubBytes.m:19]()\n3. The resulting substituted values replace the original state bytes\n\n## Inverse S-box Lookup Table\n\nThe inverse S-box is defined as a 256-element lookup table stored as a 16×16 matrix. The table is hardcoded in hexadecimal format and converted to decimal values for indexing.\n\n### S-box Structure\n\n| Property | Value |\n|----------|-------|\n| Dimensions | 16 × 16 |\n| Total elements | 256 |\n| Index range | 0-255 (stored as 1-256 in MATLAB) |\n| Value range | 0-255 |\n| Definition | Lines 2-17 in InvSubBytes.m |\n\n### S-box Construction\n\n```mermaid\nflowchart TD\n    HexString[\"Hexadecimal string array\u003cbr/\u003e16 rows of 32 hex characters\u003cbr/\u003elines 2-17\"]\n    \n    Reshape1[\"Transpose and reshape\u003cbr/\u003eSbox' → 2-char chunks\"]\n    \n    HexToDec[\"hex2dec conversion\u003cbr/\u003e512 hex pairs → 256 decimal values\"]\n    \n    Reshape2[\"Reshape to 16×16 matrix\u003cbr/\u003eSbox = reshape(..., 16, 16)\"]\n    \n    Final[\"Final Sbox matrix\u003cbr/\u003eready for lookup\"]\n    \n    HexString --\u003e Reshape1\n    Reshape1 --\u003e HexToDec\n    HexToDec --\u003e Reshape2\n    Reshape2 --\u003e Final\n```\n\n**Sources:** [AES_update/InvSubBytes.m:2-18]()\n\nThe inverse S-box initialization occurs at [AES_update/InvSubBytes.m:2-18]():\n1. A 16-line hexadecimal string defines all 256 inverse S-box values\n2. The string is reshaped and transposed to separate individual byte pairs\n3. `hex2dec` converts the hexadecimal pairs to decimal integers\n4. The resulting 256 values are reshaped into a 16×16 matrix\n\n### Example S-box Values\n\nThe first row of the inverse S-box (indices 0x00-0x0F) contains the values:\n```\n52 09 6A D5 30 36 A5 38 BF 40 A3 9E 81 F3 D7 FB (hex)\n```\n\nThese values represent the inverse substitution mappings defined by the AES standard (FIPS-197).\n\n## Byte-Level Transformation\n\n### State Array Transformation\n\n```mermaid\nflowchart LR\n    subgraph InputState[\"Input State (4×4)\"]\n        direction TB\n        I00[\"s[0,0]\"] \n        I01[\"s[0,1]\"]\n        I02[\"s[0,2]\"]\n        I03[\"s[0,3]\"]\n        I10[\"s[1,0]\"]\n        I11[\"...\"]\n        I20[\"...\"]\n        I30[\"s[3,3]\"]\n    end\n    \n    subgraph Transformation[\"InvSubBytes Operation\"]\n        direction TB\n        SboxLookup[\"For each byte b:\u003cbr/\u003eresult = Sbox[b + 1]\"]\n    end\n    \n    subgraph OutputState[\"Output State (4×4)\"]\n        direction TB\n        O00[\"Sbox[s[0,0]+1]\"]\n        O01[\"Sbox[s[0,1]+1]\"]\n        O02[\"Sbox[s[0,2]+1]\"]\n        O03[\"Sbox[s[0,3]+1]\"]\n        O10[\"Sbox[s[1,0]+1]\"]\n        O11[\"...\"]\n        O20[\"...\"]\n        O30[\"Sbox[s[3,3]+1]\"]\n    end\n    \n    InputState --\u003e Transformation\n    Transformation --\u003e OutputState\n```\n\n**Sources:** [AES_update/InvSubBytes.m:19]()\n\nEach of the 16 bytes in the 4×4 state matrix undergoes independent substitution. The operation is purely element-wise with no interaction between bytes.\n\n## Relationship to Forward SubBytes\n\nThe InvSubBytes transformation is designed to be the exact inverse of the SubBytes transformation used in encryption. When applied in sequence, these operations cancel each other:\n\n**Property:** `InvSubBytes(SubBytes(state)) = state`\n\nThe inverse S-box table is mathematically constructed such that:\n- If forward S-box maps value `x` to value `y`\n- Then inverse S-box maps value `y` back to value `x`\n\nThis ensures that the decryption process correctly reverses the encryption transformations.\n\n## Usage Context\n\n### Integration in InvCipher Rounds\n\nThe InvSubBytes function is called at two specific points in the InvCipher algorithm:\n\n| Call Location | Context | Line Reference |\n|---------------|---------|----------------|\n| Standard rounds | After InvShiftRows, before AddRoundKey + InvMixColumns | [AES_update/InvCipher.m:18]() |\n| Final round | After InvShiftRows, before final AddRoundKey | [AES_update/InvCipher.m:23]() |\n\n### Round Structure\n\nFor AES-128 (Nk=4), InvSubBytes is called:\n- 9 times in the main round loop (rounds 10 down to 2)\n- 1 time in the final round (round 1)\n- **Total: 10 times** per decryption\n\nFor AES-192 and AES-256, the number of calls increases proportionally with the number of rounds.\n\n## Implementation Details\n\n### MATLAB-Specific Considerations\n\nThe implementation includes several MATLAB-specific features:\n\n| Feature | Implementation | Rationale |\n|---------|---------------|-----------|\n| 1-based indexing | `Sbox(state+1)` | MATLAB arrays start at index 1, not 0 |\n| Vectorized operation | Single line: `state=Sbox(state+1)` | MATLAB efficiently handles matrix indexing |\n| Hardcoded S-box | Defined as string literal | Avoids runtime computation of inverse S-box |\n\n**Sources:** [AES_update/InvSubBytes.m:19]()\n\n### Performance Characteristics\n\n- **Time Complexity:** O(1) per byte, O(16) for entire state\n- **Space Complexity:** O(256) for S-box storage (constant)\n- **Operation Type:** Pure lookup table (no computation required)\n\n## Code Entity Reference\n\n### Function: `InvSubBytes`\n\n**Definition:** [AES_update/InvSubBytes.m:1]()\n\n**Input:**\n- `state`: 4×4 matrix of byte values (0-255)\n\n**Output:**\n- `state`: 4×4 matrix after inverse S-box substitution\n\n**Called by:**\n- `InvCipher` at [AES_update/InvCipher.m:18]() and [AES_update/InvCipher.m:23]()\n\n### Variable: `Sbox`\n\n**Definition:** [AES_update/InvSubBytes.m:2-18]()\n\n**Type:** 16×16 matrix of decimal integers (0-255)\n\n**Purpose:** Lookup table for inverse byte substitution as defined by AES/FIPS-197 standard\n\n**Sources:** [AES_update/InvSubBytes.m:1-20](), [AES_update/InvCipher.m:1-28]()"])</script><script>self.__next_f.push([1,"23:T2014,"])</script><script>self.__next_f.push([1,"# InvShiftRows Transformation\n\n\u003cdetails\u003e\n\u003csummary\u003eRelevant source files\u003c/summary\u003e\n\nThe following files were used as context for generating this wiki page:\n\n- [AES_update/InvCipher.m](AES_update/InvCipher.m)\n- [AES_update/InvShiftRows.m](AES_update/InvShiftRows.m)\n\n\u003c/details\u003e\n\n\n\nThis document explains the `InvShiftRows` transformation, which is one of the four inverse round operations in the AES decryption process. It performs the inverse of the ShiftRows operation by cyclically shifting the rows of the AES state matrix to the right instead of to the left.\n\n**Related pages:** For information about the forward ShiftRows operation, see [2.2.2](#2.2.2). For the complete decryption process context, see [2.3](#2.3).\n\n## Purpose and Operation\n\nThe `InvShiftRows` function reverses the row permutation applied by the forward `ShiftRows` transformation. In AES, the state is represented as a 4×4 matrix of bytes. The `InvShiftRows` operation cyclically shifts each row to the right by a specific offset:\n\n| Row | Shift Amount | Direction |\n|-----|--------------|-----------|\n| Row 1 | 0 bytes | No shift |\n| Row 2 | 1 byte | Right |\n| Row 3 | 2 bytes | Right |\n| Row 4 | 3 bytes | Right |\n\nThis right-shifting pattern is the inverse of the forward ShiftRows operation, which shifts rows to the left by the same amounts (or equivalently, shifts right by complementary amounts).\n\nSources: [AES_update/InvShiftRows.m:1-5]()\n\n## Implementation\n\nThe `InvShiftRows` function is implemented in a single function file that operates directly on the AES state matrix.\n\n### Function Signature\n\n```\nfunction state = InvShiftRows(state)\n```\n\n**Input:** `state` - A 4×4 matrix representing the current AES state (16 bytes arranged in column-major order)\n\n**Output:** `state` - The same 4×4 matrix with rows cyclically shifted according to the inverse ShiftRows pattern\n\nSources: [AES_update/InvShiftRows.m:1]()\n\n### State Transformation Logic\n\nThe implementation uses MATLAB's `circshift` function to perform the circular shifts on each row:\n\n| Operation | Code | Effect |\n|-----------|------|--------|\n| Row 2 shift | `state(2,:)=circshift(state(2,:),[0 1])` | Shift row 2 right by 1 position |\n| Row 3 shift | `state(3,:)=circshift(state(3,:),[0 2])` | Shift row 3 right by 2 positions |\n| Row 4 shift | `state(4,:)=circshift(state(4,:),[0 3])` | Shift row 4 right by 3 positions |\n\nRow 1 (index 1 in MATLAB) remains unchanged, as no operation is performed on it.\n\nThe `circshift` function with parameters `[0 N]` shifts the array elements along the second dimension (columns) by N positions to the right, with wraparound at the boundaries.\n\nSources: [AES_update/InvShiftRows.m:2-4]()\n\n## Visual Representation of the Transformation\n\n### InvShiftRows Byte Movement Pattern\n\n```mermaid\ngraph LR\n    subgraph \"Input State\"\n        I00[\"s0,0\"]\n        I01[\"s0,1\"]\n        I02[\"s0,2\"]\n        I03[\"s0,3\"]\n        I10[\"s1,0\"]\n        I11[\"s1,1\"]\n        I12[\"s1,2\"]\n        I13[\"s1,3\"]\n        I20[\"s2,0\"]\n        I21[\"s2,1\"]\n        I22[\"s2,2\"]\n        I23[\"s2,3\"]\n        I30[\"s3,0\"]\n        I31[\"s3,1\"]\n        I32[\"s3,2\"]\n        I33[\"s3,3\"]\n    end\n    \n    subgraph \"Output State\"\n        O00[\"s0,0\"]\n        O01[\"s0,1\"]\n        O02[\"s0,2\"]\n        O03[\"s0,3\"]\n        O10[\"s1,3\"]\n        O11[\"s1,0\"]\n        O12[\"s1,1\"]\n        O13[\"s1,2\"]\n        O20[\"s2,2\"]\n        O21[\"s2,3\"]\n        O22[\"s2,0\"]\n        O23[\"s2,1\"]\n        O30[\"s3,1\"]\n        O31[\"s3,2\"]\n        O32[\"s3,3\"]\n        O33[\"s3,0\"]\n    end\n    \n    I00 --\u003e O00\n    I01 --\u003e O01\n    I02 --\u003e O02\n    I03 --\u003e O03\n    \n    I10 --\u003e O11\n    I11 --\u003e O12\n    I12 --\u003e O13\n    I13 --\u003e O10\n    \n    I20 --\u003e O22\n    I21 --\u003e O23\n    I22 --\u003e O20\n    I23 --\u003e O21\n    \n    I30 --\u003e O33\n    I31 --\u003e O30\n    I32 --\u003e O31\n    I33 --\u003e O32\n```\n\nThis diagram illustrates how each byte in the input state matrix is repositioned in the output state. Row 1 bytes remain in place, row 2 bytes shift right by 1, row 3 bytes shift right by 2, and row 4 bytes shift right by 3 positions with wraparound.\n\nSources: [AES_update/InvShiftRows.m:1-5]()\n\n## Integration in the Decryption Process\n\nThe `InvShiftRows` transformation is called multiple times during the AES decryption process within the `InvCipher` function.\n\n### Call Sites in InvCipher\n\n```mermaid\ngraph TD\n    Start[\"InvCipher Entry\"] --\u003e InitKey[\"AddRoundKey with final round key\"]\n    InitKey --\u003e LoopStart[\"Round Loop: k = Nk+6 down to 2\"]\n    \n    LoopStart --\u003e ISR1[\"InvShiftRows(state)\"]\n    ISR1 --\u003e ISB1[\"InvSubBytes(state)\"]\n    ISB1 --\u003e ARK1[\"AddRoundKey(state, w)\"]\n    ARK1 --\u003e IMC[\"InvMixColumns(state)\"]\n    IMC --\u003e LoopCheck{\"More rounds?\"}\n    LoopCheck --\u003e|Yes| ISR1\n    LoopCheck --\u003e|No| FinalISR[\"InvShiftRows(state)\"]\n    \n    FinalISR --\u003e FinalISB[\"InvSubBytes(state)\"]\n    FinalISB --\u003e FinalARK[\"AddRoundKey with initial key\"]\n    FinalARK --\u003e Output[\"Return decrypted output\"]\n```\n\nThe function is invoked at two distinct points:\n\n1. **Within the main round loop** ([AES_update/InvCipher.m:17]()):\n   - Called at the start of each round (rounds Nk+6 down to 2)\n   - Immediately followed by `InvSubBytes`\n   - Part of the four-operation sequence: InvShiftRows → InvSubBytes → AddRoundKey → InvMixColumns\n\n2. **After the final round** ([AES_update/InvCipher.m:22]()):\n   - Called before the final `InvSubBytes` operation\n   - The final round omits `InvMixColumns`, so the sequence is: InvShiftRows → InvSubBytes → AddRoundKey\n\nSources: [AES_update/InvCipher.m:16-24]()\n\n### Execution Context\n\n```mermaid\ngraph LR\n    subgraph \"InvCipher Function Flow\"\n        W[\"w = KeyExpansion(key, Nk)\"] --\u003e Init[\"state = AddRoundKey(state, final_round_key)\"]\n        \n        Init --\u003e R1[\"Round Loop Iteration\"]\n        \n        R1 --\u003e ISR[\"InvShiftRows.m\u003cbr/\u003eLine 2-4: circshift operations\"]\n        ISR --\u003e ISB[\"InvSubBytes.m\"]\n        ISB --\u003e ARK[\"AddRoundKey.m\"]\n        ARK --\u003e IMC[\"InvMixColumns.m\"]\n        \n        IMC --\u003e NextR{\"Next Round?\"}\n        NextR --\u003e|Yes| R1\n        NextR --\u003e|No| FinalRound[\"Final Round\"]\n        \n        FinalRound --\u003e FISR[\"InvShiftRows.m\u003cbr/\u003eLine 2-4: circshift operations\"]\n        FISR --\u003e FISB[\"InvSubBytes.m\"]\n        FISB --\u003e FARK[\"AddRoundKey.m\"]\n        FARK --\u003e Done[\"Output\"]\n    end\n```\n\nThis diagram shows the complete execution flow within `InvCipher`, highlighting where `InvShiftRows` is invoked and how it integrates with other inverse transformations. The function is called once per round plus once more in the final round.\n\nSources: [AES_update/InvCipher.m:1-28](), [AES_update/InvShiftRows.m:1-5]()\n\n## Technical Characteristics\n\n### Computational Complexity\n\nThe `InvShiftRows` operation has the following characteristics:\n\n- **Time Complexity:** O(1) - Fixed number of operations regardless of key size\n- **Space Complexity:** O(1) - Operates in-place on the state matrix\n- **Operations:** 3 circular shift operations (one per modified row)\n- **No lookups:** Unlike SubBytes, this operation does not require any lookup tables\n\n### Reversibility\n\nThe `InvShiftRows` operation is perfectly reversible:\n- Applying `ShiftRows` followed by `InvShiftRows` returns the original state\n- Applying `InvShiftRows` followed by `ShiftRows` returns the original state\n\nMathematically, if we denote ShiftRows as SR and InvShiftRows as ISR:\n- ISR(SR(state)) = state\n- SR(ISR(state)) = state\n\nThis property is essential for AES decryption to correctly reverse the encryption process.\n\nSources: [AES_update/InvShiftRows.m:1-5]()\n\n## Relationship to Forward Transformation\n\nThe `InvShiftRows` operation is the exact inverse of the `ShiftRows` operation (see [2.2.2](#2.2.2)). The relationship can be expressed as:\n\n| Transformation | Row 1 | Row 2 | Row 3 | Row 4 |\n|----------------|-------|-------|-------|-------|\n| **ShiftRows** (forward) | 0 left | 1 left | 2 left | 3 left |\n| **InvShiftRows** (inverse) | 0 right | 1 right | 2 right | 3 right |\n\nSince a left shift by N positions is equivalent to a right shift by (4-N) positions in a 4-element row, the inverse relationship is maintained. However, the implementation uses explicit right shifts for clarity and direct correspondence to the AES specification.\n\nSources: [AES_update/InvShiftRows.m:1-5]()"])</script><script>self.__next_f.push([1,"24:T2e8b,"])</script><script>self.__next_f.push([1,"# InvMixColumns Transformation\n\n\u003cdetails\u003e\n\u003csummary\u003eRelevant source files\u003c/summary\u003e\n\nThe following files were used as context for generating this wiki page:\n\n- [AES_update/InvCipher.m](AES_update/InvCipher.m)\n- [AES_update/InvMixColumns.m](AES_update/InvMixColumns.m)\n- [AES_update/xtime.m](AES_update/xtime.m)\n\n\u003c/details\u003e\n\n\n\n## Purpose and Scope\n\nThis page documents the `InvMixColumns` transformation, which is the inverse of the MixColumns operation used in AES encryption. The InvMixColumns transformation is applied during the AES decryption process to reverse the column-mixing diffusion that was performed during encryption. This operation uses Galois field GF(2^8) arithmetic to multiply each column of the state matrix by a fixed inverse transformation matrix.\n\nFor information about the forward MixColumns operation, see [MixColumns Transformation](#2.2.3). For details on the underlying Galois field multiplication, see [Galois Field Arithmetic](#2.4). For the complete decryption process context, see [Decryption Process](#2.3).\n\n**Sources:** [AES_update/InvMixColumns.m:1-9]()\n\n## Mathematical Foundation\n\nThe InvMixColumns transformation operates on the 4×4 state matrix by treating each column as a four-term polynomial in GF(2^8) and multiplying it by a fixed inverse polynomial modulo x^4 + 1. This operation reverses the column mixing performed by MixColumns during encryption.\n\n### Inverse Transformation Matrix\n\nEach column of the state is multiplied by the following fixed matrix in GF(2^8):\n\n| Column 0 | Column 1 | Column 2 | Column 3 |\n|----------|----------|----------|----------|\n| 0x0E     | 0x0B     | 0x0D     | 0x09     |\n| 0x09     | 0x0E     | 0x0B     | 0x0D     |\n| 0x0D     | 0x09     | 0x0E     | 0x0B     |\n| 0x0B     | 0x0D     | 0x09     | 0x0E     |\n\nWhere:\n- `0x0E` = 14 (decimal)\n- `0x0B` = 11 (decimal)\n- `0x0D` = 13 (decimal)\n- `0x09` = 9 (decimal)\n\nFor a column `[s(0), s(1), s(2), s(3)]`, the transformation produces:\n\n```\ns'(0) = (0x0E • s(0)) ⊕ (0x0B • s(1)) ⊕ (0x0D • s(2)) ⊕ (0x09 • s(3))\ns'(1) = (0x09 • s(0)) ⊕ (0x0E • s(1)) ⊕ (0x0B • s(2)) ⊕ (0x0D • s(3))\ns'(2) = (0x0D • s(0)) ⊕ (0x09 • s(1)) ⊕ (0x0E • s(2)) ⊕ (0x0B • s(3))\ns'(3) = (0x0B • s(0)) ⊕ (0x0D • s(1)) ⊕ (0x09 • s(2)) ⊕ (0x0E • s(3))\n```\n\nWhere `•` denotes multiplication in GF(2^8) and `⊕` denotes bitwise XOR.\n\n**Sources:** [AES_update/InvMixColumns.m:1-9]()\n\n## State Matrix Column Processing\n\n```mermaid\ngraph TD\n    State[\"State Matrix\u003cbr/\u003e(4x4 bytes)\"]\n    \n    Col0[\"Column 0\u003cbr/\u003estate[0,4,8,12]\"]\n    Col1[\"Column 1\u003cbr/\u003estate[1,5,9,13]\"]\n    Col2[\"Column 2\u003cbr/\u003estate[2,6,10,14]\"]\n    Col3[\"Column 3\u003cbr/\u003estate[3,7,11,15]\"]\n    \n    Transform0[\"InvMixColumns\u003cbr/\u003eMatrix Multiply\u003cbr/\u003ein GF(2^8)\"]\n    Transform1[\"InvMixColumns\u003cbr/\u003eMatrix Multiply\u003cbr/\u003ein GF(2^8)\"]\n    Transform2[\"InvMixColumns\u003cbr/\u003eMatrix Multiply\u003cbr/\u003ein GF(2^8)\"]\n    Transform3[\"InvMixColumns\u003cbr/\u003eMatrix Multiply\u003cbr/\u003ein GF(2^8)\"]\n    \n    NewCol0[\"State'[0,4,8,12]\"]\n    NewCol1[\"State'[1,5,9,13]\"]\n    NewCol2[\"State'[2,6,10,14]\"]\n    NewCol3[\"State'[3,7,11,15]\"]\n    \n    NewState[\"Transformed State\u003cbr/\u003e(4x4 bytes)\"]\n    \n    State --\u003e Col0\n    State --\u003e Col1\n    State --\u003e Col2\n    State --\u003e Col3\n    \n    Col0 --\u003e Transform0\n    Col1 --\u003e Transform1\n    Col2 --\u003e Transform2\n    Col3 --\u003e Transform3\n    \n    Transform0 --\u003e NewCol0\n    Transform1 --\u003e NewCol1\n    Transform2 --\u003e NewCol2\n    Transform3 --\u003e NewCol3\n    \n    NewCol0 --\u003e NewState\n    NewCol1 --\u003e NewState\n    NewCol2 --\u003e NewState\n    NewCol3 --\u003e NewState\n```\n\n**Sources:** [AES_update/InvMixColumns.m:3-8]()\n\n## Implementation Details\n\n### Function Signature\n\nThe `InvMixColumns` function is implemented in [AES_update/InvMixColumns.m:1-9]() with the signature:\n\n```matlab\nfunction State = InvMixColumns(state)\n```\n\n**Input:** `state` - A 16-element vector representing the 4×4 state matrix in column-major order  \n**Output:** `State` - The transformed state after applying inverse column mixing\n\n### Column-by-Column Processing Loop\n\nThe implementation processes the state matrix one column at a time using a loop that iterates over column starting indices `[1, 5, 9, 13]`:\n\n```mermaid\ngraph LR\n    subgraph \"Loop Iteration a=1\"\n        S1_0[\"state(1)\"]\n        S1_1[\"state(2)\"]\n        S1_2[\"state(3)\"]\n        S1_3[\"state(4)\"]\n        \n        T1[\"Column 0\u003cbr/\u003eTransform\"]\n        \n        Out1_0[\"State(1)\"]\n        Out1_1[\"State(2)\"]\n        Out1_2[\"State(3)\"]\n        Out1_3[\"State(4)\"]\n        \n        S1_0 --\u003e T1\n        S1_1 --\u003e T1\n        S1_2 --\u003e T1\n        S1_3 --\u003e T1\n        \n        T1 --\u003e Out1_0\n        T1 --\u003e Out1_1\n        T1 --\u003e Out1_2\n        T1 --\u003e Out1_3\n    end\n    \n    subgraph \"Loop Iteration a=5\"\n        S2_0[\"state(5)\"]\n        S2_1[\"state(6)\"]\n        S2_2[\"state(7)\"]\n        S2_3[\"state(8)\"]\n        \n        T2[\"Column 1\u003cbr/\u003eTransform\"]\n        \n        Out2_0[\"State(5)\"]\n        Out2_1[\"State(6)\"]\n        Out2_2[\"State(7)\"]\n        Out2_3[\"State(8)\"]\n        \n        S2_0 --\u003e T2\n        S2_1 --\u003e T2\n        S2_2 --\u003e T2\n        S2_3 --\u003e T2\n        \n        T2 --\u003e Out2_0\n        T2 --\u003e Out2_1\n        T2 --\u003e Out2_2\n        T2 --\u003e Out2_3\n    end\n```\n\n**Sources:** [AES_update/InvMixColumns.m:3-8]()\n\n### Galois Field Multiplication via xtime\n\nEach element of the output column is computed using the `xtime` function for Galois field multiplication. The implementation at [AES_update/InvMixColumns.m:4-7]() applies the following transformations for each column starting at index `a`:\n\n| Output Element | Formula |\n|---------------|---------|\n| `State(a)`    | `xtime(state(a),14) ⊕ xtime(state(a+1),11) ⊕ xtime(state(a+2),13) ⊕ xtime(state(a+3),9)` |\n| `State(a+1)`  | `xtime(state(a),9) ⊕ xtime(state(a+1),14) ⊕ xtime(state(a+2),11) ⊕ xtime(state(a+3),13)` |\n| `State(a+2)`  | `xtime(state(a),13) ⊕ xtime(state(a+1),9) ⊕ xtime(state(a+2),14) ⊕ xtime(state(a+3),11)` |\n| `State(a+3)`  | `xtime(state(a),11) ⊕ xtime(state(a+1),13) ⊕ xtime(state(a+2),9) ⊕ xtime(state(a+3),14)` |\n\nWhere `⊕` represents the `bitxor` operation and `xtime(x,c)` performs multiplication of `x` by `c` in GF(2^8).\n\n**Sources:** [AES_update/InvMixColumns.m:4-7](), [AES_update/xtime.m:1-18]()\n\n### Code Entity Mapping\n\n```mermaid\ngraph TB\n    subgraph \"InvMixColumns.m Function\"\n        Entry[\"function State = InvMixColumns(state)\"]\n        Init[\"State=state\"]\n        Loop[\"for a=1:4:13\"]\n        \n        Compute0[\"State(a) = bitxor(bitxor(bitxor(\u003cbr/\u003extime(state(a),14),\u003cbr/\u003extime(state(a+1),11)),\u003cbr/\u003extime(state(a+2),13)),\u003cbr/\u003extime(state(a+3),9))\"]\n        \n        Compute1[\"State(a+1) = bitxor(bitxor(bitxor(\u003cbr/\u003extime(state(a),9),\u003cbr/\u003extime(state(a+1),14)),\u003cbr/\u003extime(state(a+2),11)),\u003cbr/\u003extime(state(a+3),13))\"]\n        \n        Compute2[\"State(a+2) = bitxor(bitxor(bitxor(\u003cbr/\u003extime(state(a),13),\u003cbr/\u003extime(state(a+1),9)),\u003cbr/\u003extime(state(a+2),14)),\u003cbr/\u003extime(state(a+3),11))\"]\n        \n        Compute3[\"State(a+3) = bitxor(bitxor(bitxor(\u003cbr/\u003extime(state(a),11),\u003cbr/\u003extime(state(a+1),13)),\u003cbr/\u003extime(state(a+2),9)),\u003cbr/\u003extime(state(a+3),14))\"]\n        \n        EndLoop[\"end\"]\n        Return[\"return State\"]\n    end\n    \n    subgraph \"xtime.m Dependency\"\n        Xtime[\"function a = xtime(x,c)\u003cbr/\u003eGF(2^8) multiplication\"]\n    end\n    \n    Entry --\u003e Init\n    Init --\u003e Loop\n    Loop --\u003e Compute0\n    Compute0 --\u003e Compute1\n    Compute1 --\u003e Compute2\n    Compute2 --\u003e Compute3\n    Compute3 --\u003e EndLoop\n    EndLoop --\u003e Return\n    \n    Compute0 -.-\u003e|\"calls\"| Xtime\n    Compute1 -.-\u003e|\"calls\"| Xtime\n    Compute2 -.-\u003e|\"calls\"| Xtime\n    Compute3 -.-\u003e|\"calls\"| Xtime\n```\n\n**Sources:** [AES_update/InvMixColumns.m:1-9](), [AES_update/xtime.m:1-18]()\n\n## Integration with InvCipher Decryption\n\nThe `InvMixColumns` transformation is applied during each round of the AES decryption process, except for the final round. Within the `InvCipher` function at [AES_update/InvCipher.m:1-28](), the transformation appears at line 20.\n\n### Decryption Round Structure\n\n```mermaid\ngraph TD\n    Start[\"InvCipher Entry\u003cbr/\u003estate, round keys w\"]\n    \n    InitKey[\"AddRoundKey\u003cbr/\u003ewith final round key\u003cbr/\u003ew(:,4*(Nk+6)+1:4*(Nk+7))\"]\n    \n    LoopStart[\"Round Loop\u003cbr/\u003ek=(Nk+6):-1:2\"]\n    \n    Step1[\"InvShiftRows(state)\"]\n    Step2[\"InvSubBytes(state)\"]\n    Step3[\"AddRoundKey(state,\u003cbr/\u003ew(:,4*(k-1)+1:4*k))\"]\n    Step4[\"InvMixColumns(state)\"]\n    \n    LoopEnd[\"Loop End\"]\n    \n    Final1[\"InvShiftRows(state)\"]\n    Final2[\"InvSubBytes(state)\"]\n    Final3[\"AddRoundKey(state, w(:,1:4))\"]\n    \n    Output[\"Return decrypted state\"]\n    \n    Start --\u003e InitKey\n    InitKey --\u003e LoopStart\n    LoopStart --\u003e Step1\n    Step1 --\u003e Step2\n    Step2 --\u003e Step3\n    Step3 --\u003e Step4\n    Step4 --\u003e LoopEnd\n    LoopEnd --\u003e|\"more rounds\"| LoopStart\n    LoopEnd --\u003e|\"done\"| Final1\n    Final1 --\u003e Final2\n    Final2 --\u003e Final3\n    Final3 --\u003e Output\n```\n\n**Note:** The final round (lines 22-24) applies `InvShiftRows`, `InvSubBytes`, and `AddRoundKey`, but **does not** apply `InvMixColumns`. This mirrors the encryption process where the final round omits the `MixColumns` transformation.\n\n**Sources:** [AES_update/InvCipher.m:15-24]()\n\n### Round Transformation Order\n\nWithin each non-final round at [AES_update/InvCipher.m:16-21](), the transformations are applied in this specific order:\n\n1. **InvShiftRows** (line 17) - Reverse the row shifts\n2. **InvSubBytes** (line 18) - Reverse the S-box substitution\n3. **AddRoundKey** (line 19) - XOR with round key\n4. **InvMixColumns** (line 20) - Reverse the column mixing\n\nThis order is the inverse of the encryption round structure, applied in reverse.\n\n**Sources:** [AES_update/InvCipher.m:16-21]()\n\n## Relationship to Forward MixColumns\n\nThe InvMixColumns transformation is the mathematical inverse of the MixColumns operation used during encryption. When the InvMixColumns matrix is multiplied by the MixColumns matrix in GF(2^8), the result is the identity matrix, ensuring that:\n\n```\nInvMixColumns(MixColumns(state)) = state\n```\n\n### Matrix Coefficient Correspondence\n\n| Forward MixColumns | Inverse MixColumns |\n|-------------------|-------------------|\n| 0x02, 0x03        | 0x0E, 0x0B        |\n| Circulant pattern | Circulant pattern |\n| Applied during encryption | Applied during decryption |\n\nThe coefficients 14 (0x0E), 11 (0x0B), 13 (0x0D), and 9 (0x09) used in InvMixColumns were mathematically derived to satisfy the inverse relationship in GF(2^8) arithmetic.\n\n**Sources:** [AES_update/InvMixColumns.m:1-9]()\n\n## Performance Characteristics\n\nThe `InvMixColumns` function has the following computational characteristics:\n\n| Metric | Value |\n|--------|-------|\n| Loop iterations | 4 (one per column) |\n| `xtime` calls per iteration | 16 (4 per output element × 4 elements) |\n| Total `xtime` calls | 64 per state transformation |\n| `bitxor` operations per element | 3 (nested XORs) |\n| Total `bitxor` operations | 48 per state transformation |\n\nEach call to `xtime` involves bit operations and conditional XOR with the irreducible polynomial (0x1B), making InvMixColumns one of the more computationally intensive steps in the decryption process.\n\n**Sources:** [AES_update/InvMixColumns.m:3-8](), [AES_update/xtime.m:1-18]()\n\n## Summary\n\nThe `InvMixColumns` transformation is a critical component of AES decryption that reverses the diffusion performed during encryption. It operates on each column of the state matrix independently, using Galois field GF(2^8) arithmetic with fixed multiplication coefficients (14, 11, 13, 9). The transformation relies on the `xtime` function for efficient Galois field multiplication and is applied in every decryption round except the final one. The implementation processes 16 bytes of state through 64 Galois field multiplications and 48 XOR operations to restore the original column structure.\n\n**Sources:** [AES_update/InvMixColumns.m:1-9](), [AES_update/InvCipher.m:1-28](), [AES_update/xtime.m:1-18]()"])</script><script>self.__next_f.push([1,"25:T284e,"])</script><script>self.__next_f.push([1,"# Galois Field Arithmetic\n\n\u003cdetails\u003e\n\u003csummary\u003eRelevant source files\u003c/summary\u003e\n\nThe following files were used as context for generating this wiki page:\n\n- [AES_update/InvMixColumns.m](AES_update/InvMixColumns.m)\n- [AES_update/MixColumns.m](AES_update/MixColumns.m)\n- [AES_update/xtime.m](AES_update/xtime.m)\n\n\u003c/details\u003e\n\n\n\n## Purpose and Scope\n\nThis page documents the Galois field arithmetic operations used in the AES encryption system, specifically the multiplication operations in GF(2^8) implemented by the `xtime` function. This mathematical foundation is essential for the MixColumns and InvMixColumns transformations. For information about how these operations are used in the encryption process, see [MixColumns Transformation](#2.2.3) and [InvMixColumns Transformation](#2.3.3).\n\n## Overview\n\nAES operations, particularly the MixColumns transformation, require arithmetic in the Galois field GF(2^8), also known as a finite field with 256 elements. In this field, addition is performed using XOR, and multiplication follows special rules defined by an irreducible polynomial. The AES standard uses the polynomial:\n\n**m(x) = x^8 + x^4 + x^3 + x + 1** (represented as 0x11B in hexadecimal)\n\nAll byte values in AES can be viewed as polynomials of degree less than 8, where each bit represents a coefficient (0 or 1).\n\nSources: [AES_update/xtime.m:1-18]()\n\n## The xtime Function\n\n### Function Signature\n\nThe `xtime` function implements Galois field multiplication in GF(2^8):\n\n```matlab\nfunction a = xtime(x,c)\n```\n\n**Parameters:**\n- `x`: The multiplier (treated as a polynomial representation)\n- `c`: The multiplicand (the byte value to be multiplied)\n\n**Returns:**\n- `a`: The product in GF(2^8)\n\nSources: [AES_update/xtime.m:1]()\n\n### Implementation Architecture\n\n```mermaid\ngraph TD\n    START[\"xtime(x, c)\"] --\u003e INIT[\"Initialize result a = 0\"]\n    INIT --\u003e CHECK1[\"Check LSB of x\u003cbr/\u003ebitget(x, 1)\"]\n    CHECK1 --\u003e|\"LSB = 1\"| SET[\"Set a = c\"]\n    CHECK1 --\u003e|\"LSB = 0\"| SHIFT1[\"Shift x right\u003cbr/\u003ex = bitshift(x, -1)\"]\n    SET --\u003e SHIFT1\n    \n    SHIFT1 --\u003e LOOP{\"x \u003e 0?\"}\n    LOOP --\u003e|\"No\"| RETURN[\"Return a\"]\n    \n    LOOP --\u003e|\"Yes\"| LEFTSHIFT[\"Left shift c\u003cbr/\u003ec = bitshift(c, 1)\"]\n    LEFTSHIFT --\u003e OVERFLOW{\"Bit 9 set?\u003cbr/\u003ebitget(c, 9)\"}\n    \n    OVERFLOW --\u003e|\"Yes\"| CLEAR[\"Clear bit 9\u003cbr/\u003ebitset(c, 9, 0)\"]\n    OVERFLOW --\u003e|\"No\"| CHECKBIT\n    CLEAR --\u003e REDUCE[\"XOR with 0x1B\u003cbr/\u003ec = bitxor(c, 27)\"]\n    REDUCE --\u003e CHECKBIT[\"Check LSB of x\u003cbr/\u003ebitget(x, 1)\"]\n    \n    CHECKBIT --\u003e|\"LSB = 1\"| ACCUMULATE[\"Accumulate result\u003cbr/\u003ea = bitxor(a, c)\"]\n    CHECKBIT --\u003e|\"LSB = 0\"| SHIFT2\n    ACCUMULATE --\u003e SHIFT2[\"Shift x right\u003cbr/\u003ex = bitshift(x, -1)\"]\n    SHIFT2 --\u003e LOOP\n    \n    style START fill:#f9f9f9\n    style RETURN fill:#f9f9f9\n```\n\n**Diagram: xtime Function Flow**\n\nThe algorithm processes the multiplier `x` bit-by-bit from LSB to MSB. For each set bit in `x`, it accumulates the current value of `c` into the result. The multiplicand `c` is repeatedly doubled (left-shifted) with modular reduction when it exceeds 8 bits.\n\nSources: [AES_update/xtime.m:1-18]()\n\n### Modular Reduction\n\nWhen left-shifting `c` produces a 9th bit, the algorithm performs modular reduction by the irreducible polynomial:\n\n| Operation | Code | Mathematical Meaning |\n|-----------|------|---------------------|\n| Detect overflow | `bitget(c, 9)` | Check if result \u003e= 256 |\n| Clear bit 9 | `bitset(c, 9, 0)` | Reduce to 8-bit range |\n| Apply polynomial | `bitxor(c, 27)` | XOR with 0x1B (polynomial modulus) |\n\nThe value 27 (0x1B in hex) represents the lower 8 bits of the irreducible polynomial 0x11B. This reduction ensures all results remain in the valid range [0, 255].\n\nSources: [AES_update/xtime.m:9-12]()\n\n### Bit-by-Bit Multiplication Algorithm\n\n```mermaid\ngraph LR\n    subgraph \"Example: xtime(5, 0x57)\"\n        INPUT[\"Inputs:\u003cbr/\u003ex = 5 (binary 101)\u003cbr/\u003ec = 0x57\"]\n        \n        BIT0[\"Bit 0 = 1\u003cbr/\u003ea = 0x57\u003cbr/\u003ec = 0xAE (x2)\"]\n        BIT1[\"Bit 1 = 0\u003cbr/\u003eNo accumulation\u003cbr/\u003ec = 0x5C (x2, reduced)\"]\n        BIT2[\"Bit 2 = 1\u003cbr/\u003ea ^= 0x5C\u003cbr/\u003eResult = 0x0B\"]\n        \n        INPUT --\u003e BIT0\n        BIT0 --\u003e BIT1\n        BIT1 --\u003e BIT2\n    end\n```\n\n**Diagram: Multiplication Example**\n\nThe algorithm effectively implements: **result = x × c (mod irreducible polynomial)**\n\nSources: [AES_update/xtime.m:3-17]()\n\n## Multiplication by Constants\n\nThe AES specification requires multiplication by specific constants. The `xtime` function supports arbitrary multipliers, but the most common operations are:\n\n| Multiplier | Binary | Used In | Code Example |\n|------------|--------|---------|--------------|\n| 2 | 0x02 | MixColumns | `xtime(byte, 2)` |\n| 3 | 0x03 | MixColumns | `xtime(byte, 3)` |\n| 9 | 0x09 | InvMixColumns | `xtime(byte, 9)` |\n| 11 | 0x0B | InvMixColumns | `xtime(byte, 11)` |\n| 13 | 0x0D | InvMixColumns | `xtime(byte, 13)` |\n| 14 | 0x0E | InvMixColumns | `xtime(byte, 14)` |\n\n### Implementation Note\n\nMultiplication by 3 can be computed as: **(byte × 2) ⊕ byte**\n\nThis optimization is visible in the MixColumns implementation but handled by `xtime(byte, 3)`.\n\nSources: [AES_update/MixColumns.m:1-9](), [AES_update/InvMixColumns.m:1-9]()\n\n## Usage in MixColumns\n\nThe MixColumns transformation multiplies each column of the AES state by a fixed polynomial matrix. Each element of the result requires multiple Galois field multiplications:\n\n```mermaid\ngraph TD\n    subgraph \"MixColumns Column Processing\"\n        COL[\"Column [s0, s1, s2, s3]\"]\n        \n        R0[\"s0' = (2•s0) ⊕ (3•s1) ⊕ s2 ⊕ s3\"]\n        R1[\"s1' = s0 ⊕ (2•s1) ⊕ (3•s2) ⊕ s3\"]\n        R2[\"s2' = s0 ⊕ s1 ⊕ (2•s2) ⊕ (3•s3)\"]\n        R3[\"s3' = (3•s0) ⊕ s1 ⊕ s2 ⊕ (2•s3)\"]\n        \n        COL --\u003e R0\n        COL --\u003e R1\n        COL --\u003e R2\n        COL --\u003e R3\n    end\n    \n    X2[\"xtime(byte, 2)\u003cbr/\u003eMultiply by 2\"]\n    X3[\"xtime(byte, 3)\u003cbr/\u003eMultiply by 3\"]\n    \n    R0 -.-\u003e|\"calls\"| X2\n    R0 -.-\u003e|\"calls\"| X3\n    R1 -.-\u003e|\"calls\"| X2\n    R1 -.-\u003e|\"calls\"| X3\n    R2 -.-\u003e|\"calls\"| X2\n    R2 -.-\u003e|\"calls\"| X3\n    R3 -.-\u003e|\"calls\"| X2\n    R3 -.-\u003e|\"calls\"| X3\n```\n\n**Diagram: MixColumns Galois Field Operations**\n\n### Code Implementation\n\nThe MixColumns function processes the 16-byte state in groups of 4 (one column at a time):\n\n```\nState(a)   = xtime(state(a),2)   ⊕ xtime(state(a+1),3) ⊕ state(a+2)       ⊕ state(a+3)\nState(a+1) = xtime(state(a+1),2) ⊕ xtime(state(a+2),3) ⊕ state(a)         ⊕ state(a+3)\nState(a+2) = xtime(state(a+2),2) ⊕ xtime(state(a+3),3) ⊕ state(a)         ⊕ state(a+1)\nState(a+3) = xtime(state(a+3),2) ⊕ xtime(state(a),3)   ⊕ state(a+1)       ⊕ state(a+2)\n```\n\nThe loop iterates with `a = 1, 5, 9, 13` to process all four columns.\n\nSources: [AES_update/MixColumns.m:3-8]()\n\n## Usage in InvMixColumns\n\nThe InvMixColumns transformation uses the inverse of the MixColumns matrix, requiring multiplication by different constants: 9, 11, 13, and 14.\n\n```mermaid\ngraph TD\n    subgraph \"InvMixColumns Column Processing\"\n        COL[\"Column [s0, s1, s2, s3]\"]\n        \n        R0[\"s0' = (14•s0) ⊕ (11•s1) ⊕ (13•s2) ⊕ (9•s3)\"]\n        R1[\"s1' = (9•s0) ⊕ (14•s1) ⊕ (11•s2) ⊕ (13•s3)\"]\n        R2[\"s2' = (13•s0) ⊕ (9•s1) ⊕ (14•s2) ⊕ (11•s3)\"]\n        R3[\"s3' = (11•s0) ⊕ (13•s1) ⊕ (9•s2) ⊕ (14•s3)\"]\n        \n        COL --\u003e R0\n        COL --\u003e R1\n        COL --\u003e R2\n        COL --\u003e R3\n    end\n    \n    X9[\"xtime(byte, 9)\"]\n    X11[\"xtime(byte, 11)\"]\n    X13[\"xtime(byte, 13)\"]\n    X14[\"xtime(byte, 14)\"]\n    \n    R0 -.-\u003e|\"calls\"| X14\n    R0 -.-\u003e|\"calls\"| X11\n    R0 -.-\u003e|\"calls\"| X13\n    R0 -.-\u003e|\"calls\"| X9\n```\n\n**Diagram: InvMixColumns Galois Field Operations**\n\n### Code Implementation\n\nSimilar to MixColumns, but with different multiplier constants:\n\n```\nState(a)   = xtime(state(a),14)   ⊕ xtime(state(a+1),11) ⊕ xtime(state(a+2),13) ⊕ xtime(state(a+3),9)\nState(a+1) = xtime(state(a),9)    ⊕ xtime(state(a+1),14) ⊕ xtime(state(a+2),11) ⊕ xtime(state(a+3),13)\nState(a+2) = xtime(state(a),13)   ⊕ xtime(state(a+1),9)  ⊕ xtime(state(a+2),14) ⊕ xtime(state(a+3),11)\nState(a+3) = xtime(state(a),11)   ⊕ xtime(state(a+1),13) ⊕ xtime(state(a+2),9)  ⊕ xtime(state(a+3),14)\n```\n\nThese constants (9, 11, 13, 14) form the inverse matrix that reverses the MixColumns operation.\n\nSources: [AES_update/InvMixColumns.m:4-7]()\n\n## Mathematical Properties\n\n### Closure Property\n\nAll operations in GF(2^8) produce results within [0, 255], ensuring valid byte values.\n\n### Inverse Elements\n\nEvery non-zero element in GF(2^8) has a multiplicative inverse. The InvMixColumns constants are carefully chosen so that:\n\n```\nMixColumns(InvMixColumns(x)) = x\n```\n\n### Distributivity\n\nGalois field operations support distribution over XOR:\n\n```\na × (b ⊕ c) = (a × b) ⊕ (a × c)\n```\n\nThis property is critical for the correctness of the column mixing operations.\n\nSources: [AES_update/xtime.m:1-18]()\n\n## Function Call Hierarchy\n\n```mermaid\ngraph TD\n    MIXCOL[\"MixColumns.m\"]\n    INVMIXCOL[\"InvMixColumns.m\"]\n    KEYEXP[\"KeyExpansion.m\u003cbr/\u003e(referenced in overview)\"]\n    \n    XTIME[\"xtime.m\u003cbr/\u003eGalois Field Multiplier\"]\n    \n    MIXCOL --\u003e|\"xtime(byte, 2)\"| XTIME\n    MIXCOL --\u003e|\"xtime(byte, 3)\"| XTIME\n    \n    INVMIXCOL --\u003e|\"xtime(byte, 9)\"| XTIME\n    INVMIXCOL --\u003e|\"xtime(byte, 11)\"| XTIME\n    INVMIXCOL --\u003e|\"xtime(byte, 13)\"| XTIME\n    INVMIXCOL --\u003e|\"xtime(byte, 14)\"| XTIME\n    \n    KEYEXP -.-\u003e|\"may use\"| XTIME\n    \n    CIPHER[\"Cipher.m\"] --\u003e MIXCOL\n    INVCIPHER[\"InvCipher.m\"] --\u003e INVMIXCOL\n```\n\n**Diagram: xtime Function Call Graph**\n\nThe `xtime` function is a fundamental utility called by both forward and inverse column mixing operations. It has no dependencies and relies only on MATLAB's built-in bit manipulation functions (`bitget`, `bitset`, `bitshift`, `bitxor`).\n\nSources: [AES_update/xtime.m:1-18](), [AES_update/MixColumns.m:1-9](), [AES_update/InvMixColumns.m:1-9]()\n\n## Algorithm Complexity\n\n| Aspect | Complexity |\n|--------|-----------|\n| Time | O(log x) - proportional to number of bits in multiplier |\n| Space | O(1) - constant memory usage |\n| Bit operations | At most 8 iterations for 8-bit multiplier |\n\nThe implementation is efficient for the small values used in AES (2, 3, 9, 11, 13, 14), typically requiring only 2-4 iterations.\n\nSources: [AES_update/xtime.m:6-17]()"])</script><script>self.__next_f.push([1,"26:T29c0,"])</script><script>self.__next_f.push([1,"# Fingerprint Processing System\n\n\u003cdetails\u003e\n\u003csummary\u003eRelevant source files\u003c/summary\u003e\n\nThe following files were used as context for generating this wiki page:\n\n- [Copy_of_match.m](Copy_of_match.m)\n- [Copy_of_score.m](Copy_of_score.m)\n- [FExtraction/fft_enhance_cubs.m](FExtraction/fft_enhance_cubs.m)\n- [FExtraction/ridgesegment.m](FExtraction/ridgesegment.m)\n\n\u003c/details\u003e\n\n\n\n## Purpose and Scope\n\nThis document provides an overview of the complete fingerprint processing pipeline, from raw fingerprint images through feature extraction to matching and similarity scoring. The system processes fingerprint images to extract distinctive features (minutiae), stores them in a database, and performs one-to-many comparisons to identify matching fingerprints.\n\nFor detailed information about the AES encryption subsystem present in this repository, see [AES Encryption System](#2). For specifics on feature extraction algorithms, see [Feature Extraction Pipeline](#3.1). For details on the matching algorithms, see [Fingerprint Matching](#3.2).\n\nSources: [Copy_of_match.m:1-411](), [Copy_of_score.m:1-47](), [FExtraction/fft_enhance_cubs.m:1-275](), [FExtraction/ridgesegment.m:1-60]()\n\n## System Overview\n\nThe fingerprint processing system consists of two major subsystems that operate in sequence:\n\n1. **Feature Extraction**: Transforms raw fingerprint images into enhanced representations and extracts minutiae (ridge endings and bifurcations)\n2. **Fingerprint Matching**: Compares minutiae sets using geometric alignment and spatial/angular similarity measures\n\n### Complete Processing Pipeline\n\n```mermaid\ngraph TB\n    subgraph Input[\"Input Stage\"]\n        RAW[\"Raw Fingerprint Image\u003cbr/\u003e(grayscale)\"]\n    end\n    \n    subgraph FeatExtract[\"Feature Extraction Subsystem\"]\n        NORM[\"ridgesegment.m\u003cbr/\u003eNormalization \u0026 Segmentation\"]\n        ORIENT[\"ridgeorient.m\u003cbr/\u003eRidge Orientation\"]\n        FREQ[\"ridgefreq.m\u003cbr/\u003eRidge Frequency\"]\n        ENHANCE[\"ridgefilter.m OR\u003cbr/\u003efft_enhance_cubs.m\u003cbr/\u003eImage Enhancement\"]\n        MINUTIAE[\"Minutiae Extraction\u003cbr/\u003e(external/implicit)\"]\n    end\n    \n    subgraph Storage[\"Data Storage\"]\n        DB[(\"db.mat\u003cbr/\u003eCell array: ff{1:N}\u003cbr/\u003eMinutiae format:\u003cbr/\u003e[x, y, theta, type, id]\")]\n    end\n    \n    subgraph Matching[\"Matching Subsystem\"]\n        LOAD[\"Copy_of_match.m\u003cbr/\u003eLoad reference \u0026 candidates\"]\n        TRANS[\"transform()\u003cbr/\u003etransform2()\u003cbr/\u003eGeometric alignment\"]\n        SCORE[\"Copy_of_score.m\u003cbr/\u003eSpatial-angular scoring\"]\n        RESULT[\"Distance metrics\u003cbr/\u003e\u0026 similarity scores\"]\n    end\n    \n    RAW --\u003e NORM\n    NORM --\u003e ORIENT\n    ORIENT --\u003e FREQ\n    FREQ --\u003e ENHANCE\n    ENHANCE --\u003e MINUTIAE\n    MINUTIAE --\u003e DB\n    \n    DB --\u003e LOAD\n    LOAD --\u003e TRANS\n    TRANS --\u003e SCORE\n    SCORE --\u003e RESULT\n    \n    style RAW fill:#f9f9f9\n    style DB fill:#f9f9f9\n    style RESULT fill:#f9f9f9\n```\n\n**Diagram: End-to-End Fingerprint Processing Pipeline**\n\nSources: [Copy_of_match.m:17-25](), [FExtraction/fft_enhance_cubs.m:22-168](), [FExtraction/ridgesegment.m:1-60]()\n\n## Data Flow and Storage\n\nThe system operates on minutiae data stored in MATLAB `.mat` files. The primary database file `db.mat` contains a cell array `ff` where each cell holds minutiae for one fingerprint image.\n\n### Minutiae Data Format\n\n| Column | Field | Type | Description |\n|--------|-------|------|-------------|\n| 1 | x | double | X-coordinate in image space |\n| 2 | y | double | Y-coordinate in image space |\n| 3 | theta | double | Ridge angle (radians) |\n| 4 | type | integer | Minutia type (filtered by value \u003c 5) |\n| 5 | id | integer | Minutia identifier within fingerprint |\n\nThe database is organized as `ff{1}, ff{2}, ..., ff{N}` where each cell contains an M×5 matrix of minutiae points. The matching system assumes fingerprints are grouped in sets of 8, where `ff{Index*8-7}` serves as the reference print.\n\nSources: [Copy_of_match.m:18-36](), [Copy_of_score.m:16-19]()\n\n## Subsystem Interaction\n\n```mermaid\ngraph LR\n    subgraph ExtPipe[\"FExtraction/ Directory\"]\n        SEG[\"ridgesegment.m\"]\n        ORI[\"ridgeorient.m\"]\n        FRQ[\"ridgefreq.m\"]\n        FIL[\"ridgefilter.m\"]\n        FFT[\"fft_enhance_cubs.m\"]\n        \n        SEG --\u003e ORI\n        ORI --\u003e FRQ\n        FRQ --\u003e FIL\n        FFT -.-\u003e|alternative path| FIL\n    end\n    \n    subgraph MatchPipe[\"Root Directory\"]\n        MATCH[\"Copy_of_match.m\"]\n        SCR[\"Copy_of_score.m\"]\n        \n        MATCH --\u003e|calls| SCR\n    end\n    \n    subgraph DataLayer[\"Data Files\"]\n        DBFILE[(\"db.mat\u003cbr/\u003eff cell array\")]\n        ANGFILT[(\"angular_filters_pi_4.mat\u003cbr/\u003eangular_filters_pi_2.mat\u003cbr/\u003eFilter banks\")]\n    end\n    \n    ExtPipe --\u003e|produces| DBFILE\n    DBFILE --\u003e|loads into| MATCH\n    ANGFILT -.-\u003e|used by| FFT\n    \n    style DBFILE fill:#f9f9f9\n    style ANGFILT fill:#f9f9f9\n```\n\n**Diagram: Subsystem and Data Dependencies**\n\nSources: [Copy_of_match.m:18](), [FExtraction/fft_enhance_cubs.m:73-76]()\n\n## Key Processing Functions\n\n### Feature Extraction Functions\n\nThe feature extraction subsystem is located in the `FExtraction/` directory and implements several processing stages:\n\n| Function | Purpose | Key Parameters |\n|----------|---------|----------------|\n| `ridgesegment.m` | Normalizes image and segments ridge regions from background | `blksze=16`, `thresh=0.1-0.2` |\n| `ridgeorient.m` | Computes local ridge orientation using gradient analysis | Block-based processing |\n| `ridgefreq.m` | Estimates ridge spatial frequency (wavelength) | Projection-based analysis |\n| `ridgefilter.m` | Applies oriented Gabor-like filters for enhancement | Uses orientation and frequency maps |\n| `fft_enhance_cubs.m` | Alternative FFT-based enhancement with adaptive filtering | `BLKSZ=12`, `NFFT=32` |\n\nSources: [FExtraction/ridgesegment.m:1-60](), [FExtraction/fft_enhance_cubs.m:22-168]()\n\n### Matching Functions\n\nThe matching subsystem consists of two primary functions in the root directory:\n\n| Function | Purpose | Key Operations |\n|----------|---------|----------------|\n| `Copy_of_match.m` | Main matching engine that performs brute-force alignment search | Loads reference and 5 candidates from `db.mat`, tests multiple transformations |\n| `Copy_of_score.m` | Computes similarity between transformed minutiae sets | Counts matches within spatial (15px) and angular (14°) thresholds |\n\nHelper functions embedded in `Copy_of_match.m`:\n- `transform(M, i)`: Translates minutiae set M so that point i is at origin\n- `transform2(T, alpha)`: Rotates minutiae set T by angle alpha\n\nSources: [Copy_of_match.m:17-410](), [Copy_of_score.m:16-47]()\n\n## Matching Workflow\n\nThe matching process implements a comprehensive brute-force search strategy to find optimal alignment between fingerprints.\n\n```mermaid\ngraph TD\n    START[\"Copy_of_match\u003cbr/\u003eInput: Index, Number\"]\n    LOAD[\"Load from db.mat:\u003cbr/\u003eM1 = ff{Index*8-7}\u003cbr/\u003eM2-M6 = ff{random(5)}\"]\n    FILTER[\"Filter minutiae:\u003cbr/\u003eKeep only type \u003c 5\"]\n    \n    LOOP_I[\"For each M1 point i\"]\n    TRANS1[\"T1 = transform(M1, i)\u003cbr/\u003eTranslate M1 so point i at origin\"]\n    \n    LOOP_J[\"For each candidate point j\u003cbr/\u003e(M2, M3, M4, M5, M6)\"]\n    CHECK[\"Check if M1(i).type == M2(j).type\"]\n    TRANS2[\"T2 = transform(M2, j)\u003cbr/\u003eTranslate M2 so point j at origin\"]\n    \n    LOOP_A[\"For alpha in range\u003cbr/\u003e[-10:10] or [-5:5]\"]\n    ROT[\"T22 = transform2(T2, alpha*pi/180)\u003cbr/\u003eRotate T2 by alpha degrees\"]\n    \n    SCORING[\"[sm, T2_] = score(T1, T22)\u003cbr/\u003eCount matched minutiae\"]\n    UPDATE[\"Update best score:\u003cbr/\u003eif sm \u003e S2: S2=sm, bi2=i, bj2=j, ba2=alpha\"]\n    \n    DISPLAY{\"display_flag==1?\"}\n    CALC[\"Calculate distance metrics\u003cbr/\u003ebetween consistently matched points\"]\n    OUTPUT[\"Return: result, result_r\"]\n    \n    START --\u003e LOAD\n    LOAD --\u003e FILTER\n    FILTER --\u003e LOOP_I\n    LOOP_I --\u003e TRANS1\n    TRANS1 --\u003e LOOP_J\n    LOOP_J --\u003e CHECK\n    CHECK --\u003e|type match| TRANS2\n    CHECK --\u003e|no match| LOOP_J\n    TRANS2 --\u003e LOOP_A\n    LOOP_A --\u003e ROT\n    ROT --\u003e SCORING\n    SCORING --\u003e UPDATE\n    UPDATE --\u003e LOOP_A\n    LOOP_A --\u003e|next alpha| LOOP_J\n    LOOP_J --\u003e|next candidate| LOOP_I\n    LOOP_I --\u003e|all processed| DISPLAY\n    DISPLAY --\u003e|yes| CALC\n    DISPLAY --\u003e|no| OUTPUT\n    CALC --\u003e OUTPUT\n```\n\n**Diagram: Copy_of_match.m Control Flow**\n\nSources: [Copy_of_match.m:17-410]()\n\n### Scoring Algorithm\n\nThe `Copy_of_score.m` function implements spatial-angular matching criteria:\n\n**Matching Criteria:**\n- **Spatial threshold (T)**: 15 pixels - Maximum Euclidean distance between corresponding minutiae\n- **Angular threshold (TT)**: 14 degrees - Maximum orientation difference\n\n**Similarity Measure:**\n```\nn = count of matched minutiae pairs\nsm = sqrt(n² / (Count1 × Count2))\n```\n\nWhere `Count1` and `Count2` are the total minutiae counts in the two fingerprints being compared. This normalized score ranges from 0 (no match) to 1 (perfect match).\n\nSources: [Copy_of_score.m:16-47]()\n\n## Processing Parameters\n\n### Feature Extraction Configuration\n\nThe FFT-based enhancement method uses the following default parameters:\n\n| Parameter | Value | Purpose |\n|-----------|-------|---------|\n| `NFFT` | 32 | FFT window size |\n| `BLKSZ` | 12 | Block size for analysis |\n| `OVRLP` | 2 or 6 | Overlap size for block processing |\n| `ALPHA` | 0.5 | Root filtering coefficient |\n| `RMIN` | 3-4 | Minimum ridge spacing (pixels) |\n| `RMAX` | 18-40 | Maximum ridge spacing (pixels) |\n| `ETHRESH` | 6-19 | Energy threshold for segmentation |\n\nSources: [FExtraction/fft_enhance_cubs.m:24-42]()\n\n### Matching Configuration\n\nThe matching algorithm uses rotation angle ranges that vary by candidate:\n\n| Candidate | Rotation Range | Step Size |\n|-----------|---------------|-----------|\n| M2 | -10° to +10° | 1° |\n| M3 | -5° to +5° | 1° |\n| M4 | -10° to +10° | 1° |\n| M5 | -5° to +5° | 1° |\n| M6 | -5° to +5° | 1° |\n\nThese ranges represent typical maximum rotation differences between fingerprint acquisitions.\n\nSources: [Copy_of_match.m:68-136]()\n\n## System Limitations and Assumptions\n\n1. **Database Organization**: The system assumes fingerprints are grouped in sets of 8, using the formula `Index*8-7` to compute reference indices\n2. **Minutiae Type Filtering**: Only minutiae with `type \u003c 5` are processed; other types are filtered out\n3. **Brute-Force Search**: The matching algorithm tests all possible alignment pairs, resulting in O(n²×k) complexity where n is minutiae count and k is number of rotation angles\n4. **Fixed Thresholds**: Spatial (15px) and angular (14°) matching thresholds are hardcoded\n5. **Missing Minutiae Extraction**: The actual minutiae extraction step is not visible in the provided files; the system operates on pre-extracted minutiae stored in `db.mat`\n\nSources: [Copy_of_match.m:19-36](), [Copy_of_score.m:20-31]()"])</script><script>self.__next_f.push([1,"27:T4ac0,"])</script><script>self.__next_f.push([1,"# Feature Extraction Pipeline\n\n\u003cdetails\u003e\n\u003csummary\u003eRelevant source files\u003c/summary\u003e\n\nThe following files were used as context for generating this wiki page:\n\n- [FExtraction/fft_enhance_cubs.m](FExtraction/fft_enhance_cubs.m)\n- [FExtraction/ridgefilter.m](FExtraction/ridgefilter.m)\n- [FExtraction/ridgefreq.m](FExtraction/ridgefreq.m)\n- [FExtraction/ridgeorient.m](FExtraction/ridgeorient.m)\n- [FExtraction/ridgesegment.m](FExtraction/ridgesegment.m)\n\n\u003c/details\u003e\n\n\n\n## Purpose and Scope\n\nThis document provides an overview of the feature extraction pipeline that transforms raw fingerprint images into enhanced representations suitable for minutiae extraction and matching. The pipeline consists of multiple processing stages that normalize the image, estimate ridge characteristics, and apply enhancement filters.\n\nThe system implements two distinct enhancement approaches:\n1. **Standard path**: Sequential processing through normalization, orientation, frequency, and filtering stages\n2. **FFT path**: Block-wise frequency domain enhancement with adaptive angular filtering\n\nFor detailed explanations of individual stages, see:\n- Image segmentation and normalization: [3.1.1](#3.1.1)\n- Ridge orientation estimation: [3.1.2](#3.1.2)\n- Ridge frequency estimation: [3.1.3](#3.1.3)\n- Ridge filter enhancement: [3.1.4](#3.1.4)\n- FFT-based enhancement: [3.1.5](#3.1.5)\n- Angular filter banks: [3.1.6](#3.1.6)\n- Supporting utilities: [3.1.7](#3.1.7)\n\n## Feature Extraction Architecture\n\nThe feature extraction pipeline transforms raw fingerprint images through a series of analysis and enhancement stages. Each stage extracts specific characteristics of the ridge structure, building upon the outputs of previous stages.\n\n```mermaid\ngraph TD\n    RAW[\"Raw Fingerprint Image\u003cbr/\u003e(grayscale)\"]\n    \n    subgraph \"Standard Enhancement Path\"\n        SEG[\"ridgesegment()\u003cbr/\u003eFExtraction/ridgesegment.m\"]\n        ORIENT[\"ridgeorient()\u003cbr/\u003eFExtraction/ridgeorient.m\"]\n        FREQ[\"ridgefreq()\u003cbr/\u003eFExtraction/ridgefreq.m\"]\n        FILT[\"ridgefilter()\u003cbr/\u003eFExtraction/ridgefilter.m\"]\n    end\n    \n    subgraph \"FFT Enhancement Path\"\n        FFT[\"fft_enhance_cubs()\u003cbr/\u003eFExtraction/fft_enhance_cubs.m\"]\n    end\n    \n    subgraph \"Intermediate Products - Standard Path\"\n        NORMIM[\"normim\u003cbr/\u003e(normalized image)\"]\n        MASK[\"mask\u003cbr/\u003e(ridge region binary mask)\"]\n        ORIENTIM[\"orientim\u003cbr/\u003e(orientation in radians)\"]\n        RELIABILITY[\"reliability\u003cbr/\u003e(orientation confidence)\"]\n        FREQIM[\"freqim\u003cbr/\u003e(ridge frequency per pixel)\"]\n        MEDFREQ[\"medianfreq\u003cbr/\u003e(median frequency value)\"]\n    end\n    \n    subgraph \"Intermediate Products - FFT Path\"\n        ENHIMG[\"enhimg\u003cbr/\u003e(enhanced image)\"]\n        CIMG[\"cimg\u003cbr/\u003e(coherence map)\"]\n        OIMG[\"oimg\u003cbr/\u003e(orientation blocks)\"]\n        FIMG[\"fimg\u003cbr/\u003e(frequency blocks)\"]\n        BWIMG[\"bwimg\u003cbr/\u003e(bandwidth map)\"]\n        EIMG[\"eimg\u003cbr/\u003e(energy/ridgeness map)\"]\n    end\n    \n    FINAL[\"Enhanced Fingerprint Image\u003cbr/\u003e(ready for minutiae extraction)\"]\n    \n    RAW --\u003e SEG\n    RAW --\u003e FFT\n    \n    SEG --\u003e NORMIM\n    SEG --\u003e MASK\n    \n    NORMIM --\u003e ORIENT\n    ORIENT --\u003e ORIENTIM\n    ORIENT --\u003e RELIABILITY\n    \n    NORMIM --\u003e FREQ\n    MASK --\u003e FREQ\n    ORIENTIM --\u003e FREQ\n    FREQ --\u003e FREQIM\n    FREQ --\u003e MEDFREQ\n    \n    NORMIM --\u003e FILT\n    ORIENTIM --\u003e FILT\n    FREQIM --\u003e FILT\n    \n    FILT --\u003e FINAL\n    \n    FFT --\u003e ENHIMG\n    FFT --\u003e CIMG\n    FFT --\u003e OIMG\n    FFT --\u003e FIMG\n    FFT --\u003e BWIMG\n    FFT --\u003e EIMG\n    \n    ENHIMG --\u003e FINAL\n```\n\n**Pipeline Overview: Standard Path vs FFT Path**\n\nSources: [FExtraction/ridgesegment.m:1-59](), [FExtraction/ridgeorient.m:1-97](), [FExtraction/ridgefreq.m:1-74](), [FExtraction/ridgefilter.m:1-129](), [FExtraction/fft_enhance_cubs.m:1-275]()\n\n## Standard Enhancement Path\n\nThe standard path processes the fingerprint image through four sequential stages, each building upon the previous stage's outputs. This approach follows the methodology described in Hong et al. (1998).\n\n### Processing Stages\n\n| Stage | Function | Primary Inputs | Primary Outputs | Purpose |\n|-------|----------|---------------|-----------------|---------|\n| **1. Segmentation** | `ridgesegment()` | Raw image `im` | `normim`, `mask`, `maskind` | Normalize intensity and identify ridge regions |\n| **2. Orientation** | `ridgeorient()` | `normim` (or `im`) | `orientim`, `reliability` | Estimate local ridge direction using gradient analysis |\n| **3. Frequency** | `ridgefreq()` | `normim`, `mask`, `orientim` | `freqim`, `medianfreq` | Estimate ridge wavelength/spacing |\n| **4. Filtering** | `ridgefilter()` | `normim`, `orientim`, `freqim` | `newim` (enhanced image) | Apply oriented Gabor-like filters |\n\n### Typical Parameter Values\n\nFor a 500 DPI fingerprint image, the recommended parameter values are:\n\n```matlab\n% Stage 1: Segmentation\nblksze = 16;      % Block size for standard deviation calculation\nthresh = 0.1;     % Threshold for ridge region detection\n[normim, mask, maskind] = ridgesegment(im, blksze, thresh);\n\n% Stage 2: Orientation\ngradientsigma = 1;       % Sigma for gradient computation\nblocksigma = 3;          % Sigma for gradient moment summation\norientsmoothsigma = 3;   % Sigma for orientation smoothing\n[orientim, reliability] = ridgeorient(normim, gradientsigma, blocksigma, orientsmoothsigma);\n\n% Stage 3: Frequency\nblksze = 32;             % Block size for frequency estimation\nwindsze = 5;             % Window size for peak detection\nminWaveLength = 5;       % Minimum ridge wavelength (pixels)\nmaxWaveLength = 15;      % Maximum ridge wavelength (pixels)\n[freqim, medianfreq] = ridgefreq(normim, mask, orientim, blksze, windsze, minWaveLength, maxWaveLength);\n\n% Stage 4: Filtering\nkx = 0.5;                % Sigma scale factor along filter\nky = 0.5;                % Sigma scale factor across filter\nnewim = ridgefilter(normim, orientim, freqim, kx, ky);\n```\n\nSources: [FExtraction/ridgesegment.m:29-31](), [FExtraction/ridgeorient.m:25-28](), [FExtraction/ridgefreq.m:31-32](), [FExtraction/ridgefilter.m:8-26]()\n\n### Data Flow Through Standard Path\n\n```mermaid\ngraph LR\n    subgraph \"Input Image Properties\"\n        RAW[\"im\u003cbr/\u003e[rows x cols]\u003cbr/\u003euint8 grayscale\"]\n    end\n    \n    subgraph \"ridgesegment.m\"\n        NORM[\"normalise()\u003cbr/\u003ezero mean,\u003cbr/\u003eunit std\"]\n        STDDEV[\"blkproc()\u003cbr/\u003ecompute block std dev\"]\n        THRESH[\"threshold \u003e thresh\u003cbr/\u003ecreate mask\"]\n        RENORM[\"renormalize\u003cbr/\u003eusing ridge regions\"]\n    end\n    \n    subgraph \"ridgeorient.m\"\n        GRAD[\"gradient()\u003cbr/\u003eGx, Gy\"]\n        COV[\"Gxx, Gxy, Gyy\u003cbr/\u003e(covariance)\"]\n        SMOOTH[\"Gaussian filter\u003cbr/\u003e(weighted sum)\"]\n        ANGLE[\"atan2(sin2θ, cos2θ)/2\u003cbr/\u003eprincipal direction\"]\n    end\n    \n    subgraph \"ridgefreq.m\"\n        BLOCKS[\"Block iteration\u003cbr/\u003eblksze x blksze\"]\n        FREQEST[\"freqest()\u003cbr/\u003eX-signature analysis\"]\n        MEDIAN[\"median()\u003cbr/\u003eover valid regions\"]\n    end\n    \n    subgraph \"ridgefilter.m\"\n        GENFILT[\"Generate Gabor filters\u003cbr/\u003eper frequency\"]\n        ROTATE[\"imrotate()\u003cbr/\u003eper orientation\"]\n        CONV[\"Convolution\u003cbr/\u003eim .* filter\"]\n    end\n    \n    subgraph \"Output\"\n        ENHANCED[\"newim\u003cbr/\u003e[rows x cols]\u003cbr/\u003eenhanced image\"]\n    end\n    \n    RAW --\u003e NORM\n    NORM --\u003e STDDEV\n    STDDEV --\u003e THRESH\n    THRESH --\u003e RENORM\n    RENORM --\u003e GRAD\n    \n    GRAD --\u003e COV\n    COV --\u003e SMOOTH\n    SMOOTH --\u003e ANGLE\n    \n    ANGLE --\u003e BLOCKS\n    RENORM --\u003e BLOCKS\n    BLOCKS --\u003e FREQEST\n    FREQEST --\u003e MEDIAN\n    \n    ANGLE --\u003e GENFILT\n    MEDIAN --\u003e GENFILT\n    GENFILT --\u003e ROTATE\n    ROTATE --\u003e CONV\n    RENORM --\u003e CONV\n    \n    CONV --\u003e ENHANCED\n```\n\n**Standard Path Data Transformations**\n\nSources: [FExtraction/ridgesegment.m:44-58](), [FExtraction/ridgeorient.m:43-78](), [FExtraction/ridgefreq.m:56-73](), [FExtraction/ridgefilter.m:51-125]()\n\n## FFT Enhancement Path\n\nThe FFT-based enhancement method performs block-wise frequency domain analysis and applies adaptive angular filtering. Unlike the standard path, this approach computes all feature maps (orientation, frequency, coherence, bandwidth, energy) simultaneously in a single pass.\n\n### FFT Enhancement Function Signature\n\n```matlab\nfunction [enhimg, cimg, oimg, fimg, bwimg, eimg] = fft_enhance_cubs(img, BLKSZ)\n```\n\n| Parameter | Type | Description |\n|-----------|------|-------------|\n| **Input:** `img` | `double [H x W]` | Input fingerprint image (must be `double` type) |\n| **Input:** `BLKSZ` | `integer` | Block size for processing (e.g., 12 or 32) |\n| **Output:** `enhimg` | `uint8 [H x W]` | Enhanced fingerprint image |\n| **Output:** `cimg` | `double [nBlkHt x nBlkWt]` | Coherence image (orientation quality) |\n| **Output:** `oimg` | `double [nBlkHt x nBlkWt]` | Block orientation image (radians) |\n| **Output:** `fimg` | `double [nBlkHt x nBlkWt]` | Block frequency image (ridge spacing) |\n| **Output:** `bwimg` | `double [nBlkHt x nBlkWt]` | Angular bandwidth image (π/4, π/2, or π) |\n| **Output:** `eimg` | `double [nBlkHt x nBlkWt]` | Energy image (ridgeness measure) |\n\nSources: [FExtraction/fft_enhance_cubs.m:22-57]()\n\n### FFT Processing Configuration\n\nThe function uses different parameter sets based on the `BLKSZ` input:\n\n| Parameter | `BLKSZ \u003e 0` | `BLKSZ = 0` (default) | Purpose |\n|-----------|-------------|----------------------|---------|\n| `NFFT` | 32 | 32 | FFT size |\n| `BLKSZ` | (as provided) | 12 | Analysis block size |\n| `OVRLP` | 2 | 6 | Overlap size between blocks |\n| `ALPHA` | 0.5 | 0.5 | Root filtering parameter |\n| `RMIN` | 4 | 3 | Minimum ridge spacing (pixels) |\n| `RMAX` | 40 | 18 | Maximum ridge spacing (pixels) |\n| `ESTRETCH` | 20 | 20 | Contrast enhancement parameter |\n| `ETHRESH` | 19 | 6 | Energy threshold for segmentation |\n\nSources: [FExtraction/fft_enhance_cubs.m:25-42]()\n\n### FFT Enhancement Pipeline\n\n```mermaid\ngraph TD\n    subgraph \"Preprocessing\"\n        IMG[\"img (double)\"]\n        PARAMS[\"Load parameters\u003cbr/\u003eNFFT, BLKSZ, OVRLP\"]\n        FILTERS[\"Load angular filters\u003cbr/\u003eangular_filters_pi_4.mat\u003cbr/\u003eangular_filters_pi_2.mat\"]\n        BPASS[\"Butterworth bandpass\u003cbr/\u003eFLOW = NFFT/RMAX\u003cbr/\u003eFHIGH = NFFT/RMIN\"]\n    end\n    \n    subgraph \"FFT Analysis Loop (per block)\"\n        EXTRACT[\"Extract block\u003cbr/\u003esize: BLKSZ+2*OVRLP\"]\n        REMOVEDC[\"Remove DC\u003cbr/\u003esubtract mean\"]\n        WINDOW[\"Apply spectral window\u003cbr/\u003eraised_cosine_window()\"]\n        FFT2[\"fft2(block, NFFT, NFFT)\"]\n        BPFILT[\"Apply bandpass filter\u003cbr/\u003eblkfft .* dBPass\"]\n        ROOT[\"Root filtering\u003cbr/\u003eblkfft .* sqrt(energy)\"]\n        STATS[\"Compute statistics\u003cbr/\u003ecompute_mean_frequency()\u003cbr/\u003ecompute_mean_angle()\"]\n    end\n    \n    subgraph \"Feature Map Processing\"\n        SMOOTH_O[\"smoothen_orientation_image()\u003cbr/\u003e(3 iterations)\"]\n        SMOOTH_F[\"smoothen_frequency_image()\u003cbr/\u003e(diffusion)\"]\n        COHERENCE[\"compute_coherence()\u003cbr/\u003e(from orientation)\"]\n        BW[\"get_angular_bw_image()\u003cbr/\u003e(quantize to π/4, π/2, π)\"]\n    end\n    \n    subgraph \"Reconstruction Loop (per block)\"\n        GETFFT[\"Retrieve stored FFT\u003cbr/\u003efrom fftSrc matrix\"]\n        GETFILTER[\"get_angular_filter()\u003cbr/\u003e(based on oimg, bwimg)\"]\n        APPLY[\"Apply angular filter\u003cbr/\u003eblkfft .* af\"]\n        IFFT2[\"ifft2() and center\"]\n        PLACE[\"Place in enhimg\u003cbr/\u003e(BLKSZ x BLKSZ core)\"]\n    end\n    \n    subgraph \"Postprocessing\"\n        CONTRAST[\"Contrast enhancement\u003cbr/\u003esqrt(abs()) + sign\"]\n        NORMALIZE[\"Normalize to [1, 254]\"]\n        MASK_E[\"Apply energy mask\u003cbr/\u003eenhimg(emsk \u003c ETHRESH) = 128\"]\n    end\n    \n    IMG --\u003e PARAMS\n    PARAMS --\u003e FILTERS\n    PARAMS --\u003e BPASS\n    \n    BPASS --\u003e EXTRACT\n    EXTRACT --\u003e REMOVEDC\n    REMOVEDC --\u003e WINDOW\n    WINDOW --\u003e FFT2\n    FFT2 --\u003e BPFILT\n    BPFILT --\u003e ROOT\n    ROOT --\u003e STATS\n    \n    STATS --\u003e SMOOTH_O\n    SMOOTH_O --\u003e SMOOTH_F\n    SMOOTH_F --\u003e COHERENCE\n    COHERENCE --\u003e BW\n    \n    BW --\u003e GETFFT\n    GETFFT --\u003e GETFILTER\n    GETFILTER --\u003e APPLY\n    APPLY --\u003e IFFT2\n    IFFT2 --\u003e PLACE\n    \n    PLACE --\u003e CONTRAST\n    CONTRAST --\u003e NORMALIZE\n    NORMALIZE --\u003e MASK_E\n```\n\n**FFT Enhancement Processing Stages**\n\nSources: [FExtraction/fft_enhance_cubs.m:62-168]()\n\n### Angular Filtering Strategy\n\nThe FFT method applies adaptive angular filtering based on local coherence:\n\n```mermaid\ngraph TD\n    COHERENCE[\"cimg (coherence)\"]\n    \n    subgraph \"Bandwidth Allocation\"\n        HIGH[\"c ≤ 0.7\u003cbr/\u003e→ bw = π\u003cbr/\u003e(high bandwidth)\"]\n        MED[\"0.7 \u003c c \u003c 0.9\u003cbr/\u003e→ bw = π/2\u003cbr/\u003e(medium bandwidth)\"]\n        LOW[\"c ≥ 0.9\u003cbr/\u003e→ bw = π/4\u003cbr/\u003e(low bandwidth)\"]\n    end\n    \n    subgraph \"Filter Selection\"\n        PI4[\"Use angf_pi_4\u003cbr/\u003e(narrow filter)\"]\n        PI2[\"Use angf_pi_2\u003cbr/\u003e(medium filter)\"]\n        FULL[\"Use ones()\u003cbr/\u003e(no filtering)\"]\n    end\n    \n    COHERENCE --\u003e HIGH\n    COHERENCE --\u003e MED\n    COHERENCE --\u003e LOW\n    \n    HIGH --\u003e FULL\n    MED --\u003e PI2\n    LOW --\u003e PI4\n    \n    PI4 --\u003e APPLY[\"Apply at block orientation\u003cbr/\u003eget_angular_filter(oimg, bwimg)\"]\n    PI2 --\u003e APPLY\n    FULL --\u003e APPLY\n```\n\n**Adaptive Bandwidth Allocation Based on Coherence**\n\n- **High coherence (≥0.9)**: Narrow bandwidth (π/4) - strong directional filtering for well-defined ridges\n- **Medium coherence (0.7-0.9)**: Medium bandwidth (π/2) - moderate filtering\n- **Low coherence (≤0.7)**: Full bandwidth (π) - minimal directional filtering near singular points\n\nSources: [FExtraction/fft_enhance_cubs.m:132-133](), [FExtraction/fft_enhance_cubs.m:235-240](), [FExtraction/fft_enhance_cubs.m:211-225]()\n\n## Comparison: Standard vs FFT Enhancement\n\n| Aspect | Standard Path | FFT Path |\n|--------|---------------|----------|\n| **Processing Domain** | Spatial (with frequency info) | Frequency domain |\n| **Number of Passes** | 4 sequential stages | 2 passes (analysis + reconstruction) |\n| **Feature Maps** | Generated sequentially | Generated simultaneously in one pass |\n| **Orientation Estimation** | Gradient-based (continuous) | FFT energy-based (block-wise) |\n| **Frequency Estimation** | X-signature analysis per block | FFT magnitude analysis |\n| **Filter Adaptation** | Filter size adapts to frequency | Angular bandwidth adapts to coherence |\n| **Filter Type** | Gabor-like (spatial domain) | Angular filters (frequency domain) |\n| **Block Processing** | Required only for freq estimation | Required throughout |\n| **Overlap Strategy** | None (except in filtering) | Explicit overlap (OVRLP parameter) |\n| **Segmentation** | Explicit mask from std dev | Energy threshold on FFT magnitude |\n| **Output Resolution** | Full image resolution | Full image resolution |\n| **Precomputed Data** | None (generates filters on-demand) | Angular filter banks (.mat files) |\n| **Primary Reference** | Hong et al. (1998) | Chikkerur et al. (2004) |\n\nSources: [FExtraction/ridgesegment.m:1-59](), [FExtraction/ridgeorient.m:1-97](), [FExtraction/ridgefreq.m:1-74](), [FExtraction/ridgefilter.m:1-129](), [FExtraction/fft_enhance_cubs.m:1-275]()\n\n## Key Algorithm Components\n\n### Statistical Measures in FFT Analysis\n\nThe FFT path computes ridge orientation and frequency from the FFT energy distribution:\n\n**Mean Angle Computation** [FExtraction/fft_enhance_cubs.m:250-260]():\n```matlab\nsth = sin(2*th);\ncth = cos(2*th);\nnum = sum(sum(dEnergy.*sth));\nden = sum(sum(dEnergy.*cth));\nmth = 0.5*atan2(num,den);\nif(mth \u003c0)\n    mth = mth+pi;\nend\n```\n\n**Mean Frequency Computation** [FExtraction/fft_enhance_cubs.m:269-274]():\n```matlab\nnum = sum(sum(dEnergy.*r));\nden = sum(sum(dEnergy));\nmr = num/(den+eps);\n% Ridge spacing = NFFT/mr\n```\n\n### Gabor Filter Generation in Standard Path\n\nThe standard path generates Gabor-like filters adaptively based on local ridge frequency [FExtraction/ridgefilter.m:79-95]():\n\n```matlab\nfor k = 1:length(unfreq)\n    sigmax = 1/unfreq(k)*kx;  % Along ridge\n    sigmay = 1/unfreq(k)*ky;  % Across ridge\n    \n    sze(k) = round(3*max(sigmax,sigmay));\n    [x,y] = meshgrid(-sze(k):sze(k));\n    reffilter = exp(-(x.^2/sigmax^2 + y.^2/sigmay^2)/2) ...\n            .*cos(2*pi*unfreq(k)*x);\n    \n    % Generate rotated versions at 3° increments\n    for o = 1:180/angleInc\n        filter{k,o} = imrotate(reffilter,-(o*angleInc+90),'bilinear','crop');\n    end\nend\n```\n\nSources: [FExtraction/ridgefilter.m:79-95](), [FExtraction/fft_enhance_cubs.m:250-274]()\n\n## Data Dependencies\n\n### Input Requirements\n\n| Path | Required Input Format | Notes |\n|------|----------------------|-------|\n| Standard | `uint8` or `double` grayscale image | Automatically normalized in `ridgesegment()` |\n| FFT | `double` grayscale image | Must convert to `double` before calling |\n\n### External Data Files\n\nThe FFT enhancement path requires precomputed angular filter banks:\n\n- **`angular_filters_pi_4.mat`**: Narrow bandwidth filters (loaded at [FExtraction/fft_enhance_cubs.m:73-74]())\n- **`angular_filters_pi_2.mat`**: Medium bandwidth filters (loaded at [FExtraction/fft_enhance_cubs.m:75-76]())\n\nThese files contain the variable `angf`, which is a matrix where:\n- Each column represents a filter at a specific orientation\n- `TSTEPS = size(angf, 2)` defines the angular resolution\n- Orientation increment: `DELTAT = π/TSTEPS`\n\nFor information on how these filter banks are generated, see [3.1.6](#3.1.6).\n\nSources: [FExtraction/fft_enhance_cubs.m:71-76](), [FExtraction/fft_enhance_cubs.m:211-225]()\n\n## Output Characteristics\n\n### Standard Path Outputs\n\nThe standard path produces a single enhanced image where:\n- Ridge regions are emphasized through oriented filtering\n- Non-ridge regions may contain artifacts from the filtering process\n- Segmentation must be applied separately using the `mask` output\n\n### FFT Path Outputs\n\nThe FFT path produces multiple feature maps useful for subsequent processing:\n\n1. **`enhimg`**: Enhanced fingerprint image (uint8, 1-254 range, background=128)\n2. **`cimg`**: Coherence map indicating orientation quality\n3. **`oimg`**: Block-wise orientation estimates\n4. **`fimg`**: Block-wise ridge frequency estimates  \n5. **`bwimg`**: Angular bandwidth allocation map\n6. **`eimg`**: Energy map for segmentation (log scale)\n\nThe energy-based segmentation is applied automatically [FExtraction/fft_enhance_cubs.m:166-167]():\n```matlab\nemsk = imresize(eimg,[nHt,nWt]);\nenhimg(emsk\u003cETHRESH) = 128;  % Set low-energy regions to gray\n```\n\nSources: [FExtraction/fft_enhance_cubs.m:51-57](), [FExtraction/fft_enhance_cubs.m:158-168]()\n\n## Integration with Minutiae Extraction\n\nThe enhanced images produced by either path serve as input to minutiae extraction algorithms (not included in the visible codebase). The enhancement improves minutiae detection by:\n\n1. **Reducing noise**: Smoothing operations remove high-frequency noise\n2. **Enhancing ridges**: Oriented filtering emphasizes ridge structures\n3. **Normalizing contrast**: Consistent intensity makes thresholding more reliable\n4. **Segmenting background**: Masks or energy thresholds separate ridge regions\n\nThe typical workflow continues:\n```\nEnhanced Image → Binarization → Thinning → Minutiae Detection → Feature Vector\n```\n\nThe minutiae features (ridge endings and bifurcations) are then stored in the database format used by the matching system (see [3.2](#3.2)).\n\nSources: [FExtraction/fft_enhance_cubs.m:1-21](), [FExtraction/ridgefilter.m:1-33]()"])</script><script>self.__next_f.push([1,"28:T31e2,"])</script><script>self.__next_f.push([1,"# Image Segmentation and Normalization\n\n\u003cdetails\u003e\n\u003csummary\u003eRelevant source files\u003c/summary\u003e\n\nThe following files were used as context for generating this wiki page:\n\n- [FExtraction/normalise.m](FExtraction/normalise.m)\n- [FExtraction/ridgesegment.m](FExtraction/ridgesegment.m)\n\n\u003c/details\u003e\n\n\n\n## Purpose and Scope\n\nThis page describes the first stage of the fingerprint feature extraction pipeline, which prepares raw fingerprint images for subsequent analysis by normalizing intensity values and identifying ridge regions. This preprocessing step separates the informative ridge patterns from background noise and areas without useful fingerprint information.\n\nFor details on subsequent processing steps that use the normalized image and mask, see [Ridge Orientation Estimation](#3.1.2) and [Ridge Frequency Estimation](#3.1.3).\n\n## Overview\n\nImage segmentation and normalization is implemented primarily in `ridgesegment.m`, which performs two critical operations:\n\n1. **Intensity Normalization**: Adjusts pixel values to have consistent statistical properties (zero mean, unit standard deviation)\n2. **Ridge Region Segmentation**: Identifies areas containing actual fingerprint ridge patterns versus background or low-quality regions\n\nThe process relies on the principle that fingerprint ridge regions exhibit higher local variance compared to background areas, which tend to be uniform.\n\n**Diagram: Segmentation and Normalization Data Flow**\n\n```mermaid\ngraph TD\n    Input[\"Raw Fingerprint Image\u003cbr/\u003e(im)\"]\n    \n    Norm1[\"normalise(im, 0, 1)\"]\n    NormOut1[\"Globally Normalized Image\u003cbr/\u003e(zero mean, unit std dev)\"]\n    \n    BlockProc[\"blkproc(im, [blksze blksze], fun)\u003cbr/\u003eBlock-wise Std Dev Calculation\"]\n    StdDevImg[\"stddevim\u003cbr/\u003e(Standard Deviation Map)\"]\n    \n    Thresh[\"mask = stddevim \u003e thresh\"]\n    Mask[\"Binary Mask\u003cbr/\u003e(1 = ridge region, 0 = background)\"]\n    MaskInd[\"maskind\u003cbr/\u003e(Linear indices of ridge pixels)\"]\n    \n    Renorm[\"Re-normalize using ridge region stats\u003cbr/\u003eim - mean(im(maskind))\u003cbr/\u003eim / std(im(maskind))\"]\n    \n    Output[\"normim\u003cbr/\u003e(Normalized Image)\"]\n    \n    Input --\u003e Norm1\n    Norm1 --\u003e NormOut1\n    NormOut1 --\u003e BlockProc\n    BlockProc --\u003e StdDevImg\n    StdDevImg --\u003e Thresh\n    Thresh --\u003e Mask\n    Mask --\u003e MaskInd\n    MaskInd --\u003e Renorm\n    NormOut1 --\u003e Renorm\n    Renorm --\u003e Output\n    \n    Mask --\u003e PipelineOutput[\"Outputs to Pipeline\"]\n    Output --\u003e PipelineOutput\n    MaskInd --\u003e PipelineOutput\n```\n\nSources: [FExtraction/ridgesegment.m:1-59]()\n\n## Image Normalization Function\n\nThe `normalise` function provides general-purpose image normalization capabilities used throughout the feature extraction pipeline. It supports two normalization modes:\n\n### Mode 1: Range Normalization (0-1)\n\nWhen called with a single argument `normalise(im)`, the function rescales pixel values to the range [0, 1]:\n\n```\nn = (im - min(im(:))) / max(im(:))\n```\n\nThis simple linear transformation preserves relative intensity relationships while standardizing the value range. For color images, only the value component of the HSV representation is normalized.\n\nImplementation: [FExtraction/normalise.m:44-56]()\n\n### Mode 2: Statistical Normalization (Mean and Variance)\n\nWhen called with three arguments `normalise(im, reqmean, reqvar)`, the function adjusts the image to have a specified mean and variance:\n\n```\n1. Center: im = im - mean(im(:))\n2. Scale: im = im / std(im(:))\n3. Transform: n = reqmean + im * sqrt(reqvar)\n```\n\nThis mode is used by `ridgesegment` with `normalise(im, 0, 1)` to create a zero-mean, unit-variance image, which enables consistent threshold values across different fingerprint images.\n\nImplementation: [FExtraction/normalise.m:58-69]()\n\n**Diagram: normalise Function Modes**\n\n```mermaid\ngraph LR\n    subgraph \"Mode 1: Range [0,1]\"\n        I1[\"Input Image\"]\n        Sub1[\"Subtract min(im)\"]\n        Div1[\"Divide by max(im)\"]\n        O1[\"Output [0,1]\"]\n        \n        I1 --\u003e Sub1\n        Sub1 --\u003e Div1\n        Div1 --\u003e O1\n    end\n    \n    subgraph \"Mode 2: Mean/Variance\"\n        I2[\"Input Image\"]\n        Sub2[\"Subtract mean(im)\"]\n        Div2[\"Divide by std(im)\"]\n        Scale[\"Scale by sqrt(reqvar)\"]\n        Add[\"Add reqmean\"]\n        O2[\"Output (reqmean, reqvar)\"]\n        \n        I2 --\u003e Sub2\n        Sub2 --\u003e Div2\n        Div2 --\u003e Scale\n        Scale --\u003e Add\n        Add --\u003e O2\n    end\n```\n\nSources: [FExtraction/normalise.m:1-71]()\n\n## Ridge Segmentation Process\n\nThe `ridgesegment` function implements the main segmentation and normalization algorithm. It accepts three parameters:\n\n| Parameter | Type | Description | Typical Value (500 dpi) |\n|-----------|------|-------------|-------------------------|\n| `im` | 2D array | Raw fingerprint image | - |\n| `blksze` | integer | Block size for local analysis | 16 |\n| `thresh` | float | Standard deviation threshold | 0.1 - 0.2 |\n\n### Block-Wise Standard Deviation Analysis\n\nThe segmentation algorithm divides the image into non-overlapping blocks of size `blksze × blksze` pixels and computes the standard deviation within each block:\n\n```matlab\nfun = inline('std(x(:))*ones(size(x))');\nstddevim = blkproc(im, [blksze blksze], fun);\n```\n\nThe `blkproc` function applies the standard deviation calculation to each block, producing a downsampled map where each pixel represents the local variance of the corresponding block in the original image.\n\n**Diagram: Block Processing for Segmentation**\n\n```mermaid\ngraph TB\n    subgraph \"Input Processing\"\n        Raw[\"Raw Fingerprint Image\"]\n        First[\"normalise(im, 0, 1)\"]\n        Std[\"Standardized Image\u003cbr/\u003e(mean=0, std=1)\"]\n        Raw --\u003e First\n        First --\u003e Std\n    end\n    \n    subgraph \"Block-wise Analysis\"\n        Std --\u003e Divide[\"Divide into blksze×blksze blocks\"]\n        Divide --\u003e B1[\"Block (1,1)\"]\n        Divide --\u003e B2[\"Block (1,2)\"]\n        Divide --\u003e B3[\"Block (2,1)\"]\n        Divide --\u003e Bn[\"Block (n,m)\"]\n        \n        B1 --\u003e S1[\"std(block)\"]\n        B2 --\u003e S2[\"std(block)\"]\n        B3 --\u003e S3[\"std(block)\"]\n        Bn --\u003e Sn[\"std(block)\"]\n        \n        S1 --\u003e StdMap[\"stddevim\"]\n        S2 --\u003e StdMap\n        S3 --\u003e StdMap\n        Sn --\u003e StdMap\n    end\n    \n    subgraph \"Mask Generation\"\n        StdMap --\u003e Compare[\"stddevim \u003e thresh\"]\n        Compare --\u003e MaskOut[\"mask\u003cbr/\u003e(binary ridge/background)\"]\n        MaskOut --\u003e FindIdx[\"find(mask)\"]\n        FindIdx --\u003e Indices[\"maskind\u003cbr/\u003e(ridge pixel indices)\"]\n    end\n    \n    subgraph \"Final Normalization\"\n        Std --\u003e CalcMean[\"mean(im(maskind))\"]\n        Std --\u003e CalcStd[\"std(im(maskind))\"]\n        CalcMean --\u003e SubMean[\"im - ridge_mean\"]\n        SubMean --\u003e DivStd[\"result / ridge_std\"]\n        CalcStd --\u003e DivStd\n        DivStd --\u003e Final[\"normim\u003cbr/\u003e(ridge regions: mean=0, std=1)\"]\n    end\n    \n    Indices --\u003e CalcMean\n    Indices --\u003e CalcStd\n```\n\nSources: [FExtraction/ridgesegment.m:44-59]()\n\n### Mask Generation\n\nAfter computing the standard deviation map, a binary mask is created by thresholding:\n\n```matlab\nmask = stddevim \u003e thresh;\nmaskind = find(mask);\n```\n\nRegions where `stddevim \u003e thresh` are classified as ridge regions (mask value = 1), while regions below the threshold are considered background or poor-quality areas (mask value = 0). The `maskind` vector stores the linear indices of all ridge pixels for efficient access.\n\nImplementation: [FExtraction/ridgesegment.m:52-53]()\n\n### Ridge Region Re-normalization\n\nThe final step re-normalizes the image using statistics computed only from the ridge regions:\n\n```matlab\nim = im - mean(im(maskind));\nnormim = im / std(im(maskind));\n```\n\nThis ensures that the meaningful fingerprint areas have consistent statistical properties (zero mean, unit standard deviation), while background regions may have arbitrary values. This selective normalization is critical because:\n\n- Ridge regions contain the actual fingerprint information\n- Background regions would skew global statistics\n- Subsequent processing stages rely on consistent ridge intensity distributions\n\nImplementation: [FExtraction/ridgesegment.m:57-58]()\n\n## Algorithm Flow\n\n**Diagram: ridgesegment Algorithm with Code References**\n\n```mermaid\nflowchart TD\n    Start[\"ridgesegment(im, blksze, thresh)\"]\n    \n    Step1[\"Line 46:\u003cbr/\u003eim = normalise(im, 0, 1)\"]\n    Comment1[\"Global normalization\u003cbr/\u003ezero mean, unit std dev\"]\n    \n    Step2[\"Line 48:\u003cbr/\u003efun = inline('std(x(:))*ones(size(x))')\"]\n    Comment2[\"Define std dev function\u003cbr/\u003efor block processing\"]\n    \n    Step3[\"Line 50:\u003cbr/\u003estddevim = blkproc(im, [blksze blksze], fun)\"]\n    Comment3[\"Compute std dev\u003cbr/\u003efor each block\"]\n    \n    Step4[\"Line 52:\u003cbr/\u003emask = stddevim \u003e thresh\"]\n    Comment4[\"Threshold to create\u003cbr/\u003ebinary mask\"]\n    \n    Step5[\"Line 53:\u003cbr/\u003emaskind = find(mask)\"]\n    Comment5[\"Get linear indices\u003cbr/\u003eof ridge pixels\"]\n    \n    Step6[\"Line 57:\u003cbr/\u003eim = im - mean(im(maskind))\"]\n    Comment6[\"Center using\u003cbr/\u003eridge region mean\"]\n    \n    Step7[\"Line 58:\u003cbr/\u003enormim = im / std(im(maskind))\"]\n    Comment7[\"Scale using\u003cbr/\u003eridge region std dev\"]\n    \n    Return[\"Return:\u003cbr/\u003enormim, mask, maskind\"]\n    \n    Start --\u003e Step1\n    Step1 -.-\u003e Comment1\n    Step1 --\u003e Step2\n    Step2 -.-\u003e Comment2\n    Step2 --\u003e Step3\n    Step3 -.-\u003e Comment3\n    Step3 --\u003e Step4\n    Step4 -.-\u003e Comment4\n    Step4 --\u003e Step5\n    Step5 -.-\u003e Comment5\n    Step5 --\u003e Step6\n    Step6 -.-\u003e Comment6\n    Step6 --\u003e Step7\n    Step7 -.-\u003e Comment7\n    Step7 --\u003e Return\n```\n\nSources: [FExtraction/ridgesegment.m:44-59]()\n\n## Parameters and Typical Values\n\nThe effectiveness of segmentation depends on proper parameter selection:\n\n### Block Size (`blksze`)\n\nThe block size determines the spatial resolution of the segmentation. Common values:\n\n- **16 pixels**: Recommended for 500 dpi fingerprint images\n- Larger values: Provide smoother segmentation but less spatial precision\n- Smaller values: More sensitive to local variations but may misclassify noise as ridge regions\n\nThe block size should be chosen relative to the average ridge-to-ridge distance in the image. For 500 dpi images, typical ridge frequency is 5-8 ridges per 25mm, corresponding to approximately 10-15 pixels per ridge period. A 16-pixel block captures roughly one full ridge cycle.\n\n### Threshold (`thresh`)\n\nThe standard deviation threshold separates ridge from non-ridge regions:\n\n- **0.1 - 0.2**: Recommended range for normalized images (zero mean, unit std dev)\n- Lower values: Include more marginal regions (higher sensitivity, more false positives)\n- Higher values: Stricter segmentation (lower sensitivity, may exclude valid ridge areas)\n\nSince the input is normalized to unit standard deviation, these threshold values are dimensionless and transferable across different images.\n\nSources: [FExtraction/ridgesegment.m:15-31]()\n\n## Output Data Products\n\nThe `ridgesegment` function returns three outputs:\n\n**Output Specifications**\n\n| Output | Type | Description | Usage |\n|--------|------|-------------|-------|\n| `normim` | 2D double array | Normalized fingerprint image with ridge regions having mean=0, std=1 | Input to orientation and frequency estimation |\n| `mask` | 2D logical array | Binary mask (1=ridge, 0=background), same size as input | Spatial filtering and region selection |\n| `maskind` | 1D integer array | Linear indices of ridge pixels (result of `find(mask)`) | Efficient indexing without repeated `find()` calls |\n\nThe `maskind` output is particularly useful for performance optimization, as it allows downstream algorithms to process only ridge regions without repeatedly computing `find(mask)` or using logical indexing with the full 2D mask array.\n\nSources: [FExtraction/ridgesegment.m:23-27]()\n\n## Integration with Feature Extraction Pipeline\n\nThe outputs from `ridgesegment` serve as inputs to subsequent stages:\n\n**Diagram: Pipeline Integration**\n\n```mermaid\ngraph LR\n    Input[\"Raw Image\"]\n    \n    Segment[\"ridgesegment.m\"]\n    \n    NormImg[\"normim\"]\n    Mask[\"mask\"]\n    MaskInd[\"maskind\"]\n    \n    Orient[\"ridgeorient.m\u003cbr/\u003e(Page 3.1.2)\"]\n    Freq[\"ridgefreq.m\u003cbr/\u003e(Page 3.1.3)\"]\n    Filter[\"ridgefilter.m\u003cbr/\u003e(Page 3.1.4)\"]\n    \n    Input --\u003e Segment\n    Segment --\u003e NormImg\n    Segment --\u003e Mask\n    Segment --\u003e MaskInd\n    \n    NormImg --\u003e Orient\n    Mask --\u003e Orient\n    \n    NormImg --\u003e Freq\n    Mask --\u003e Freq\n    Orient --\u003e Freq\n    \n    NormImg --\u003e Filter\n    Orient --\u003e Filter\n    Freq --\u003e Filter\n```\n\nSources: [FExtraction/ridgesegment.m:33]()\n\nThe normalized image (`normim`) with consistent statistical properties ensures that subsequent orientation and frequency estimation algorithms produce comparable results across different fingerprint samples. The mask constrains processing to informative regions, improving computational efficiency and result quality by excluding background areas that would contribute noise to the analysis."])</script><script>self.__next_f.push([1,"29:T3413,"])</script><script>self.__next_f.push([1,"# Ridge Orientation Estimation\n\n\u003cdetails\u003e\n\u003csummary\u003eRelevant source files\u003c/summary\u003e\n\nThe following files were used as context for generating this wiki page:\n\n- [FExtraction/compute_coherence.m](FExtraction/compute_coherence.m)\n- [FExtraction/ridgeorient.m](FExtraction/ridgeorient.m)\n- [FExtraction/smoothen_orientation_image.m](FExtraction/smoothen_orientation_image.m)\n\n\u003c/details\u003e\n\n\n\n## Purpose and Scope\n\nThis page documents the ridge orientation estimation subsystem used in the fingerprint feature extraction pipeline. Ridge orientation refers to the local direction of fingerprint ridges at each point in the image, measured in radians. This orientation information is critical for subsequent enhancement stages, including frequency analysis (see [Ridge Frequency Estimation](#3.1.3)) and oriented filtering (see [Ridge Filter Enhancement](#3.1.4)).\n\nThe orientation estimation is implemented in [FExtraction/ridgeorient.m]() and supported by utility functions [FExtraction/smoothen_orientation_image.m]() and [FExtraction/compute_coherence.m]().\n\n## Algorithm Overview\n\nThe ridge orientation estimation algorithm computes local ridge direction by analyzing the principal axis of variation in image gradients. The process follows a gradient-based approach that leverages covariance analysis to identify the dominant orientation at each pixel location.\n\n**Diagram: Ridge Orientation Estimation Pipeline**\n\n```mermaid\ngraph TD\n    INPUT[\"Normalized Image\u003cbr/\u003e(from ridgesegment)\"]\n    \n    GRADIENT[\"Compute Image Gradients\u003cbr/\u003eridgeorient.m:46-51\u003cbr/\u003eGx, Gy via Gaussian derivatives\"]\n    \n    COVAR[\"Compute Covariance Terms\u003cbr/\u003eridgeorient.m:56-58\u003cbr/\u003eGxx = Gx²\u003cbr/\u003eGxy = Gx·Gy\u003cbr/\u003eGyy = Gy²\"]\n    \n    SMOOTH_COV[\"Smooth Covariance Data\u003cbr/\u003eridgeorient.m:62-66\u003cbr/\u003eGaussian filtering with blocksigma\"]\n    \n    PRINCIPAL[\"Extract Principal Direction\u003cbr/\u003eridgeorient.m:68-71\u003cbr/\u003esin2theta, cos2theta\"]\n    \n    SMOOTH_ORIENT[\"Smooth Orientation Field\u003cbr/\u003eridgeorient.m:73-78\u003cbr/\u003eVectorial Gaussian smoothing\"]\n    \n    RELIABILITY[\"Compute Reliability\u003cbr/\u003eridgeorient.m:80-96\u003cbr/\u003eBased on moment of inertia ratio\"]\n    \n    OUTPUT[\"orientim\u003cbr/\u003e(orientation in radians)\u003cbr/\u003ereliability\u003cbr/\u003e(confidence 0-1)\"]\n    \n    INPUT --\u003e GRADIENT\n    GRADIENT --\u003e COVAR\n    COVAR --\u003e SMOOTH_COV\n    SMOOTH_COV --\u003e PRINCIPAL\n    PRINCIPAL --\u003e SMOOTH_ORIENT\n    SMOOTH_ORIENT --\u003e OUTPUT\n    SMOOTH_COV --\u003e RELIABILITY\n    RELIABILITY --\u003e OUTPUT\n```\n\nSources: [FExtraction/ridgeorient.m:1-97]()\n\n## Input Parameters\n\nThe `ridgeorient` function accepts four parameters that control the scale and smoothness of the orientation estimation:\n\n| Parameter | Type | Purpose | Typical Value |\n|-----------|------|---------|---------------|\n| `im` | 2D array | Normalized input fingerprint image | From ridgesegment |\n| `gradientsigma` | scalar | Sigma for Gaussian derivative used in gradient computation | 1 |\n| `blocksigma` | scalar | Sigma for Gaussian weighting when summing gradient moments | 3 |\n| `orientsmoothsigma` | scalar | Sigma for final orientation field smoothing | 3 |\n\nSources: [FExtraction/ridgeorient.m:7-13](), [FExtraction/ridgeorient.m:25-28]()\n\n## Gradient Computation\n\nThe algorithm begins by computing image gradients using the derivative of a Gaussian filter. This approach provides both smoothing and differentiation in a single operation.\n\n**Implementation Details:**\n\n1. **Gaussian Derivative Filter Construction** [FExtraction/ridgeorient.m:46-48]()\n   - Filter size: `fix(6*gradientsigma)` (forced to odd)\n   - Base Gaussian created with `fspecial('gaussian', sze, gradientsigma)`\n   - Gradients `fx` and `fy` extracted using MATLAB's `gradient` function\n\n2. **Gradient Image Computation** [FExtraction/ridgeorient.m:50-51]()\n   - `Gx = filter2(fx, im)` - x-direction gradient\n   - `Gy = filter2(fy, im)` - y-direction gradient\n\nSources: [FExtraction/ridgeorient.m:45-51]()\n\n## Covariance Analysis\n\nLocal orientation is determined by analyzing the covariance structure of the image gradients. The algorithm computes three covariance terms that form a structure tensor.\n\n**Diagram: Covariance Term Computation and Smoothing**\n\n```mermaid\ngraph LR\n    GX[\"Gx\u003cbr/\u003e(x-gradient)\"]\n    GY[\"Gy\u003cbr/\u003e(y-gradient)\"]\n    \n    GXX[\"Gxx = Gx²\u003cbr/\u003eridgeorient.m:56\"]\n    GXY[\"Gxy = Gx·Gy\u003cbr/\u003eridgeorient.m:57\"]\n    GYY[\"Gyy = Gy²\u003cbr/\u003eridgeorient.m:58\"]\n    \n    GAUSS[\"Gaussian Filter\u003cbr/\u003esze = fix(6*blocksigma)\u003cbr/\u003eridgeorient.m:62-63\"]\n    \n    SXXX[\"Smoothed Gxx\u003cbr/\u003efilter2(f, Gxx)\u003cbr/\u003eridgeorient.m:64\"]\n    SXYY[\"Smoothed Gxy\u003cbr/\u003e2*filter2(f, Gxy)\u003cbr/\u003eridgeorient.m:65\"]\n    SYYY[\"Smoothed Gyy\u003cbr/\u003efilter2(f, Gyy)\u003cbr/\u003eridgeorient.m:66\"]\n    \n    GX --\u003e GXX\n    GX --\u003e GXY\n    GY --\u003e GXY\n    GY --\u003e GYY\n    \n    GXX --\u003e SXXX\n    GXY --\u003e SXYY\n    GYY --\u003e SYYY\n    \n    GAUSS -.-\u003e|\"applies to\"| SXXX\n    GAUSS -.-\u003e|\"applies to\"| SXYY\n    GAUSS -.-\u003e|\"applies to\"| SYYY\n```\n\nThe factor of 2 applied to `Gxy` [FExtraction/ridgeorient.m:65]() accounts for the symmetry of the covariance matrix in the subsequent principal direction calculation.\n\nSources: [FExtraction/ridgeorient.m:56-66]()\n\n## Principal Direction Extraction\n\nThe ridge orientation corresponds to the principal direction (eigenvector associated with the minimum eigenvalue) of the structure tensor. Rather than computing eigenvalues directly, the algorithm uses an analytic solution that expresses the orientation through trigonometric functions.\n\n**Mathematical Formulation:**\n\n[FExtraction/ridgeorient.m:68-71]() computes:\n\n```\ndenom = sqrt(Gxy² + (Gxx - Gyy)²) + eps\nsin2theta = Gxy / denom\ncos2theta = (Gxx - Gyy) / denom\n```\n\nThe denominator represents the coherence strength, with `eps` added for numerical stability. The values `sin2theta` and `cos2theta` represent the sine and cosine of twice the orientation angle.\n\nSources: [FExtraction/ridgeorient.m:68-71]()\n\n## Vectorial Smoothing\n\nOrientation fields require special smoothing techniques because orientations are circular quantities (e.g., 0° and 360° represent the same direction). Direct averaging of orientation angles produces artifacts at discontinuities. The algorithm employs **vectorial Gaussian filtering** to address this.\n\n**Vectorial Smoothing Process** [FExtraction/ridgeorient.m:73-78]():\n\n1. Construct Gaussian smoothing kernel with size `fix(6*orientsmoothsigma)`\n2. Filter `cos2theta` to produce smoothed cosine values\n3. Filter `sin2theta` to produce smoothed sine values\n4. Recover smoothed orientation: `orientim = π/2 + atan2(sin2theta, cos2theta)/2`\n\nThe doubling of angles (`2theta`) before filtering and halving after filtering ensures smooth transitions across orientation discontinuities.\n\n**Diagram: Vectorial Smoothing Implementation**\n\n```mermaid\ngraph TD\n    ANGLES[\"Double-angle representation\u003cbr/\u003ecos2theta, sin2theta\u003cbr/\u003eridgeorient.m:70-71\"]\n    \n    GAUSSIAN[\"Gaussian kernel\u003cbr/\u003esze = fix(6*orientsmoothsigma)\u003cbr/\u003efspecial('gaussian', sze, orientsmoothsigma)\u003cbr/\u003eridgeorient.m:73-74\"]\n    \n    FILTER_COS[\"Filter cos2theta\u003cbr/\u003efilter2(f, cos2theta)\u003cbr/\u003eridgeorient.m:75\"]\n    \n    FILTER_SIN[\"Filter sin2theta\u003cbr/\u003efilter2(f, sin2theta)\u003cbr/\u003eridgeorient.m:76\"]\n    \n    RECOVER[\"Recover orientation\u003cbr/\u003eorientim = π/2 + atan2(sin2theta, cos2theta)/2\u003cbr/\u003eridgeorient.m:78\"]\n    \n    ANGLES --\u003e FILTER_COS\n    ANGLES --\u003e FILTER_SIN\n    GAUSSIAN -.-\u003e|\"smooths\"| FILTER_COS\n    GAUSSIAN -.-\u003e|\"smooths\"| FILTER_SIN\n    FILTER_COS --\u003e RECOVER\n    FILTER_SIN --\u003e RECOVER\n```\n\nSources: [FExtraction/ridgeorient.m:73-78]()\n\n## Reliability Estimation\n\nThe algorithm computes a reliability measure that quantifies confidence in the estimated orientation at each pixel. This is based on the ratio of moments of inertia about the principal axes.\n\n**Reliability Calculation** [FExtraction/ridgeorient.m:80-96]():\n\n1. **Minimum Moment of Inertia** (about estimated orientation axis):\n   ```\n   Imin = (Gyy + Gxx)/2 - (Gxx - Gyy)·cos2theta/2 - Gxy·sin2theta/2\n   ```\n\n2. **Maximum Moment of Inertia** (perpendicular axis):\n   ```\n   Imax = Gyy + Gxx - Imin\n   ```\n\n3. **Reliability Measure**:\n   ```\n   reliability = 1 - Imin/(Imax + 0.001)\n   ```\n\n4. **Masking**: Reliability is set to zero where the denominator in the original orientation calculation was small (`denom \u003e 0.001`)\n\n**Interpretation:**\n- `reliability ≈ 1`: Strong directional structure (ridges clearly oriented)\n- `reliability ≈ 0`: Weak directional structure (isotropic or noisy region)\n- Threshold: Values above 0.5 are generally considered reliable [FExtraction/ridgeorient.m:22]()\n\nSources: [FExtraction/ridgeorient.m:80-96]()\n\n## Supporting Utility Functions\n\n### smoothen_orientation_image\n\nThe [FExtraction/smoothen_orientation_image.m]() function provides an alternative vectorial smoothing implementation used in some enhancement workflows.\n\n**Algorithm** [FExtraction/smoothen_orientation_image.m:15-28]():\n\n```mermaid\ngraph LR\n    OIMG[\"oimg\u003cbr/\u003e(orientation image)\"]\n    \n    DOUBLE[\"Convert to double angle\u003cbr/\u003egx = cos(2*oimg)\u003cbr/\u003egy = sin(2*oimg)\u003cbr/\u003esmoothen_orientation_image.m:19-20\"]\n    \n    FILTER[\"Apply 5x5 Gaussian\u003cbr/\u003efspecial('gaussian',5)\u003cbr/\u003eimfilter with symmetric padding\u003cbr/\u003esmoothen_orientation_image.m:22-24\"]\n    \n    RECOVER[\"Recover orientation\u003cbr/\u003enoimg = 0.5*atan2(gfy,gfx)\u003cbr/\u003esmoothen_orientation_image.m:25-27\"]\n    \n    OIMG --\u003e DOUBLE\n    DOUBLE --\u003e FILTER\n    FILTER --\u003e RECOVER\n```\n\nThis function differs from the smoothing in `ridgeorient` by:\n- Using a fixed 5×5 Gaussian kernel\n- Normalizing output to [0, 2π) range\n- Operating on pre-computed orientation images rather than double-angle components\n\nSources: [FExtraction/smoothen_orientation_image.m:1-28]()\n\n### compute_coherence\n\nThe [FExtraction/compute_coherence.m]() function computes a coherence measure from an orientation image, quantifying the local uniformity of ridge direction.\n\n**Algorithm** [FExtraction/compute_coherence.m:14-31]():\n\n1. Pad image by reflecting boundary regions (N=2 pixels) [FExtraction/compute_coherence.m:21-22]()\n2. For each pixel, extract 5×5 neighborhood (2N+1 = 5)\n3. Compute coherence as: `sum(sum(abs(cos(blk - th)))) / 25`\n   - `th` is the center pixel orientation\n   - `blk` is the neighborhood block\n   - Measures average angular agreement with center\n\n**Output Range:**\n- `cimg = 1`: Perfect coherence (all orientations match)\n- `cimg = 0`: No coherence (random orientations)\n\n**Diagram: Coherence Computation Structure**\n\n```mermaid\ngraph TD\n    INPUT[\"oimg\u003cbr/\u003e(orientation image)\"]\n    \n    PAD[\"Pad image boundaries\u003cbr/\u003eN=2 pixels\u003cbr/\u003eflipud/fliplr\u003cbr/\u003ecompute_coherence.m:21-22\"]\n    \n    LOOP[\"For each pixel (i,j)\u003cbr/\u003ecompute_coherence.m:24-30\"]\n    \n    BLOCK[\"Extract 5x5 block\u003cbr/\u003eblk = oimg(i-N:i+N, j-N:j+N)\u003cbr/\u003ecompute_coherence.m:27\"]\n    \n    CENTER[\"Center orientation\u003cbr/\u003eth = oimg(i,j)\u003cbr/\u003ecompute_coherence.m:26\"]\n    \n    COMPUTE[\"Coherence value\u003cbr/\u003esum(sum(abs(cos(blk-th)))) / 25\u003cbr/\u003ecompute_coherence.m:28\"]\n    \n    OUTPUT[\"cimg\u003cbr/\u003e(coherence image)\"]\n    \n    INPUT --\u003e PAD\n    PAD --\u003e LOOP\n    LOOP --\u003e BLOCK\n    LOOP --\u003e CENTER\n    BLOCK --\u003e COMPUTE\n    CENTER --\u003e COMPUTE\n    COMPUTE --\u003e OUTPUT\n```\n\nSources: [FExtraction/compute_coherence.m:1-31]()\n\n## Function Signatures and Usage\n\n**Primary Function:**\n\n```matlab\n[orientim, reliability] = ridgeorient(im, gradientsigma, blocksigma, orientsmoothsigma)\n```\n\nTypical invocation for 500 DPI fingerprint images [FExtraction/ridgeorient.m:28]():\n```matlab\n[orientim, reliability] = ridgeorient(im, 1, 3, 3);\n```\n\n**Supporting Functions:**\n\n```matlab\nnoimg = smoothen_orientation_image(oimg)\n```\n\n```matlab\ncimg = compute_coherence(oimg)\n```\n\nSources: [FExtraction/ridgeorient.m:40-41](), [FExtraction/smoothen_orientation_image.m:15](), [FExtraction/compute_coherence.m:14]()\n\n## Output Format\n\nThe `ridgeorient` function returns two outputs:\n\n| Output | Type | Description | Range |\n|--------|------|-------------|-------|\n| `orientim` | 2D array (rows×cols) | Orientation in radians, positive clockwise, direction **along** ridges | [0, π) |\n| `reliability` | 2D array (rows×cols) | Confidence measure for orientation estimate | [0, 1] |\n\nThe orientation convention specifies that angles point **along** the ridge direction (not perpendicular to it) [FExtraction/ridgeorient.m:15-18]().\n\nSources: [FExtraction/ridgeorient.m:15-22]()\n\n## Integration with Feature Extraction Pipeline\n\nRidge orientation estimation sits between normalization and frequency analysis in the feature extraction pipeline:\n\n```mermaid\ngraph LR\n    SEG[\"ridgesegment.m\u003cbr/\u003eNormalization\"]\n    \n    ORIENT[\"ridgeorient.m\u003cbr/\u003eOrientation Estimation\"]\n    \n    FREQ[\"ridgefreq.m\u003cbr/\u003eFrequency Estimation\"]\n    \n    FILTER[\"ridgefilter.m\u003cbr/\u003eOriented Filtering\"]\n    \n    SEG --\u003e|\"normalized image\u003cbr/\u003emask\"| ORIENT\n    ORIENT --\u003e|\"orientim\u003cbr/\u003ereliability\"| FREQ\n    ORIENT --\u003e|\"orientim\"| FILTER\n    FREQ --\u003e|\"freq image\"| FILTER\n```\n\nThe orientation image is consumed by:\n- **ridgefreq** [Ridge Frequency Estimation](#3.1.3): Uses orientation to determine ridge wavelength perpendicular to ridge direction\n- **ridgefilter** [Ridge Filter Enhancement](#3.1.4): Uses orientation to align Gabor filters with local ridge structure\n- **fft_enhance_cubs** [FFT-Based Enhancement](#3.1.5): Alternative enhancement path that may use or recompute orientation\n\nSources: [FExtraction/ridgeorient.m:30]()"])</script><script>self.__next_f.push([1,"2a:T38c7,"])</script><script>self.__next_f.push([1,"# Ridge Frequency Estimation\n\n\u003cdetails\u003e\n\u003csummary\u003eRelevant source files\u003c/summary\u003e\n\nThe following files were used as context for generating this wiki page:\n\n- [FExtraction/freqest.m](FExtraction/freqest.m)\n- [FExtraction/ridgefreq.m](FExtraction/ridgefreq.m)\n- [FExtraction/smoothen_frequency_image.m](FExtraction/smoothen_frequency_image.m)\n\n\u003c/details\u003e\n\n\n\n## Purpose and Scope\n\nThis document explains how ridge spatial frequency is calculated across a fingerprint image through block-wise analysis and wavelength detection. Ridge frequency represents the number of ridges per unit distance perpendicular to the ridge flow, and is a critical parameter for the subsequent enhancement filtering stage.\n\nThe frequency estimation process operates on the normalized image and orientation map produced in earlier stages (see [Image Segmentation and Normalization](#3.1.1) and [Ridge Orientation Estimation](#3.1.2)). The computed frequency image is used by the ridge filter enhancement algorithm (see [Ridge Filter Enhancement](#3.1.4)).\n\n**Sources:** [FExtraction/ridgefreq.m:1-74]()\n\n---\n\n## System Overview\n\nThe ridge frequency estimation system consists of three primary components working in sequence:\n\n1. **Block-wise processing** ([FExtraction/ridgefreq.m]()): Divides the fingerprint image into overlapping or non-overlapping blocks\n2. **Per-block frequency estimation** ([FExtraction/freqest.m]()): Computes spatial frequency within each block using projection-based peak detection\n3. **Optional smoothing** ([FExtraction/smoothen_frequency_image.m]()): Refines the frequency map through iterative diffusion\n\n```mermaid\ngraph TD\n    Input1[\"Normalized Image (im)\"]\n    Input2[\"Ridge Mask (mask)\"]\n    Input3[\"Orientation Image (orientim)\"]\n    \n    Process1[\"ridgefreq()\"]\n    Process2[\"Block Partitioning\u003cbr/\u003eLoop: r=1:blksze:rows-blksze\u003cbr/\u003eLoop: c=1:blksze:cols-blksze\"]\n    Process3[\"freqest()\u003cbr/\u003ePer-block estimation\"]\n    Process4[\"Frequency Masking\u003cbr/\u003efreq = freq .* mask\"]\n    Process5[\"Median Calculation\u003cbr/\u003emedian(freq(find(freq\u003e0)))\"]\n    \n    Output1[\"Frequency Image (freq)\"]\n    Output2[\"Median Frequency (medianfreq)\"]\n    \n    Optional[\"smoothen_frequency_image()\u003cbr/\u003eDiffusion-based refinement\"]\n    OutputSmooth[\"Smoothed Frequency Image (nfimg)\"]\n    \n    Input1 --\u003e Process1\n    Input2 --\u003e Process1\n    Input3 --\u003e Process1\n    Process1 --\u003e Process2\n    Process2 --\u003e Process3\n    Process3 --\u003e Process4\n    Process4 --\u003e Process5\n    Process4 --\u003e Output1\n    Process5 --\u003e Output2\n    \n    Output1 -.-\u003e|\"optional\"| Optional\n    Optional -.-\u003e OutputSmooth\n    \n    style Process3 fill:#f0f0f0\n    style Optional fill:#e0e0e0\n```\n\n**Diagram: Ridge Frequency Estimation Pipeline**\n\n**Sources:** [FExtraction/ridgefreq.m:53-74](), [FExtraction/freqest.m:40-104](), [FExtraction/smoothen_frequency_image.m:18-59]()\n\n---\n\n## Block-wise Processing Architecture\n\nThe `ridgefreq` function divides the input fingerprint image into rectangular blocks and estimates frequency independently for each block. This approach allows the algorithm to adapt to local variations in ridge spacing across the fingerprint.\n\n### Function Signature\n\n```\n[freq, medianfreq] = ridgefreq(im, mask, orient, blksze, windsze, minWaveLength, maxWaveLength)\n```\n\n**Sources:** [FExtraction/ridgefreq.m:53-54]()\n\n### Input Parameters\n\n| Parameter | Type | Description |\n|-----------|------|-------------|\n| `im` | 2D matrix | Normalized fingerprint image |\n| `mask` | Binary matrix | Ridge region mask from segmentation |\n| `orient` | 2D matrix | Ridge orientation image (radians) |\n| `blksze` | Integer | Block size in pixels (typically 32) |\n| `windsze` | Integer | Peak detection window size (odd integer, e.g., 3 or 5) |\n| `minWaveLength` | Integer | Minimum acceptable ridge wavelength in pixels (e.g., 5) |\n| `maxWaveLength` | Integer | Maximum acceptable ridge wavelength in pixels (e.g., 15) |\n\n**Sources:** [FExtraction/ridgefreq.m:11-19]()\n\n### Block Iteration Strategy\n\nThe function uses nested loops to process blocks in a raster scan pattern:\n\n```\nfor r = 1:blksze:rows-blksze\n    for c = 1:blksze:cols-blksze\n        blkim = im(r:r+blksze-1, c:c+blksze-1)\n        blkor = orient(r:r+blksze-1, c:c+blksze-1)\n        freq(r:r+blksze-1, c:c+blksze-1) = freqest(blkim, blkor, windsze, minWaveLength, maxWaveLength)\n```\n\nThis creates non-overlapping blocks. The loop bounds ensure that all blocks are fully contained within the image boundaries.\n\n**Sources:** [FExtraction/ridgefreq.m:59-67]()\n\n### Post-processing\n\nAfter block-wise estimation, two operations finalize the frequency image:\n\n1. **Masking**: Frequency values outside valid ridge regions are zeroed using the input mask [FExtraction/ridgefreq.m:70]()\n2. **Median calculation**: A single representative frequency is computed from all valid (non-zero) frequency values [FExtraction/ridgefreq.m:73]()\n\nThe median frequency is often more robust than the detailed frequency image for subsequent filtering operations, as noted in the code comments.\n\n**Sources:** [FExtraction/ridgefreq.m:69-73]()\n\n---\n\n## Frequency Estimation Algorithm\n\nThe `freqest` function implements the core frequency estimation algorithm for a single image block. The algorithm operates by rotating the ridge pattern to vertical orientation and detecting periodic peaks in the column-wise projection.\n\n```mermaid\ngraph TD\n    Input[\"Image Block (im)\u003cbr/\u003eOrientation Block (orientim)\"]\n    \n    Step1[\"Mean Orientation Calculation\u003cbr/\u003ecosorient = mean(cos(2*orientim))\u003cbr/\u003esinorient = mean(sin(2*orientim))\u003cbr/\u003eorient = atan2(sinorient,cosorient)/2\"]\n    \n    Step2[\"Ridge Rotation\u003cbr/\u003erotim = imrotate(im, orient/pi*180+90)\"]\n    \n    Step3[\"Image Cropping\u003cbr/\u003ecropsze = fix(rows/sqrt(2))\u003cbr/\u003eRemove invalid border regions\"]\n    \n    Step4[\"Column Projection\u003cbr/\u003eproj = sum(rotim)\"]\n    \n    Step5[\"Peak Detection\u003cbr/\u003edilation = ordfilt2(proj, windsze, ones(1,windsze))\u003cbr/\u003emaxpts = (dilation == proj) \u0026 (proj \u003e mean(proj))\"]\n    \n    Step6[\"Wavelength Calculation\u003cbr/\u003ewaveLength = (maxind(end)-maxind(1))/(NoOfPeaks-1)\"]\n    \n    Step7{\"Valid\u003cbr/\u003eWavelength?\u003cbr/\u003eminWaveLength \u003c λ \u003c maxWaveLength\"}\n    \n    Output1[\"freqim = 1/waveLength * ones(size(im))\"]\n    Output2[\"freqim = zeros(size(im))\"]\n    \n    Input --\u003e Step1\n    Step1 --\u003e Step2\n    Step2 --\u003e Step3\n    Step3 --\u003e Step4\n    Step4 --\u003e Step5\n    Step5 --\u003e Step6\n    Step6 --\u003e Step7\n    Step7 --\u003e|\"Yes\"| Output1\n    Step7 --\u003e|\"No\"| Output2\n    \n    style Step1 fill:#f0f0f0\n    style Step5 fill:#f0f0f0\n    style Step6 fill:#f0f0f0\n```\n\n**Diagram: freqest Algorithm Flow**\n\n**Sources:** [FExtraction/freqest.m:40-104]()\n\n### Mean Orientation Calculation\n\nTo handle orientation wraparound at the 0°/180° boundary, the algorithm averages the doubled orientation angles in Cartesian form before reconstructing the mean orientation:\n\n```\norientim = 2*orientim\ncosorient = mean(cos(orientim))\nsinorient = mean(sin(orientim))\norient = atan2(sinorient, cosorient)/2\n```\n\nThis vectorial averaging technique prevents discontinuities when orientations span the angular origin.\n\n**Sources:** [FExtraction/freqest.m:46-52]()\n\n### Ridge Rotation and Cropping\n\nThe image block is rotated so that ridges align vertically. This simplifies frequency detection to a 1D problem:\n\n1. **Rotation**: The block is rotated by `orient/pi*180 + 90` degrees using nearest-neighbor interpolation [FExtraction/freqest.m:55]()\n2. **Cropping**: To avoid artifacts from invalid rotated regions, the image is cropped to the largest inscribed square that fits within the rotated bounds. The crop size is `rows/sqrt(2)` [FExtraction/freqest.m:60-61]()\n\n**Sources:** [FExtraction/freqest.m:54-61]()\n\n### Column Projection\n\nWith ridges now vertical, the grey values are summed down each column to produce a 1D signal. This projection captures the periodic intensity variation as the summation crosses alternating ridges and valleys:\n\n```\nproj = sum(rotim)\n```\n\nThe resulting projection signal has local maxima at ridge positions.\n\n**Sources:** [FExtraction/freqest.m:65]()\n\n### Peak Detection\n\nPeaks in the projection signal are identified using greyscale morphological dilation:\n\n1. **Dilation**: Apply `ordfilt2` with a 1D window to compute local maxima [FExtraction/freqest.m:70]()\n2. **Peak identification**: A point is a peak if the dilation equals the original value AND the value exceeds the mean [FExtraction/freqest.m:71]()\n3. **Peak indices**: Extract the column positions of detected peaks [FExtraction/freqest.m:72]()\n\nThis morphological approach is robust to noise and small intensity variations.\n\n**Sources:** [FExtraction/freqest.m:67-72]()\n\n### Wavelength Calculation and Validation\n\nRidge wavelength is estimated from peak spacing:\n\n```\nwaveLength = (maxind(end) - maxind(1)) / (NoOfPeaks - 1)\n```\n\nThis computes the average distance between consecutive peaks over the entire projection. The wavelength must satisfy validation constraints:\n\n- At least 2 peaks must be detected [FExtraction/freqest.m:78]()\n- Wavelength must fall within `[minWaveLength, maxWaveLength]` [FExtraction/freqest.m:83]()\n\nIf validation passes, the spatial frequency is computed as the reciprocal: `freq = 1/waveLength`. Otherwise, the block frequency is set to zero, indicating an unreliable estimate.\n\n**Sources:** [FExtraction/freqest.m:74-88]()\n\n---\n\n## Output Format\n\nThe `ridgefreq` function produces two outputs:\n\n### Frequency Image\n\nA 2D matrix the same size as the input image, where each pixel contains the estimated ridge spatial frequency (cycles per pixel) for its block. Regions where frequency cannot be reliably estimated are set to zero.\n\n**Sources:** [FExtraction/ridgefreq.m:22-27]()\n\n### Median Frequency\n\nA scalar representing the median of all valid (non-zero) frequency values across the image. This single value is often used as a global frequency estimate for the entire fingerprint in subsequent filtering operations.\n\nAccording to the code comments, the median frequency tends to be more useful than the detailed frequency image due to potential deficiencies in the block-wise estimation.\n\n**Sources:** [FExtraction/ridgefreq.m:28-36](), [FExtraction/ridgefreq.m:73]()\n\n---\n\n## Frequency Image Smoothing\n\nThe optional `smoothen_frequency_image` function refines the raw frequency image through iterative diffusion. This process reduces noise and fills in regions where initial frequency estimation failed.\n\n### Function Signature\n\n```\nnfimg = smoothen_frequency_image(fimg, RLOW, RHIGH, diff_cycles)\n```\n\n| Parameter | Description |\n|-----------|-------------|\n| `fimg` | Input frequency image |\n| `RLOW` | Minimum valid ridge separation |\n| `RHIGH` | Maximum valid ridge separation |\n| `diff_cycles` | Number of diffusion iterations |\n| `nfimg` | Output smoothed frequency image |\n\n**Sources:** [FExtraction/smoothen_frequency_image.m:1-18]()\n\n### Diffusion Algorithm\n\nThe smoothing process uses weighted Gaussian averaging with validity constraints:\n\n```mermaid\ngraph TD\n    Init[\"Initialize\u003cbr/\u003enfimg = fimg\u003cbr/\u003eN = 1\u003cbr/\u003ecycles = 0\"]\n    \n    Check{\"invalid_cnt \u003e 0\u003cbr/\u003eAND\u003cbr/\u003ecycles \u003c diff_cycles\"}\n    \n    Pad[\"Image Padding\u003cbr/\u003eReflect rows and columns\u003cbr/\u003eby N pixels\"]\n    \n    Loop[\"For each pixel (i,j)\"]\n    \n    Extract[\"Extract neighborhood\u003cbr/\u003eblk = fimg(i-N:i+N, j-N:j+N)\"]\n    \n    Mask[\"Create validity mask\u003cbr/\u003emsk = (blk\u003e=RLOW \u0026 blk\u003c=RHIGH)\"]\n    \n    ValidCheck{\"sum(msk)\u003cbr/\u003e\u003e= valid_nbrs\u003cbr/\u003e(3)\"}\n    \n    Diffuse[\"Apply Gaussian filter\u003cbr/\u003enfimg(i,j) = sum(blk.*h) / sum(h.*msk)\"]\n    \n    Invalid[\"nfimg(i,j) = -1\"]\n    \n    Update[\"fimg = nfimg\u003cbr/\u003ecycles = cycles + 1\u003cbr/\u003eRecalculate invalid_cnt\"]\n    \n    Output[\"Return nfimg\"]\n    \n    Init --\u003e Check\n    Check --\u003e|\"Yes\"| Pad\n    Check --\u003e|\"No\"| Output\n    Pad --\u003e Loop\n    Loop --\u003e Extract\n    Extract --\u003e Mask\n    Mask --\u003e ValidCheck\n    ValidCheck --\u003e|\"Yes\"| Diffuse\n    ValidCheck --\u003e|\"No\"| Invalid\n    Diffuse --\u003e Update\n    Invalid --\u003e Update\n    Update --\u003e Check\n    \n    style Diffuse fill:#f0f0f0\n    style ValidCheck fill:#f0f0f0\n```\n\n**Diagram: Frequency Image Smoothing via Diffusion**\n\n**Sources:** [FExtraction/smoothen_frequency_image.m:18-59]()\n\n### Key Features\n\n1. **Validity filtering**: Only pixels within `[RLOW, RHIGH]` contribute to the weighted average [FExtraction/smoothen_frequency_image.m:42]()\n2. **Neighbor threshold**: At least 3 valid neighbors must exist for diffusion to occur [FExtraction/smoothen_frequency_image.m:19]()\n3. **Normalized weighting**: The Gaussian weights are normalized by the sum of weights over valid neighbors [FExtraction/smoothen_frequency_image.m:45]()\n4. **Iterative refinement**: The process repeats until all pixels are valid or the maximum cycle count is reached [FExtraction/smoothen_frequency_image.m:30]()\n\n**Sources:** [FExtraction/smoothen_frequency_image.m:19-57]()\n\n---\n\n## Typical Parameter Values\n\nThe following table summarizes typical parameter values for a 500 DPI fingerprint image:\n\n| Parameter | Typical Value | Rationale |\n|-----------|---------------|-----------|\n| `blksze` | 32 pixels | Balances local adaptation with statistical reliability |\n| `windsze` | 3 or 5 pixels | Small odd window for morphological peak detection |\n| `minWaveLength` | 5 pixels | ~0.25mm at 500 DPI (assumes ridges not closer than 0.25mm) |\n| `maxWaveLength` | 15 pixels | ~0.76mm at 500 DPI (assumes ridges not farther than 0.76mm) |\n| `diff_cycles` | 10-20 | Number of diffusion iterations for smoothing |\n| `RLOW` / `RHIGH` | Based on wavelength bounds | Typically `1/maxWaveLength` to `1/minWaveLength` |\n\nFor a 500 DPI image, typical inter-ridge distances range from 0.3mm to 0.5mm (approximately 6-10 pixels).\n\n**Sources:** [FExtraction/ridgefreq.m:31-32](), [FExtraction/freqest.m:24-25]()\n\n---\n\n## Integration with Pipeline\n\nThe ridge frequency estimation stage receives inputs from previous stages and provides outputs to subsequent stages:\n\n### Inputs Required\n\n- **Normalized image** from [Image Segmentation and Normalization](#3.1.1)\n- **Ridge mask** from [Image Segmentation and Normalization](#3.1.1)\n- **Orientation image** from [Ridge Orientation Estimation](#3.1.2)\n\n### Outputs Provided\n\n- **Frequency image**: Used by [Ridge Filter Enhancement](#3.1.4) for adaptive Gabor filtering\n- **Median frequency**: Often used as a global frequency parameter in filtering\n\nThe frequency information enables the ridge filter to adapt its wavelength to local ridge spacing, producing optimal enhancement across the entire fingerprint.\n\n**Sources:** [FExtraction/ridgefreq.m:8-14](), [FExtraction/ridgefreq.m:38]()"])</script><script>self.__next_f.push([1,"2b:T40ca,"])</script><script>self.__next_f.push([1,"# Ridge Filter Enhancement\n\n\u003cdetails\u003e\n\u003csummary\u003eRelevant source files\u003c/summary\u003e\n\nThe following files were used as context for generating this wiki page:\n\n- [FExtraction/ridgefilter.m](FExtraction/ridgefilter.m)\n- [FExtraction/ridgefreq.m](FExtraction/ridgefreq.m)\n- [FExtraction/ridgeorient.m](FExtraction/ridgeorient.m)\n\n\u003c/details\u003e\n\n\n\n## Purpose and Scope\n\nThis page documents the ridge filter enhancement process implemented in `ridgefilter.m`, which performs oriented Gabor-like filtering to enhance fingerprint ridge patterns. This is the final stage of the standard feature extraction pipeline and produces an enhanced fingerprint image suitable for minutiae extraction.\n\nFor information about the prerequisite orientation estimation, see [Ridge Orientation Estimation](#3.1.2). For information about the prerequisite frequency estimation, see [Ridge Frequency Estimation](#3.1.3). For an alternative enhancement approach, see [FFT-Based Enhancement](#3.1.5).\n\n**Sources:** [FExtraction/ridgefilter.m:1-42]()\n\n---\n\n## Enhancement Approach\n\nThe `ridgefilter` function implements the enhancement algorithm described by Hong, Wan, and Jain (1998). The method applies orientation-selective Gabor-like filters that are tuned to the local ridge frequency and orientation at each pixel. The filtering process preserves ridge structures while suppressing noise and bridging gaps in ridge patterns.\n\nThe core principle is to convolve the input image with even-symmetric Gabor filters whose parameters (orientation, frequency, bandwidth) are adapted to match the local fingerprint characteristics determined in previous stages.\n\n**Sources:** [FExtraction/ridgefilter.m:29-42]()\n\n---\n\n## Data Flow Architecture\n\n```mermaid\ngraph TB\n    subgraph \"Input Data\"\n        IM[\"im\u003cbr/\u003e(Input Image)\"]\n        ORIENT[\"orientim\u003cbr/\u003e(Orientation Map)\"]\n        FREQ[\"freqim\u003cbr/\u003e(Frequency Map)\"]\n        KX[\"kx parameter\u003cbr/\u003e(Along-ridge sigma)\"]\n        KY[\"ky parameter\u003cbr/\u003e(Across-ridge sigma)\"]\n    end\n    \n    subgraph \"Filter Bank Generation\"\n        ROUND[\"Round frequencies\u003cbr/\u003efreq(ind) = round(freq(ind)*100)/100\u003cbr/\u003eLines 60\"]\n        UNIQ[\"Extract unique frequencies\u003cbr/\u003eunfreq = unique(freq(ind))\u003cbr/\u003eLine 64\"]\n        FIDX[\"Build frequency index\u003cbr/\u003efreqindex array\u003cbr/\u003eLines 69-72\"]\n        GEN[\"Generate filters\u003cbr/\u003ecell(length(unfreq), 180/angleInc)\u003cbr/\u003eLines 76-95\"]\n    end\n    \n    subgraph \"Filter Design\"\n        SIGMA[\"Compute sigmas\u003cbr/\u003esigmax = 1/unfreq(k)*kx\u003cbr/\u003esigmay = 1/unfreq(k)*ky\u003cbr/\u003eLines 80-81\"]\n        GRID[\"Create mesh grid\u003cbr/\u003emeshgrid(-sze(k):sze(k))\u003cbr/\u003eLine 84\"]\n        GABOR[\"Generate Gabor filter\u003cbr/\u003eexp(-(x.^2/sigmax^2 + y.^2/sigmay^2)/2)\u003cbr/\u003e.*cos(2*pi*unfreq(k)*x)\u003cbr/\u003eLines 85-86\"]\n        ROT[\"Rotate filters\u003cbr/\u003eimrotate 3-degree increments\u003cbr/\u003eLines 92-94\"]\n    end\n    \n    subgraph \"Application Process\"\n        VALID[\"Find valid regions\u003cbr/\u003evalidr\u003emaxsze \u0026 validr\u003crows-maxsze\u003cbr/\u003eLines 104-105\"]\n        OIDX[\"Convert orientations to indices\u003cbr/\u003eorientindex = round(orient/pi*180/angleInc)\u003cbr/\u003eLines 110-113\"]\n        APPLY[\"Apply matched filter\u003cbr/\u003esum(sum(im(r-s:r+s, c-s:c+s).*filter{...}))\u003cbr/\u003eLines 116-125\"]\n    end\n    \n    OUTPUT[\"newim\u003cbr/\u003e(Enhanced Image)\"]\n    \n    IM --\u003e ROUND\n    FREQ --\u003e ROUND\n    ORIENT --\u003e OIDX\n    \n    ROUND --\u003e UNIQ\n    UNIQ --\u003e FIDX\n    UNIQ --\u003e GEN\n    \n    GEN --\u003e SIGMA\n    SIGMA --\u003e GRID\n    GRID --\u003e GABOR\n    GABOR --\u003e ROT\n    ROT --\u003e APPLY\n    \n    IM --\u003e APPLY\n    FIDX --\u003e APPLY\n    OIDX --\u003e APPLY\n    VALID --\u003e APPLY\n    \n    KX --\u003e SIGMA\n    KY --\u003e SIGMA\n    \n    APPLY --\u003e OUTPUT\n```\n\n**Filter Bank Generation Flow**: The function processes the frequency map to identify distinct frequency values, generates a Gabor filter for each unique frequency, and creates rotated versions at 3-degree increments to cover all orientations.\n\n**Sources:** [FExtraction/ridgefilter.m:42-129]()\n\n---\n\n## Filter Bank Generation Process\n\n### Frequency Discretization\n\nThe algorithm begins by discretizing the frequency map to reduce computational cost:\n\n| Operation | Code Reference | Purpose |\n|-----------|----------------|---------|\n| Find valid regions | `[validr,validc] = find(freq \u003e 0)` [line 55]() | Identify pixels with valid frequency estimates |\n| Round frequencies | `freq(ind) = round(freq(ind)*100)/100` [line 60]() | Reduce to 0.01 precision to limit distinct frequencies |\n| Extract unique values | `unfreq = unique(freq(ind))` [line 64]() | Obtain set of distinct frequencies to process |\n| Build lookup table | `freqindex` array [lines 69-72]() | Map frequency×100 to index in `unfreq` array |\n\nThis discretization typically reduces hundreds of unique frequency values to a manageable set (e.g., 10-30 distinct frequencies).\n\n**Sources:** [FExtraction/ridgefilter.m:55-72]()\n\n### Filter Design Parameters\n\nThe Gabor filter for each frequency is designed with scale-invariant parameters:\n\n```mermaid\ngraph LR\n    subgraph \"Filter Parameters\"\n        FREQ[\"unfreq(k)\u003cbr/\u003e(Ridge Frequency)\"]\n        KX[\"kx\u003cbr/\u003e(Bandwidth Factor)\"]\n        KY[\"ky\u003cbr/\u003e(Orientation Factor)\"]\n    end\n    \n    subgraph \"Computed Sigmas\"\n        SIGMAX[\"sigmax = 1/unfreq(k)*kx\u003cbr/\u003eControls along-ridge bandwidth\"]\n        SIGMAY[\"sigmay = 1/unfreq(k)*ky\u003cbr/\u003eControls orientation selectivity\"]\n    end\n    \n    subgraph \"Filter Size\"\n        SZE[\"sze(k) = round(3*max(sigmax,sigmay))\u003cbr/\u003eExtent: -sze to +sze\"]\n    end\n    \n    FREQ --\u003e SIGMAX\n    FREQ --\u003e SIGMAY\n    KX --\u003e SIGMAX\n    KY --\u003e SIGMAY\n    SIGMAX --\u003e SZE\n    SIGMAY --\u003e SZE\n```\n\n**Parameter Interpretation:**\n- **`kx`**: Controls filter bandwidth along ridge direction (typical value: 0.5)\n- **`ky`**: Controls orientation selectivity across ridges (typical value: 0.5)\n- **`sigmax`**: Standard deviation along filter x-axis (ridge direction)\n- **`sigmay`**: Standard deviation along filter y-axis (perpendicular to ridges)\n- **`sze(k)`**: Filter spatial extent (window size: `(2*sze+1) × (2*sze+1)`)\n\n**Sources:** [FExtraction/ridgefilter.m:80-84]()\n\n### Gabor Filter Equation\n\nThe reference filter is an even-symmetric Gabor function:\n\n```\nreffilter(x,y) = exp(-(x²/σₓ² + y²/σᵧ²)/2) · cos(2π·f·x)\n```\n\n**Components:**\n- **Gaussian envelope**: `exp(-(x²/σₓ² + y²/σᵧ²)/2)` provides spatial localization with elliptical shape\n- **Cosine carrier**: `cos(2π·f·x)` provides frequency selectivity at frequency `f = unfreq(k)`\n- **Orientation**: Carrier oscillates along x-axis; rotation aligns to ridge direction\n\nThe filter is implemented at [FExtraction/ridgefilter.m:85-86]():\n\n```matlab\nreffilter = exp(-(x.^2/sigmax^2 + y.^2/sigmay^2)/2) .* cos(2*pi*unfreq(k)*x);\n```\n\n**Sources:** [FExtraction/ridgefilter.m:84-86]()\n\n### Rotation and Storage\n\nFor each frequency, the algorithm generates rotated versions covering all orientations:\n\n| Parameter | Value | Description |\n|-----------|-------|-------------|\n| `angleInc` | 3° | Angular spacing between filter orientations [line 48]() |\n| Number of angles | 180/angleInc = 60 | Total orientations per frequency |\n| Rotation direction | `-(o*angleInc+90)` | Negative for anticlockwise, +90° to align with ridge direction [line 93]() |\n| Rotation method | `'bilinear'` | Interpolation method for rotation [line 93]() |\n| Crop mode | `'crop'` | Maintains original filter size after rotation [line 93]() |\n\nThe filter bank is stored in a cell array: `filter{frequencyIndex, orientationIndex}` where:\n- **frequencyIndex**: 1 to `length(unfreq)`\n- **orientationIndex**: 1 to `180/angleInc` (typically 60)\n\n**Sources:** [FExtraction/ridgefilter.m:48-95]()\n\n---\n\n## Filter Application Process\n\n### Valid Region Selection\n\nThe algorithm restricts filtering to interior regions to avoid boundary effects:\n\n```mermaid\ngraph TB\n    FINDVALID[\"Find valid pixels\u003cbr/\u003e[validr,validc] = find(freq \u003e 0)\u003cbr/\u003eLine 55\"]\n    MAXSZE[\"Determine max filter size\u003cbr/\u003emaxsze = sze(1)\u003cbr/\u003eLine 103\"]\n    BOUNDARY[\"Apply boundary constraints\u003cbr/\u003evalidr\u003emaxsze \u0026 validr\u003crows-maxsze \u0026\u003cbr/\u003evalidc\u003emaxsze \u0026 validc\u003ccols-maxsze\u003cbr/\u003eLines 104-105\"]\n    FINALIND[\"finalind array\u003cbr/\u003eIndices of pixels to process\"]\n    \n    FINDVALID --\u003e BOUNDARY\n    MAXSZE --\u003e BOUNDARY\n    BOUNDARY --\u003e FINALIND\n```\n\nThis ensures that the filter window `(r-s:r+s, c-s:c+s)` never extends beyond image boundaries.\n\n**Sources:** [FExtraction/ridgefilter.m:101-105]()\n\n### Orientation Index Mapping\n\nRidge orientations are converted from radians to discrete filter indices:\n\n```mermaid\ngraph LR\n    ORIENT[\"orientim\u003cbr/\u003e(Radians)\"]\n    CONVERT[\"Convert to degrees and discretize\u003cbr/\u003eorientindex = round(orient/pi*180/angleInc)\u003cbr/\u003eLine 110\"]\n    WRAP1[\"Wrap negative values\u003cbr/\u003eif orientindex \u003c 1:\u003cbr/\u003e  orientindex += maxorientindex\u003cbr/\u003eLines 111\"]\n    WRAP2[\"Wrap values \u003e max\u003cbr/\u003eif orientindex \u003e maxorientindex:\u003cbr/\u003e  orientindex -= maxorientindex\u003cbr/\u003eLines 112-113\"]\n    FINAL[\"orientindex\u003cbr/\u003e(Discrete indices)\"]\n    \n    ORIENT --\u003e CONVERT\n    CONVERT --\u003e WRAP1\n    WRAP1 --\u003e WRAP2\n    WRAP2 --\u003e FINAL\n```\n\n**Mapping Logic:**\n- Divide radians by π, multiply by 180 to get degrees\n- Divide by `angleInc` (3°) and round to nearest integer\n- Wrap values to range [1, maxorientindex] to handle circular orientation space\n\n**Sources:** [FExtraction/ridgefilter.m:107-113]()\n\n### Pixel-by-Pixel Filtering\n\nFor each valid pixel, the algorithm applies the appropriate filter:\n\n```mermaid\ngraph TB\n    LOOP[\"For each pixel in finalind\u003cbr/\u003ek = 1:length(finalind)\u003cbr/\u003eLines 116-125\"]\n    \n    subgraph \"Per-Pixel Operations\"\n        GETRC[\"Get row, col\u003cbr/\u003er = validr(finalind(k))\u003cbr/\u003ec = validc(finalind(k))\u003cbr/\u003eLines 117-118\"]\n        GETFREQ[\"Find frequency index\u003cbr/\u003efilterindex = freqindex(round(freq(r,c)*100))\u003cbr/\u003eLine 121\"]\n        GETSZE[\"Get filter size\u003cbr/\u003es = sze(filterindex)\u003cbr/\u003eLine 123\"]\n        EXTRACT[\"Extract image region\u003cbr/\u003eim(r-s:r+s, c-s:c+s)\"]\n        GETFILT[\"Get matched filter\u003cbr/\u003efilter{filterindex, orientindex(r,c)}\"]\n        CONVOLVE[\"Compute convolution\u003cbr/\u003esum(sum(region .* filter))\u003cbr/\u003eLine 124\"]\n        STORE[\"Store result\u003cbr/\u003enewim(r,c) = value\u003cbr/\u003eLine 124\"]\n    end\n    \n    LOOP --\u003e GETRC\n    GETRC --\u003e GETFREQ\n    GETFREQ --\u003e GETSZE\n    GETSZE --\u003e EXTRACT\n    GETSZE --\u003e GETFILT\n    EXTRACT --\u003e CONVOLVE\n    GETFILT --\u003e CONVOLVE\n    CONVOLVE --\u003e STORE\n    STORE --\u003e LOOP\n```\n\n**Filtering Operation at [line 124]():**\n\n```matlab\nnewim(r,c) = sum(sum(im(r-s:r+s, c-s:c+s).*filter{filterindex,orientindex(r,c)}));\n```\n\nThis performs element-wise multiplication between the image region and the matched filter, then sums all values to produce the filtered output.\n\n**Sources:** [FExtraction/ridgefilter.m:116-125]()\n\n---\n\n## Function Signature and Parameters\n\n```mermaid\ngraph TB\n    subgraph \"Function: ridgefilter\"\n        direction TB\n        \n        subgraph \"Required Inputs\"\n            IN1[\"im\u003cbr/\u003e(double array)\u003cbr/\u003eNormalized fingerprint image\"]\n            IN2[\"orient\u003cbr/\u003e(double array)\u003cbr/\u003eOrientation map in radians\u003cbr/\u003eFrom ridgeorient.m\"]\n            IN3[\"freq\u003cbr/\u003e(double array)\u003cbr/\u003eFrequency map in cycles/pixel\u003cbr/\u003eFrom ridgefreq.m\"]\n            IN4[\"kx\u003cbr/\u003e(scalar double)\u003cbr/\u003eAlong-ridge sigma factor\u003cbr/\u003eTypical: 0.5\"]\n            IN5[\"ky\u003cbr/\u003e(scalar double)\u003cbr/\u003eAcross-ridge sigma factor\u003cbr/\u003eTypical: 0.5\"]\n        end\n        \n        subgraph \"Optional Input\"\n            IN6[\"showfilter\u003cbr/\u003e(0 or 1)\u003cbr/\u003eDisplay largest filter\u003cbr/\u003eDefault: 0\u003cbr/\u003eLines 44-46\"]\n        end\n        \n        subgraph \"Output\"\n            OUT[\"newim\u003cbr/\u003e(double array)\u003cbr/\u003eEnhanced fingerprint image\u003cbr/\u003eSame size as input\"]\n        end\n    end\n    \n    IN1 --\u003e OUT\n    IN2 --\u003e OUT\n    IN3 --\u003e OUT\n    IN4 --\u003e OUT\n    IN5 --\u003e OUT\n    IN6 -.-\u003e|Optional| OUT\n```\n\n**Parameter Guidelines (500 dpi fingerprint):**\n- **kx = 0.5**: Provides reasonable bandwidth along ridges\n- **ky = 0.5**: Provides good orientation selectivity\n- Higher kx values increase filter bandwidth (less frequency selective)\n- Higher ky values reduce orientation selectivity (wider angular response)\n\n**Sources:** [FExtraction/ridgefilter.m:1-46]()\n\n---\n\n## Filter Bank Structure\n\nThe filter bank storage structure:\n\n| Dimension | Size | Description |\n|-----------|------|-------------|\n| Cell array | `length(unfreq) × (180/angleInc)` | Typically N×60 where N=10-30 |\n| First dimension | Number of distinct frequencies | Each frequency has different filter size |\n| Second dimension | 60 orientations | Covers 0° to 177° in 3° increments |\n| Filter size | Variable per frequency | `(2*sze(k)+1)²` where sze depends on frequency |\n| Storage type | `cell` array | Allows variable-sized filters [line 76]() |\n\n**Memory Organization:**\n```\nfilter{1, 1}   → Frequency 1, Orientation 0°\nfilter{1, 2}   → Frequency 1, Orientation 3°\n...\nfilter{1, 60}  → Frequency 1, Orientation 177°\nfilter{2, 1}   → Frequency 2, Orientation 0°\n...\n```\n\n**Sources:** [FExtraction/ridgefilter.m:76-95]()\n\n---\n\n## Algorithm Complexity\n\n### Computational Cost\n\n| Operation | Complexity | Details |\n|-----------|-----------|---------|\n| Filter generation | O(N_f × N_θ × S²) | N_f frequencies, N_θ=60 angles, S=filter size |\n| Filter application | O(W × H × S²) | W×H valid pixels, S²=filter window |\n| Total preprocessing | One-time per frequency set | Amortized across all images with same frequencies |\n\n**Typical Values (500 dpi, 300×300 image):**\n- Distinct frequencies: ~15-25\n- Orientations per frequency: 60\n- Filter sizes: 11×11 to 31×31 depending on frequency\n- Valid pixels to process: ~70,000-80,000 (excluding borders and background)\n\n### Optimization Strategies\n\nThe implementation employs several optimizations:\n\n1. **Frequency discretization** [line 60](): Reduces unique filters from ~90,000 to ~1,500\n2. **Boundary exclusion** [lines 104-105](): Avoids edge cases and invalid regions\n3. **Index-based lookup** [lines 69-72](): O(1) frequency-to-filter mapping\n4. **Cell array storage**: Efficient handling of variable-sized filters\n\n**Sources:** [FExtraction/ridgefilter.m:55-125]()\n\n---\n\n## Output Characteristics\n\nThe enhanced image `newim` has the following properties:\n\n| Property | Description |\n|----------|-------------|\n| Dimensions | Same as input image `im` |\n| Data type | `double` (initialized as `zeros(rows,cols)` at [line 53]()) |\n| Valid regions | Non-zero only where filtering was applied [lines 116-125]() |\n| Background/border | Zero-valued (unprocessed regions) |\n| Value range | Depends on input normalization; typically preserves ridge/valley contrast |\n| Enhancement effect | Strengthened ridges, suppressed noise, bridged gaps |\n\n**Typical Usage Pattern:**\n\nThe enhanced image is subsequently used for:\n- Binary thresholding to create ridge/valley map\n- Thinning to extract ridge skeleton\n- Minutiae detection (terminations and bifurcations)\n\n**Sources:** [FExtraction/ridgefilter.m:42-125]()\n\n---\n\n## Integration with Feature Extraction Pipeline\n\n```mermaid\ngraph LR\n    subgraph \"Upstream Stages\"\n        SEG[\"ridgesegment.m\u003cbr/\u003eNormalization \u0026\u003cbr/\u003eSegmentation\"]\n        ORI[\"ridgeorient.m\u003cbr/\u003eOrientation\u003cbr/\u003eEstimation\"]\n        FREQ[\"ridgefreq.m\u003cbr/\u003eFrequency\u003cbr/\u003eEstimation\"]\n    end\n    \n    subgraph \"Current Stage\"\n        FILT[\"ridgefilter.m\u003cbr/\u003eRidge Filter\u003cbr/\u003eEnhancement\"]\n    end\n    \n    subgraph \"Downstream Stages\"\n        BIN[\"Binarization\"]\n        THIN[\"Thinning\"]\n        MIN[\"Minutiae\u003cbr/\u003eExtraction\"]\n    end\n    \n    SEG --\u003e|\"Normalized image\u003cbr/\u003eBinary mask\"| ORI\n    SEG --\u003e|\"Normalized image\"| FREQ\n    ORI --\u003e|\"Orientation map\"| FREQ\n    \n    SEG --\u003e|\"Normalized image\"| FILT\n    ORI --\u003e|\"Orientation map\"| FILT\n    FREQ --\u003e|\"Frequency map\"| FILT\n    \n    FILT --\u003e|\"Enhanced image\"| BIN\n    BIN --\u003e THIN\n    THIN --\u003e MIN\n```\n\n**Data Dependencies:**\n\nThe `ridgefilter` function requires three inputs from prior stages:\n1. **Normalized image** from `ridgesegment.m`\n2. **Orientation map** from `ridgeorient.m` \n3. **Frequency map** from `ridgefreq.m`\n\nThese dependencies establish `ridgefilter` as the final preprocessing stage before minutiae extraction.\n\n**Sources:** [FExtraction/ridgefilter.m:1-27](), [FExtraction/ridgeorient.m:1-30](), [FExtraction/ridgefreq.m:1-38]()\n\n---\n\n## Reference Implementation\n\nThe implementation is based on the seminal work:\n\n**Hong, L., Wan, Y., and Jain, A. K.** \"Fingerprint image enhancement: Algorithm and performance evaluation.\" *IEEE Transactions on Pattern Analysis and Machine Intelligence* 20, 8 (1998), 777-789.\n\nThis paper established the Gabor filter-based approach as a standard technique in automated fingerprint identification systems (AFIS).\n\n**Sources:** [FExtraction/ridgefilter.m:29-32]()"])</script><script>self.__next_f.push([1,"2c:T48ee,"])</script><script>self.__next_f.push([1,"# FFT-Based Enhancement\n\n\u003cdetails\u003e\n\u003csummary\u003eRelevant source files\u003c/summary\u003e\n\nThe following files were used as context for generating this wiki page:\n\n- [FExtraction/angular_filter_bank.m](FExtraction/angular_filter_bank.m)\n- [FExtraction/compute_coherence.m](FExtraction/compute_coherence.m)\n- [FExtraction/fft_enhance_cubs.m](FExtraction/fft_enhance_cubs.m)\n\n\u003c/details\u003e\n\n\n\n## Purpose and Scope\n\nThis page documents the FFT-based fingerprint enhancement method implemented in [`FExtraction/fft_enhance_cubs.m`](). This algorithm provides an alternative approach to the Gabor-like spatial domain filtering described in [Ridge Filter Enhancement](#3.1.4). Instead of applying oriented filters directly in the spatial domain, this method performs block-wise 2D Fourier analysis with adaptive angular filtering in the frequency domain.\n\nThe FFT enhancement method simultaneously computes multiple feature maps (coherence, orientation, frequency, bandwidth, energy) and produces an enhanced fingerprint image through a two-stage process: FFT analysis followed by filtered reconstruction. For information about the precomputed angular filter banks used by this method, see [Angular Filter Banks](#3.1.6).\n\n---\n\n## Algorithm Overview\n\nThe `fft_enhance_cubs` function implements a two-pass block-based enhancement algorithm that operates in the frequency domain. The method divides the input fingerprint image into overlapping blocks, analyzes each block using 2D FFT to extract ridge characteristics, then reconstructs the enhanced image by applying adaptive angular filters matched to the local ridge orientation and coherence.\n\n**Main Function Signature:**\n```matlab\n[enhimg, cimg, oimg, fimg, bwimg, eimg] = fft_enhance_cubs(img, BLKSZ)\n```\n\n**Outputs:**\n| Output | Description |\n|--------|-------------|\n| `enhimg` | Enhanced fingerprint image (uint8) |\n| `cimg` | Coherence image (0=low coherence, 1=high coherence) |\n| `oimg` | Block orientation image (radians, 0 to π) |\n| `fimg` | Ridge frequency image (pixels per ridge) |\n| `bwimg` | Angular bandwidth image (π/4, π/2, or π radians) |\n| `eimg` | Energy image (log scale, used for segmentation) |\n\nSources: [FExtraction/fft_enhance_cubs.m:1-22]()\n\n---\n\n## Two-Stage Processing Architecture\n\n**Diagram: FFT Enhancement Pipeline**\n```mermaid\ngraph TB\n    INPUT[\"Input Image\u003cbr/\u003e(double)\"]\n    \n    subgraph \"Stage 1: FFT Analysis\"\n        BLOCK1[\"Block Extraction\u003cbr/\u003eoverlapping windows\"]\n        PREPROC[\"Preprocessing:\u003cbr/\u003eDC removal,\u003cbr/\u003espectral window\"]\n        FFT1[\"2D FFT\u003cbr/\u003e(fft2)\"]\n        BPFILTER[\"Bandpass Filter\u003cbr/\u003eButterworth\u003cbr/\u003eRMIN to RMAX\"]\n        ROOT[\"Root Filtering\u003cbr/\u003esqrt(Energy)\"]\n        STATS[\"Feature Extraction:\u003cbr/\u003ecompute_mean_angle()\u003cbr/\u003ecompute_mean_frequency()\"]\n        STORE[\"Store FFT\u003cbr/\u003efftSrc array\"]\n    end\n    \n    subgraph \"Stage 2: Reconstruction\"\n        SMOOTH[\"Feature Smoothing:\u003cbr/\u003esmoothen_orientation_image()\u003cbr/\u003esmoothen_frequency_image()\"]\n        COHERENCE[\"compute_coherence()\u003cbr/\u003efrom oimg\"]\n        BWMAP[\"get_angular_bw_image()\u003cbr/\u003ebandwidth from coherence\"]\n        RETRIEVE[\"Retrieve FFT\u003cbr/\u003efrom fftSrc\"]\n        ANGFILTER[\"get_angular_filter()\u003cbr/\u003eadaptive angular filter\"]\n        IFFT[\"Inverse FFT\u003cbr/\u003e(ifft2)\"]\n        ASSEMBLE[\"Assemble blocks\u003cbr/\u003einto output\"]\n    end\n    \n    ENHANCE[\"Enhanced Image\u003cbr/\u003econtrast stretched\"]\n    SEGMENT[\"Segmentation Mask\u003cbr/\u003efrom energy\"]\n    \n    INPUT --\u003e BLOCK1\n    BLOCK1 --\u003e PREPROC\n    PREPROC --\u003e FFT1\n    FFT1 --\u003e BPFILTER\n    BPFILTER --\u003e ROOT\n    ROOT --\u003e STATS\n    ROOT --\u003e STORE\n    STATS --\u003e |\"oimg, fimg, eimg\"| SMOOTH\n    SMOOTH --\u003e COHERENCE\n    COHERENCE --\u003e BWMAP\n    STORE --\u003e RETRIEVE\n    BWMAP --\u003e ANGFILTER\n    RETRIEVE --\u003e ANGFILTER\n    ANGFILTER --\u003e IFFT\n    IFFT --\u003e ASSEMBLE\n    ASSEMBLE --\u003e ENHANCE\n    STATS --\u003e |\"eimg\"| SEGMENT\n    SEGMENT --\u003e |\"masking\"| ENHANCE\n```\n\nSources: [FExtraction/fft_enhance_cubs.m:22-168]()\n\n---\n\n## Stage 1: Block-Wise FFT Analysis\n\nThe first stage processes the image in overlapping blocks to extract frequency-domain characteristics.\n\n### Block Configuration\n\nThe algorithm uses a sliding window approach with configurable parameters:\n\n| Parameter | Default Value | Purpose |\n|-----------|---------------|---------|\n| `NFFT` | 32 | FFT size (pixels) |\n| `BLKSZ` | 12 | Core block size (pixels) |\n| `OVRLP` | 2 or 6 | Overlap size (pixels) |\n| `ALPHA` | 0.5 | Root filtering exponent |\n| `RMIN` | 3 or 4 | Minimum ridge spacing (pixels) |\n| `RMAX` | 18 or 40 | Maximum ridge spacing (pixels) |\n\nThe window size is `nWndSz = BLKSZ + 2*OVRLP`, creating overlapping analysis regions that reduce blocking artifacts in the final reconstruction.\n\nSources: [FExtraction/fft_enhance_cubs.m:24-43]()\n\n### FFT Analysis Process\n\n**Diagram: Block Processing Flow**\n```mermaid\ngraph LR\n    subgraph \"Block Extraction\"\n        IMG[\"img(nRow:nRow+nWndSz,\u003cbr/\u003enCol:nCol+nWndSz)\"]\n        DC[\"DC Removal\u003cbr/\u003eblk = blk - mean(blk)\"]\n        WINDOW[\"Spectral Window\u003cbr/\u003eblk = blk .* w\"]\n    end\n    \n    subgraph \"Frequency Domain\"\n        CENTER[\"FFT Centering\u003cbr/\u003eblk .* dMult\u003cbr/\u003edMult = (-1)^(x+y)\"]\n        FFT2[\"fft2(blk, NFFT, NFFT)\"]\n        BP[\"Bandpass Filter\u003cbr/\u003edBPass = dRLow .* dRHigh\"]\n        ROOTFILT[\"Root Filtering\u003cbr/\u003eblkfft .* sqrt(abs(blkfft)^2)\"]\n    end\n    \n    subgraph \"Feature Extraction\"\n        ENERGY[\"Energy Map\u003cbr/\u003edEnergy = abs(blkfft)^2\"]\n        FREQ[\"Mean Frequency\u003cbr/\u003eweighted by r\"]\n        ANGLE[\"Mean Angle\u003cbr/\u003eweighted by sin(2*th), cos(2*th)\"]\n        TOTAL[\"Total Energy\u003cbr/\u003esum(dEnergy)\"]\n    end\n    \n    IMG --\u003e DC\n    DC --\u003e WINDOW\n    WINDOW --\u003e CENTER\n    CENTER --\u003e FFT2\n    FFT2 --\u003e BP\n    BP --\u003e ROOTFILT\n    ROOTFILT --\u003e ENERGY\n    ENERGY --\u003e FREQ\n    ENERGY --\u003e ANGLE\n    ENERGY --\u003e TOTAL\n    \n    FREQ --\u003e |\"fimg(i,j)\"| OUTPUT[\"Feature Maps\"]\n    ANGLE --\u003e |\"oimg(i,j)\"| OUTPUT\n    TOTAL --\u003e |\"eimg(i,j)\"| OUTPUT\n```\n\nSources: [FExtraction/fft_enhance_cubs.m:90-117]()\n\n### Preprocessing Steps\n\n**1. DC Removal** [FExtraction/fft_enhance_cubs.m:97-98]()\n```matlab\ndAvg = sum(sum(blk))/(nWndSz*nWndSz);\nblk = blk - dAvg;  % Remove DC content\n```\n\n**2. Spectral Windowing** [FExtraction/fft_enhance_cubs.m:68-99]()\n\nA 2D raised cosine window is applied to reduce spectral leakage. The window is constant over the core block region and transitions smoothly in the overlap regions:\n\n```matlab\nw = raised_cosine_window(BLKSZ, OVRLP)\nblk = blk .* w;\n```\n\n**3. FFT Centering** [FExtraction/fft_enhance_cubs.m:62-63, 103]()\n\nThe multiplication by `dMult = (-1)^(x+y)` centers the DC component before FFT computation.\n\nSources: [FExtraction/fft_enhance_cubs.m:62-68, 95-99, 179-198]()\n\n### Bandpass Filtering\n\nThe frequency domain content is filtered using cascaded Butterworth filters to isolate the ridge frequency band:\n\n**Low-pass filter:**\n```matlab\ndRLow = 1 ./ (1 + (r/FHIGH).^4)\n```\n\n**High-pass filter:**\n```matlab\ndRHigh = 1 ./ (1 + (FLOW./r).^4)\n```\n\n**Bandpass filter:**\n```matlab\ndBPass = dRLow .* dRHigh\n```\n\nWhere:\n- `FLOW = NFFT/RMAX` (lower frequency cutoff)\n- `FHIGH = NFFT/RMIN` (upper frequency cutoff)\n- `r = sqrt(x^2 + y^2)` (radial frequency)\n\nSources: [FExtraction/fft_enhance_cubs.m:78-85, 104]()\n\n### Root Filtering\n\nAfter bandpass filtering, root filtering is applied to enhance diffusion characteristics:\n\n```matlab\ndEnergy = abs(blkfft).^2;\nblkfft = blkfft .* sqrt(dEnergy);  % Root filtering for diffusion\n```\n\nThis operation effectively applies `blkfft = sign(blkfft) * |blkfft|^1.5`, enhancing the dominant frequency components.\n\nSources: [FExtraction/fft_enhance_cubs.m:105-106]()\n\n---\n\n## Feature Map Computation\n\nThree key feature maps are computed from the frequency domain energy distribution:\n\n### Ridge Orientation Computation\n\nThe `compute_mean_angle` function [FExtraction/fft_enhance_cubs.m:250-260]() computes the dominant ridge orientation using energy-weighted angular moments:\n\n```matlab\nsth = sin(2*th);\ncth = cos(2*th);\nnum = sum(sum(dEnergy .* sth));\nden = sum(sum(dEnergy .* cth));\nmth = 0.5 * atan2(num, den);\n```\n\nThe factor of 2 in the trigonometric functions accounts for the 180° symmetry of ridge structures. The output is in the range [0, π).\n\n**Storage:** `oimg(i+1, j+1) = compute_mean_angle(dEnergy, th)` [FExtraction/fft_enhance_cubs.m:114]()\n\n### Ridge Frequency Computation\n\nThe `compute_mean_frequency` function [FExtraction/fft_enhance_cubs.m:269-274]() computes the mean radial frequency:\n\n```matlab\nnum = sum(sum(dEnergy .* r));\nden = sum(sum(dEnergy));\nmr = num / (den + eps);\n```\n\nThe frequency image stores ridge spacing (inverse frequency):\n```matlab\nfimg(i+1, j+1) = NFFT / (compute_mean_frequency(dEnergy, r) + eps);\n```\n\n**Storage:** [FExtraction/fft_enhance_cubs.m:113]()\n\n### Energy Map Computation\n\nThe total block energy is computed as:\n```matlab\ndTotal = sum(sum(dEnergy)) / (NFFT*NFFT);\neimg(i+1, j+1) = log(dTotal + eps);\n```\n\nThis logarithmic energy measure is later used for fingerprint segmentation to distinguish ridge regions from background.\n\n**Storage:** [FExtraction/fft_enhance_cubs.m:112-115]()\n\nSources: [FExtraction/fft_enhance_cubs.m:108-116, 250-274]()\n\n---\n\n## Feature Map Smoothing and Coherence Analysis\n\nBetween the analysis and reconstruction stages, the extracted feature maps are processed to improve stability:\n\n### Orientation Smoothing\n\nThe orientation image undergoes three iterations of smoothing using `smoothen_orientation_image()`:\n```matlab\nfor i = 1:3\n    oimg = smoothen_orientation_image(oimg);\nend\n```\n\nSources: [FExtraction/fft_enhance_cubs.m:128-130]()\n\n### Frequency Smoothing\n\nThe frequency image is diffused while enforcing physical constraints:\n```matlab\nfimg = smoothen_frequency_image(fimg, RMIN, RMAX, 5);\n```\n\nThis ensures ridge spacing estimates remain within the valid range [RMIN, RMAX] pixels.\n\nSources: [FExtraction/fft_enhance_cubs.m:131]()\n\n### Coherence Computation\n\nThe `compute_coherence` function [FExtraction/compute_coherence.m:1-31]() measures the local consistency of ridge orientation:\n\n**Diagram: Coherence Computation**\n```mermaid\ngraph TB\n    OIMG[\"Orientation Image\u003cbr/\u003eoimg(i,j)\"]\n    PAD[\"Pad Image\u003cbr/\u003eflipud/fliplr\u003cbr/\u003eN=2 pixels\"]\n    \n    subgraph \"Local Coherence Calculation\"\n        CENTER[\"Central orientation\u003cbr/\u003eth = oimg(i,j)\"]\n        BLOCK[\"5x5 neighborhood\u003cbr/\u003eblk = oimg(i-2:i+2, j-2:j+2)\"]\n        COSDIFF[\"Angular difference\u003cbr/\u003eabs(cos(blk - th))\"]\n        AVERAGE[\"Average over block\u003cbr/\u003esum(sum(...)) / 25\"]\n    end\n    \n    CIMG[\"Coherence Image\u003cbr/\u003ecimg(i,j) in [0,1]\"]\n    \n    OIMG --\u003e PAD\n    PAD --\u003e CENTER\n    PAD --\u003e BLOCK\n    CENTER --\u003e COSDIFF\n    BLOCK --\u003e COSDIFF\n    COSDIFF --\u003e AVERAGE\n    AVERAGE --\u003e CIMG\n```\n\nThe coherence value ranges from 0 (low coherence) to 1 (high coherence). High coherence indicates parallel, well-defined ridges, while low coherence occurs near singular points (cores, deltas) where ridges curve sharply.\n\nSources: [FExtraction/compute_coherence.m:1-31](), [FExtraction/fft_enhance_cubs.m:132]()\n\n---\n\n## Adaptive Angular Bandwidth Selection\n\nThe angular bandwidth of the reconstruction filter adapts based on local ridge coherence, providing narrower filtering in regular regions and broader filtering near singular points.\n\n### Bandwidth Assignment Logic\n\nThe `get_angular_bw_image` function [FExtraction/fft_enhance_cubs.m:235-240]() assigns bandwidth values based on coherence thresholds:\n\n| Coherence Range | Bandwidth | Interpretation |\n|-----------------|-----------|----------------|\n| c ≤ 0.7 | π radians | High bandwidth (low selectivity) - singular points |\n| 0.7 \u003c c \u003c 0.9 | π/2 radians | Medium bandwidth - moderate regions |\n| c ≥ 0.9 | π/4 radians | Low bandwidth (high selectivity) - regular ridges |\n\n```matlab\nbwimg(:,:) = pi/2;           % Default: medium bandwidth\nbwimg(c \u003c= 0.7) = pi;        % High bandwidth for low coherence\nbwimg(c \u003e= 0.9) = pi/4;      % Low bandwidth for high coherence\n```\n\n**Rationale:** Near singular points (low coherence), a wider angular filter preserves ridge structure across varying orientations. In regular ridge regions (high coherence), a narrow filter provides better ridge enhancement and noise suppression.\n\nSources: [FExtraction/fft_enhance_cubs.m:133, 235-240]()\n\n---\n\n## Stage 2: FFT Reconstruction with Angular Filtering\n\nThe second stage reconstructs the enhanced fingerprint by applying adaptive angular filters to the stored FFT data.\n\n### Angular Filter Selection\n\nThe `get_angular_filter` function [FExtraction/fft_enhance_cubs.m:211-225]() retrieves the appropriate precomputed filter based on orientation and bandwidth:\n\n**Diagram: Filter Selection Logic**\n```mermaid\ngraph TD\n    INPUT1[\"Block orientation\u003cbr/\u003et0 = oimg(i,j)\"]\n    INPUT2[\"Block bandwidth\u003cbr/\u003ebw = bwimg(i,j)\"]\n    \n    QUANTIZE[\"Quantize orientation\u003cbr/\u003ei = floor((t0 + DELTAT/2) / DELTAT)\u003cbr/\u003ei = mod(i, TSTEPS) + 1\u003cbr/\u003eTSTEPS=12, DELTAT=π/12\"]\n    \n    BWCHECK{\"Bandwidth\u003cbr/\u003evalue?\"}\n    \n    FILTER_PI4[\"angf_pi_4(:,i)\u003cbr/\u003ereshape to 32x32\"]\n    FILTER_PI2[\"angf_pi_2(:,i)\u003cbr/\u003ereshape to 32x32\"]\n    FILTER_PI[\"ones(32,32)\u003cbr/\u003eno angular selectivity\"]\n    \n    OUTPUT[\"Angular filter\u003cbr/\u003eaf(32x32)\"]\n    \n    INPUT1 --\u003e QUANTIZE\n    QUANTIZE --\u003e BWCHECK\n    INPUT2 --\u003e BWCHECK\n    \n    BWCHECK --\u003e|\"π/4\"| FILTER_PI4\n    BWCHECK --\u003e|\"π/2\"| FILTER_PI2\n    BWCHECK --\u003e|\"π\"| FILTER_PI\n    \n    FILTER_PI4 --\u003e OUTPUT\n    FILTER_PI2 --\u003e OUTPUT\n    FILTER_PI --\u003e OUTPUT\n```\n\nThe precomputed filters are loaded from `angular_filters_pi_4.mat` and `angular_filters_pi_2.mat` [FExtraction/fft_enhance_cubs.m:73-76](). These files contain 12 filters spanning orientations from 0° to 180° in 15° increments.\n\nSources: [FExtraction/fft_enhance_cubs.m:72-76, 211-225]()\n\n### Reconstruction Loop\n\nFor each block, the reconstruction process:\n\n1. **Retrieves stored FFT:** `blkfft = reshape(transpose(fftSrc(nBlkWt*i+j+1,:)), NFFT, NFFT)` [FExtraction/fft_enhance_cubs.m:144]()\n\n2. **Applies angular filter:** `blkfft = blkfft .* af` [FExtraction/fft_enhance_cubs.m:149]()\n\n3. **Inverse FFT:** `blk = real(ifft2(blkfft) .* dMult)` [FExtraction/fft_enhance_cubs.m:150]()\n\n4. **Extracts core block:** Removes overlap regions and copies to output [FExtraction/fft_enhance_cubs.m:151]()\n\n**Processing Order:**\n```matlab\nfor i = 0:nBlkHt-1\n    for j = 0:nBlkWt-1\n        nRow = i*BLKSZ + OVRLP + 1;\n        nCol = j*BLKSZ + OVRLP + 1;\n        % Reconstruction steps...\n        enhimg(nRow:nRow+BLKSZ-1, nCol:nCol+BLKSZ-1) = \n            blk(OVRLP+1:OVRLP+BLKSZ, OVRLP+1:OVRLP+BLKSZ);\n    end\nend\n```\n\nSources: [FExtraction/fft_enhance_cubs.m:137-153]()\n\n---\n\n## Post-Processing and Output Generation\n\n### Contrast Enhancement\n\nThe reconstructed image undergoes root-based contrast stretching:\n\n```matlab\nenhimg = sqrt(abs(enhimg)) .* sign(enhimg);  % Root compression\nmx = max(max(enhimg));\nmn = min(min(enhimg));\nenhimg = uint8((enhimg - mn) / (mx - mn) * 254 + 1);\n```\n\nThis operation:\n- Applies square root to compress dynamic range while preserving sign\n- Normalizes to [1, 255] range\n- Converts to 8-bit unsigned integer format\n\nSources: [FExtraction/fft_enhance_cubs.m:158-161]()\n\n### Energy-Based Segmentation\n\nLow-energy blocks (background regions) are masked to neutral gray:\n\n```matlab\nemsk = imresize(eimg, [nHt, nWt]);\nenhimg(emsk \u003c ETHRESH) = 128;\n```\n\nWhere `ETHRESH` is 6 or 19 depending on configuration. This prevents enhancement artifacts in non-ridge regions.\n\nSources: [FExtraction/fft_enhance_cubs.m:166-167]()\n\n---\n\n## Comparison with Standard Enhancement\n\n**FFT Method vs. Ridge Filter Method:**\n\n| Aspect | FFT Enhancement (3.1.5) | Ridge Filter (3.1.4) |\n|--------|------------------------|----------------------|\n| **Domain** | Frequency (FFT-based) | Spatial (convolution) |\n| **Filter Adaptation** | Adaptive bandwidth via coherence | Fixed Gabor parameters |\n| **Feature Extraction** | Simultaneous (orientation, frequency, energy) | Sequential pipeline stages |\n| **Singular Point Handling** | Automatic bandwidth widening | Uniform filtering |\n| **Computation** | Two-pass (analysis + reconstruction) | Single-pass filtering |\n| **Filter Bank** | 12 precomputed angular filters | Dynamically generated Gabor filters |\n| **Block Overlap** | Configurable (OVRLP parameter) | Not applicable |\n| **Reference** | Sherlock et al., 1994 (FFT filtering) | Hong et al., 1998 (Gabor filtering) |\n\nThe FFT method provides better adaptation to local ridge characteristics through coherence-based bandwidth selection, making it particularly effective near singular points where ridge patterns are irregular.\n\nSources: [FExtraction/fft_enhance_cubs.m:1-21]()\n\n---\n\n## Parameter Configuration\n\n**Default Parameter Sets:**\n\nThe function supports two parameter configurations based on the `BLKSZ` input:\n\n| Parameter | BLKSZ \u003e 0 | BLKSZ ≤ 0 (auto) |\n|-----------|-----------|------------------|\n| `NFFT` | 32 | 32 |\n| `BLKSZ` | Input value | 12 |\n| `OVRLP` | 2 | 6 |\n| `ALPHA` | 0.5 | 0.5 |\n| `RMIN` | 4 | 3 |\n| `RMAX` | 40 | 18 |\n| `ESTRETCH` | 20 | 20 |\n| `ETHRESH` | 19 | 6 |\n\nThe larger parameter set (BLKSZ \u003e 0) is intended for higher-resolution fingerprint images, while the auto configuration provides defaults for standard 500 DPI fingerprints.\n\nSources: [FExtraction/fft_enhance_cubs.m:25-42]()\n\n---\n\n## Related Functions and Dependencies\n\n**Internal Helper Functions:**\n\n- `raised_cosine(nBlkSz, nOvrlp)` [FExtraction/fft_enhance_cubs.m:179-184]() - Generates 1D raised cosine window\n- `raised_cosine_window(blksz, ovrlp)` [FExtraction/fft_enhance_cubs.m:195-197]() - Generates 2D spectral window\n- `compute_mean_angle(dEnergy, th)` [FExtraction/fft_enhance_cubs.m:250-260]() - Energy-weighted orientation\n- `compute_mean_frequency(dEnergy, r)` [FExtraction/fft_enhance_cubs.m:269-274]() - Energy-weighted frequency\n- `get_angular_filter(t0, bw, angf_pi_4, angf_pi_2)` [FExtraction/fft_enhance_cubs.m:211-225]() - Filter selection\n- `get_angular_bw_image(c)` [FExtraction/fft_enhance_cubs.m:235-240]() - Bandwidth assignment\n\n**External Dependencies:**\n\n- `smoothen_orientation_image()` - Smooths orientation field (see [Supporting Utility Functions](#3.1.7))\n- `smoothen_frequency_image()` - Smooths frequency field (see [Supporting Utility Functions](#3.1.7))\n- `compute_coherence()` - Computes coherence from orientation [FExtraction/compute_coherence.m:1-31]()\n- Angular filter banks: `angular_filters_pi_4.mat`, `angular_filters_pi_2.mat` (see [Angular Filter Banks](#3.1.6))\n\n**MATLAB Built-in Functions:**\n\n- `fft2()` - 2D Fast Fourier Transform\n- `ifft2()` - 2D Inverse Fast Fourier Transform\n- `imresize()` - Image resizing for segmentation mask\n\nSources: [FExtraction/fft_enhance_cubs.m:1-275](), [FExtraction/compute_coherence.m:1-31]()"])</script><script>self.__next_f.push([1,"2d:T3099,"])</script><script>self.__next_f.push([1,"# Angular Filter Banks\n\n\u003cdetails\u003e\n\u003csummary\u003eRelevant source files\u003c/summary\u003e\n\nThe following files were used as context for generating this wiki page:\n\n- [FExtraction/angular_filter_bank.m](FExtraction/angular_filter_bank.m)\n- [FExtraction/angular_filters_pi_2.mat](FExtraction/angular_filters_pi_2.mat)\n- [FExtraction/angular_filters_pi_4.mat](FExtraction/angular_filters_pi_4.mat)\n\n\u003c/details\u003e\n\n\n\n## Purpose and Scope\n\nThis page documents the angular filter bank precomputation system used in the fingerprint feature extraction pipeline. Angular filter banks are sets of directional frequency-domain filters that span different orientations, enabling orientation-selective filtering during fingerprint enhancement. The system generates and stores these filters for subsequent use in enhancement algorithms.\n\nFor information about how these filters are used in practice, see [FFT-Based Enhancement](#3.1.5). For the complete feature extraction pipeline context, see [Feature Extraction Pipeline](#3.1).\n\n**Sources:** [FExtraction/angular_filter_bank.m:1-97]()\n\n## Overview\n\nThe angular filter bank system precomputes a set of directional raised cosine filters in the frequency domain. Each filter is designed to pass frequency components within a specific angular range while attenuating components in other directions. This enables selective enhancement of ridge structures oriented in specific directions during fingerprint processing.\n\nThe precomputed filters are stored in `.mat` files for efficient reuse and can also be exported to C header files for non-MATLAB implementations.\n\n**Sources:** [FExtraction/angular_filter_bank.m:1-20]()\n\n## Filter Generation Architecture\n\n```mermaid\ngraph TB\n    INPUT_PARAMS[\"Input Parameters\u003cbr/\u003eBW (bandwidth)\u003cbr/\u003efname (filename)\"]\n    \n    CONSTANTS[\"Configuration Constants\u003cbr/\u003eFFTN=32 (filter size)\u003cbr/\u003eTSTEPS=12 (15° intervals)\u003cbr/\u003eDELTAT=π/12\"]\n    \n    MESHGRID[\"meshgrid(-16:15, -16:15)\u003cbr/\u003eGenerate 32×32 coordinate grid\"]\n    \n    POLAR[\"Polar Coordinate Conversion\u003cbr/\u003er = sqrt(x²+y²)\u003cbr/\u003eθ = atan2(y,x)\"]\n    \n    UNSIGNED[\"Angle Normalization\u003cbr/\u003eθ[θ\u003c0] += 2π\u003cbr/\u003eRange: [0, 2π]\"]\n    \n    subgraph \"Filter Generation Loop\"\n        LOOP_START[\"for t0 = 0:π/12:(11*π/12)\"]\n        LOBE1[\"First Lobe at t0\u003cbr/\u003eangular_distance(θ, t0)\u003cbr/\u003e1+cos(d*π/BW)\"]\n        LOBE2[\"Second Lobe at t0+π\u003cbr/\u003eangular_distance(θ, t0+π)\u003cbr/\u003e1+cos(d*π/BW)\"]\n        COMBINE[\"Combine Lobes\u003cbr/\u003ermsk = lobe1 + lobe2\"]\n        APPEND[\"Append to filter matrix\u003cbr/\u003efilter[:,i] = transpose(rmsk)[:]\"]\n    end\n    \n    OUTPUT_MAT[\"Save MATLAB Format\u003cbr/\u003eangf = filter\u003cbr/\u003esave fname.mat angf\"]\n    \n    OUTPUT_C[\"Save C Header Format\u003cbr/\u003efname.h\u003cbr/\u003e2D array initialization\"]\n    \n    INPUT_PARAMS --\u003e CONSTANTS\n    CONSTANTS --\u003e MESHGRID\n    MESHGRID --\u003e POLAR\n    POLAR --\u003e UNSIGNED\n    UNSIGNED --\u003e LOOP_START\n    LOOP_START --\u003e LOBE1\n    LOBE1 --\u003e LOBE2\n    LOBE2 --\u003e COMBINE\n    COMBINE --\u003e APPEND\n    APPEND --\u003e LOOP_START\n    APPEND --\u003e OUTPUT_MAT\n    APPEND --\u003e OUTPUT_C\n    \n    style INPUT_PARAMS fill:#f9f9f9\n    style OUTPUT_MAT fill:#f9f9f9\n    style OUTPUT_C fill:#f9f9f9\n```\n\n**Diagram: Filter Bank Generation Pipeline**\n\nThe `angular_filter_bank` function orchestrates the entire generation process, from parameter input through coordinate grid generation to final storage in multiple formats.\n\n**Sources:** [FExtraction/angular_filter_bank.m:21-87]()\n\n## Core Function: angular_filter_bank\n\n### Function Signature\n\n```\nfunction angular_filter_bank(BW, fname)\n```\n\n**Parameters:**\n\n| Parameter | Type | Description |\n|-----------|------|-------------|\n| `BW` | double | Bandwidth in radians, controls the angular width of each filter |\n| `fname` | string | Base filename for output files (without extension) |\n\n**Sources:** [FExtraction/angular_filter_bank.m:21]()\n\n### Configuration Parameters\n\nThe function uses hardcoded configuration parameters that define the filter characteristics:\n\n| Parameter | Value | Description |\n|-----------|-------|-------------|\n| `FFTN` | 32 | Filter size (32×32 pixels in frequency domain) |\n| `TSTEPS` | 12 | Number of angular steps (creates 15° intervals) |\n| `DELTAT` | π/12 | Angular spacing between consecutive filters (15°) |\n\n**Sources:** [FExtraction/angular_filter_bank.m:26-28]()\n\n## Filter Construction Process\n\n```mermaid\ngraph LR\n    subgraph \"Coordinate System Setup\"\n        MESH[\"meshgrid\u003cbr/\u003e32×32 grid\"]\n        CART[\"Cartesian\u003cbr/\u003ex, y\"]\n        RADIUS[\"Radial\u003cbr/\u003er = √(x²+y²)\"]\n        ANGLE[\"Angular\u003cbr/\u003eθ = atan2(y,x)\"]\n    end\n    \n    subgraph \"Single Filter Generation\"\n        T0[\"Central Orientation t0\"]\n        DIST1[\"angular_distance(θ, t0)\"]\n        COSINE1[\"Raised Cosine\u003cbr/\u003e1+cos(d*π/BW)\"]\n        MASK1[\"Apply Threshold\u003cbr/\u003emsk[d\u003eBW] = 0\"]\n        \n        T1[\"Opposite Lobe t0+π\"]\n        DIST2[\"angular_distance(θ, t0+π)\"]\n        COSINE2[\"Raised Cosine\u003cbr/\u003e1+cos(d*π/BW)\"]\n        MASK2[\"Apply Threshold\u003cbr/\u003emsk[d\u003eBW] = 0\"]\n        \n        COMBINE[\"Sum Lobes\u003cbr/\u003ermsk = lobe1 + lobe2\"]\n    end\n    \n    MESH --\u003e CART\n    CART --\u003e RADIUS\n    CART --\u003e ANGLE\n    ANGLE --\u003e T0\n    ANGLE --\u003e T1\n    \n    T0 --\u003e DIST1\n    DIST1 --\u003e COSINE1\n    COSINE1 --\u003e MASK1\n    \n    T1 --\u003e DIST2\n    DIST2 --\u003e COSINE2\n    COSINE2 --\u003e MASK2\n    \n    MASK1 --\u003e COMBINE\n    MASK2 --\u003e COMBINE\n```\n\n**Diagram: Single Filter Construction**\n\nEach filter consists of two lobes positioned 180° apart to capture bidirectional ridge patterns (ridges don't have inherent directionality).\n\n**Sources:** [FExtraction/angular_filter_bank.m:32-62]()\n\n### Coordinate Grid Generation\n\nThe function begins by creating a Cartesian coordinate grid centered at the origin:\n\n[FExtraction/angular_filter_bank.m:32-35]()\n\nThis generates:\n- `x, y`: Cartesian coordinates ranging from -16 to 15\n- `r`: Radial distance from origin\n- `th`: Angular coordinate in radians\n\nThe angular coordinate is normalized to the range [0, 2π] to avoid negative angles.\n\n**Sources:** [FExtraction/angular_filter_bank.m:32-35]()\n\n### Raised Cosine Filter Shape\n\nFor each target orientation `t0`, the function creates a raised cosine window:\n\n1. **Compute angular distance**: [FExtraction/angular_filter_bank.m:46]()\n   - Uses the helper function `angular_distance(th, t0)` to compute the shortest angular distance\n   - Angular distance accounts for wrapping (e.g., 350° to 10° is 20°, not 340°)\n\n2. **Apply raised cosine**: [FExtraction/angular_filter_bank.m:47]()\n   ```\n   msk = 1 + cos(d * π / BW)\n   ```\n   - Creates a smooth cosine rolloff centered at the target orientation\n   - Value ranges from 2 (at center) to 0 (at edges)\n\n3. **Apply bandwidth threshold**: [FExtraction/angular_filter_bank.m:48]()\n   ```\n   msk(d \u003e BW) = 0\n   ```\n   - Hard cutoff at bandwidth `BW` to ensure compact support\n\n**Sources:** [FExtraction/angular_filter_bank.m:46-48]()\n\n### Dual-Lobe Structure\n\nEach filter contains two lobes positioned 180° apart:\n\n[FExtraction/angular_filter_bank.m:42-57]()\n\nThis dual-lobe design is essential because:\n- Fingerprint ridges are bidirectional structures (a ridge at 45° is equivalent to a ridge at 225°)\n- Frequency domain analysis requires capturing both positive and negative frequency components\n- The second lobe at `t1 = t0 + π` ensures symmetric filtering\n\n**Sources:** [FExtraction/angular_filter_bank.m:42-57]()\n\n## Angular Distance Computation\n\n```mermaid\ngraph LR\n    INPUT[\"Input: θ (angle map), t0 (target)\"]\n    \n    DIFF[\"Compute Difference\u003cbr/\u003ed = |θ - t0|\"]\n    \n    WRAP[\"Handle Wrapping\u003cbr/\u003ed = min(d, 2π - d)\"]\n    \n    OUTPUT[\"Output: d (acute angle)\"]\n    \n    INPUT --\u003e DIFF\n    DIFF --\u003e WRAP\n    WRAP --\u003e OUTPUT\n    \n    NOTE[\"Example:\u003cbr/\u003eθ=350°, t0=10°\u003cbr/\u003e|350-10| = 340°\u003cbr/\u003emin(340°, 20°) = 20°\"]\n    \n    WRAP -.-\u003e NOTE\n```\n\n**Diagram: Angular Distance Calculation**\n\nThe `angular_distance` helper function ensures that angular distances are always measured as acute angles (≤ π).\n\n**Sources:** [FExtraction/angular_filter_bank.m:89-96]()\n\n### Implementation\n\n[FExtraction/angular_filter_bank.m:93-95]()\n\nThe function computes the shortest angular distance by:\n1. Taking the absolute difference between angles\n2. Selecting the minimum between the direct distance and the wraparound distance (2π - d)\n\nThis ensures that the distance from 350° to 10° is correctly computed as 20° rather than 340°.\n\n**Sources:** [FExtraction/angular_filter_bank.m:93-95]()\n\n## Output Format\n\n### MATLAB .mat File\n\nThe primary output format stores the filter bank as a MATLAB variable:\n\n[FExtraction/angular_filter_bank.m:66-67]()\n\n**Storage Structure:**\n- Variable name: `angf`\n- Dimensions: `(FFTN², TSTEPS)` = `(1024, 12)`\n- Each column represents one filter, flattened from its 32×32 2D form\n- File name: `fname.mat`\n\n**Sources:** [FExtraction/angular_filter_bank.m:66-67]()\n\n### C Header File Export\n\nThe function also exports filters to a C-compatible header file:\n\n[FExtraction/angular_filter_bank.m:72-86]()\n\n**Format:**\n```c\n{\n  {filter_values_for_angle_0},\n  {filter_values_for_angle_15},\n  ...\n  {filter_values_for_angle_165}\n};\n```\n\nEach row is formatted with 32 values per line for readability, creating a 2D array initialization suitable for C/C++ code.\n\n**Sources:** [FExtraction/angular_filter_bank.m:72-86]()\n\n## Filter Bank Characteristics\n\n### Angular Coverage\n\nThe default configuration generates 12 filters spanning the full 180° semicircle:\n\n| Filter Index | Central Orientation | Angular Range |\n|--------------|---------------------|---------------|\n| 0 | 0° | -BW/2 to +BW/2 |\n| 1 | 15° | 15°±BW/2 |\n| 2 | 30° | 30°±BW/2 |\n| ... | ... | ... |\n| 11 | 165° | 165°±BW/2 |\n\nEach filter's second lobe automatically covers the corresponding opposite orientation (e.g., filter 0 also covers 180°).\n\n**Sources:** [FExtraction/angular_filter_bank.m:27-28, 41-42]()\n\n### Frequency Domain Properties\n\n```mermaid\ngraph TB\n    subgraph \"Filter Properties\"\n        SIZE[\"Size: 32×32 pixels\u003cbr/\u003eFrequency resolution: 1/32\"]\n        SPACING[\"Angular spacing: 15°\u003cbr/\u003e12 orientations\"]\n        SHAPE[\"Shape: Raised cosine\u003cbr/\u003eSmooth transitions\"]\n        SYMMETRY[\"Symmetry: Dual-lobe\u003cbr/\u003e180° apart\"]\n    end\n    \n    subgraph \"Design Rationale\"\n        ORIENTED[\"Orientation-selective\u003cbr/\u003efiltering capability\"]\n        SMOOTH[\"Smooth rolloff\u003cbr/\u003ereduces ringing artifacts\"]\n        BIDIR[\"Bidirectional\u003cbr/\u003ehandles ridge symmetry\"]\n        COMPLETE[\"Complete coverage\u003cbr/\u003eall orientations\"]\n    end\n    \n    SIZE --\u003e ORIENTED\n    SPACING --\u003e COMPLETE\n    SHAPE --\u003e SMOOTH\n    SYMMETRY --\u003e BIDIR\n```\n\n**Diagram: Filter Bank Design Properties**\n\nThe combination of these properties creates an effective directional filtering system for fingerprint enhancement.\n\n**Sources:** [FExtraction/angular_filter_bank.m:26-28]()\n\n## Integration with Enhancement Pipeline\n\nThe precomputed filter banks are loaded and used by enhancement algorithms:\n\n1. **Generation Phase** (one-time):\n   - `angular_filter_bank(BW, fname)` creates and saves filters\n   - Outputs stored in `.mat` files\n\n2. **Usage Phase** (during enhancement):\n   - Enhancement functions (e.g., `fft_enhance_cubs.m`) load the `.mat` file\n   - Filters are applied in the frequency domain to enhance ridges in specific orientations\n   - See [FFT-Based Enhancement](#3.1.5) for details\n\nThe separation between generation and usage enables:\n- Computational efficiency (filters computed only once)\n- Easy parameter tuning (regenerate with different bandwidth)\n- Portability (C header export for non-MATLAB implementations)\n\n**Sources:** [FExtraction/angular_filter_bank.m:1-20]()\n\n## Usage Example\n\nTo generate a filter bank with 30° bandwidth:\n\n```matlab\n% Generate filter bank with 30 degree (π/6 radian) bandwidth\nangular_filter_bank(pi/6, 'angular_filters_30deg')\n\n% This creates:\n%   angular_filters_30deg.mat  (MATLAB format)\n%   angular_filters_30deg.h    (C header format)\n\n% The .mat file contains variable 'angf' with dimensions (1024, 12)\n% representing 12 filters of size 32×32 pixels each\n```\n\n**Sources:** [FExtraction/angular_filter_bank.m:10-12]()\n\n## References\n\nThe angular filter bank implementation is based on the directional Fourier filtering approach described in:\n\nB.G. Sherlock, D.M. Monro, and K. Millard, \"Fingerprint Enhancement by directional Fourier Filtering\", IEEE Visual Image Signal Processing, 141(2), pp. 87-94, 1994\n\n**Sources:** [FExtraction/angular_filter_bank.m:16-19]()"])</script><script>self.__next_f.push([1,"2e:T3587,"])</script><script>self.__next_f.push([1,"# Supporting Utility Functions\n\n\u003cdetails\u003e\n\u003csummary\u003eRelevant source files\u003c/summary\u003e\n\nThe following files were used as context for generating this wiki page:\n\n- [FExtraction/compute_coherence.m](FExtraction/compute_coherence.m)\n- [FExtraction/dist2.m](FExtraction/dist2.m)\n- [FExtraction/normalise.m](FExtraction/normalise.m)\n- [FExtraction/p.m](FExtraction/p.m)\n\n\u003c/details\u003e\n\n\n\n## Purpose and Scope\n\nThis document describes the utility functions that provide essential supporting operations for the feature extraction pipeline. These functions perform common computational tasks such as image normalization, coherence calculation, distance computation, and pixel access operations that are used by the main feature extraction algorithms documented in sections [3.1.1](#3.1.1) through [3.1.6](#3.1.6).\n\n---\n\n## Overview\n\nThe feature extraction pipeline relies on several utility functions that implement fundamental image processing and mathematical operations. These utilities are designed to be reusable across multiple stages of the fingerprint processing workflow and provide standardized implementations of common operations.\n\n```mermaid\ngraph TD\n    subgraph \"Main Feature Extraction Stages\"\n        RS[\"ridgesegment.m\u003cbr/\u003eSegmentation\"]\n        RO[\"ridgeorient.m\u003cbr/\u003eOrientation\"]\n        RF[\"ridgefreq.m\u003cbr/\u003eFrequency\"]\n        RFILT[\"ridgefilter.m\u003cbr/\u003eFiltering\"]\n        FFT[\"fft_enhance_cubs.m\u003cbr/\u003eFFT Enhancement\"]\n    end\n    \n    subgraph \"Supporting Utilities\"\n        NORM[\"normalise.m\u003cbr/\u003eImage Normalization\"]\n        COH[\"compute_coherence.m\u003cbr/\u003eCoherence Calculation\"]\n        DIST[\"dist2.m\u003cbr/\u003eDistance Metrics\"]\n        PIX[\"p.m\u003cbr/\u003ePixel Access\"]\n    end\n    \n    RS --\u003e NORM\n    RO --\u003e COH\n    RO --\u003e DIST\n    RF --\u003e PIX\n    FFT --\u003e COH\n    FFT --\u003e NORM\n    \n    NORM -.-\u003e|\"Provides normalized images\"| RS\n    COH -.-\u003e|\"Provides coherence maps\"| RO\n    DIST -.-\u003e|\"Provides distance calculations\"| RO\n    PIX -.-\u003e|\"Provides pixel access\"| RF\n```\n\n**Diagram: Utility Functions in Feature Extraction Context**\n\nSources: [FExtraction/normalise.m:1-71](), [FExtraction/compute_coherence.m:1-31](), [FExtraction/dist2.m:1-27](), [FExtraction/p.m:1-43]()\n\n---\n\n## Image Normalization\n\n### Function: `normalise`\n\nThe `normalise` function provides two modes of image normalization: scaling to the 0-1 range or adjusting to a specified mean and variance. This function is critical for preprocessing fingerprint images to ensure consistent intensity distributions.\n\n**Function Signature:**\n```matlab\nn = normalise(im)\nn = normalise(im, reqmean, reqvar)\n```\n\n**Parameters:**\n\n| Parameter | Type | Description |\n|-----------|------|-------------|\n| `im` | Matrix | Input grayscale or color image |\n| `reqmean` | Scalar (optional) | Desired mean value of the output image |\n| `reqvar` | Scalar (optional) | Desired variance of the output image |\n\n**Return Value:**\n\n| Variable | Type | Description |\n|----------|------|-------------|\n| `n` | Matrix | Normalized image |\n\n### Normalization Modes\n\n#### Mode 1: 0-1 Range Normalization\n\nWhen called with a single argument, the function performs min-max normalization:\n\n```mermaid\ngraph LR\n    INPUT[\"Input Image\u003cbr/\u003eim\"] --\u003e CHECK{\"Color or\u003cbr/\u003eGrayscale?\"}\n    CHECK --\u003e|\"Grayscale\"| GRAY[\"Calculate:\u003cbr/\u003en = (im - min) / (max - min)\"]\n    CHECK --\u003e|\"Color RGB\"| RGB[\"Convert to HSV\"]\n    RGB --\u003e VNORM[\"Normalize V channel:\u003cbr/\u003ev = (v - min) / (max - min)\"]\n    VNORM --\u003e BACK[\"Convert back to RGB\"]\n    GRAY --\u003e OUTPUT[\"Normalized Image\u003cbr/\u003en ∈ [0,1]\"]\n    BACK --\u003e OUTPUT\n```\n\n**Diagram: Normalization Mode 1 Algorithm Flow**\n\nFor grayscale images, the algorithm offsets the image by its minimum value and scales by the range [FExtraction/normalise.m:54-55]():\n\n$$n = \\frac{im - \\min(im)}{\\max(im) - \\min(im)}$$\n\nFor color images, only the value channel in HSV space is normalized while preserving hue and saturation [FExtraction/normalise.m:45-51]().\n\n#### Mode 2: Mean and Variance Normalization\n\nWhen called with three arguments, the function adjusts the image to have a specific mean and variance:\n\n$$n = \\mu_{req} + \\frac{im - \\mu_{im}}{\\sigma_{im}} \\cdot \\sqrt{\\sigma^2_{req}}$$\n\nThis is implemented in [FExtraction/normalise.m:65-68]() by first standardizing the image to zero mean and unit variance, then scaling and offsetting to the requested statistics. This mode only works with grayscale images [FExtraction/normalise.m:60-62]().\n\nSources: [FExtraction/normalise.m:1-71]()\n\n---\n\n## Coherence Computation\n\n### Function: `compute_coherence`\n\nThe `compute_coherence` function computes a coherence map from an orientation image. Coherence measures the consistency of ridge orientation within local neighborhoods, with values ranging from 0 (low coherence) to 1 (high coherence). This metric is useful for identifying regions with well-defined ridge flow versus noisy or low-quality areas.\n\n**Function Signature:**\n```matlab\ncimg = compute_coherence(oimg)\n```\n\n**Parameters:**\n\n| Parameter | Type | Description |\n|-----------|------|-------------|\n| `oimg` | Matrix | Orientation image (angles in radians) |\n\n**Return Value:**\n\n| Variable | Type | Description |\n|----------|------|-------------|\n| `cimg` | Matrix | Coherence image with values in [0,1] |\n\n### Algorithm Details\n\n```mermaid\ngraph TD\n    START[\"Input: Orientation Image\u003cbr/\u003eoimg\"] --\u003e PAD[\"Pad Image\u003cbr/\u003eN=2 pixels on all sides\u003cbr/\u003eUsing flipud/fliplr\"]\n    PAD --\u003e LOOP[\"For each pixel (i,j)\"]\n    LOOP --\u003e BLOCK[\"Extract local block\u003cbr/\u003eblk = oimg(i-N:i+N, j-N:j+N)\"]\n    BLOCK --\u003e CENTER[\"Get center orientation\u003cbr/\u003eth = oimg(i,j)\"]\n    CENTER --\u003e CALC[\"Calculate coherence:\u003cbr/\u003esum(abs(cos(blk-th))) / (2N+1)²\"]\n    CALC --\u003e STORE[\"Store in cimg(i,j)\"]\n    STORE --\u003e LOOP\n    LOOP --\u003e OUTPUT[\"Output: Coherence Image\u003cbr/\u003ecimg\"]\n```\n\n**Diagram: Coherence Computation Algorithm**\n\nThe coherence calculation uses a 5×5 neighborhood (N=2) [FExtraction/compute_coherence.m:17]() and measures orientation consistency using the cosine of angular differences [FExtraction/compute_coherence.m:28](). The algorithm:\n\n1. **Pads the image** by reflecting border pixels to handle edge cases [FExtraction/compute_coherence.m:21-22]()\n2. **For each pixel**, extracts a local block centered at that pixel [FExtraction/compute_coherence.m:27]()\n3. **Computes the coherence** as the average absolute cosine of the difference between each neighbor's orientation and the center orientation [FExtraction/compute_coherence.m:28]()\n\nThe use of `abs(cos(blk-th))` ensures that orientations differing by 180° are considered equivalent (since fingerprint ridges have no inherent direction). A coherence value near 1 indicates that all orientations in the neighborhood align with the center orientation, while values near 0 indicate random or conflicting orientations.\n\n**Reference:** The implementation is based on texture coherence metrics described in \"A taxonomy of texture description\" by A. Ravishankar Rao [FExtraction/compute_coherence.m:12]().\n\nSources: [FExtraction/compute_coherence.m:1-31]()\n\n---\n\n## Distance Metrics\n\n### Function: `dist2`\n\nThe `dist2` function calculates the squared Euclidean distance between two sets of points. This is a computationally efficient implementation commonly used in clustering algorithms, orientation smoothing, and other spatial analysis tasks within the feature extraction pipeline.\n\n**Function Signature:**\n```matlab\nn2 = dist2(x, c)\n```\n\n**Parameters:**\n\n| Parameter | Type | Description |\n|-----------|------|-------------|\n| `x` | M×N matrix | First set of M points in N-dimensional space |\n| `c` | L×N matrix | Second set of L points in N-dimensional space |\n\n**Return Value:**\n\n| Variable | Type | Description |\n|----------|------|-------------|\n| `n2` | M×L matrix | Squared Euclidean distances where n2(i,j) is the distance from x(i,:) to c(j,:) |\n\n### Algorithm Details\n\nThe function implements an optimized distance calculation using the algebraic expansion:\n\n$$\\|x_i - c_j\\|^2 = \\|x_i\\|^2 + \\|c_j\\|^2 - 2 x_i \\cdot c_j^T$$\n\n```mermaid\ngraph LR\n    X[\"Matrix x\u003cbr/\u003e(M × N)\"] --\u003e XSUM[\"Row sums:\u003cbr/\u003esum(x.², dim=1)\"]\n    C[\"Matrix c\u003cbr/\u003e(L × N)\"] --\u003e CSUM[\"Row sums:\u003cbr/\u003esum(c.², dim=1)\"]\n    \n    XSUM --\u003e EXPAND1[\"Expand:\u003cbr/\u003eones(L,1) * xsum\"]\n    CSUM --\u003e EXPAND2[\"Expand:\u003cbr/\u003eones(M,1) * csum'\"]\n    \n    X --\u003e DOT[\"Dot products:\u003cbr/\u003e-2 * (x * c')\"]\n    C --\u003e DOT\n    \n    EXPAND1 --\u003e ADD[\"Add all terms:\u003cbr/\u003exsum' + csum - 2*xc'\"]\n    EXPAND2 --\u003e ADD\n    DOT --\u003e ADD\n    \n    ADD --\u003e RESULT[\"Distance Matrix\u003cbr/\u003en2 (M × L)\"]\n```\n\n**Diagram: Efficient Distance Matrix Computation**\n\nThis vectorized implementation [FExtraction/dist2.m:24-26]() avoids explicit loops and computes all M×L pairwise distances simultaneously, making it much faster than naive implementations for large datasets. The function validates that both input matrices have the same column dimension [FExtraction/dist2.m:20-22]().\n\n**Copyright:** This implementation is from the Netlab neural network toolbox by Christopher M Bishop and Ian T Nabney (1996, 1997) [FExtraction/dist2.m:16]().\n\nSources: [FExtraction/dist2.m:1-27]()\n\n---\n\n## Pixel Access Utilities\n\n### Function: `p`\n\nThe `p` function provides structured access to the 8-connected neighborhood of a pixel. This utility is particularly useful in ridge frequency estimation and other algorithms that need to traverse pixels in specific directions around a center point.\n\n**Function Signature:**\n```matlab\n[j, X, Y] = p(img, x, y, i)\n```\n\n**Parameters:**\n\n| Parameter | Type | Description |\n|-----------|------|-------------|\n| `img` | Matrix | Input image |\n| `x` | Scalar | Column coordinate of center pixel |\n| `y` | Scalar | Row coordinate of center pixel |\n| `i` | Integer (1-8) | Direction code specifying which neighbor to access |\n\n**Return Values:**\n\n| Variable | Type | Description |\n|----------|------|-------------|\n| `j` | Scalar | Pixel intensity value at the specified neighbor |\n| `X` | Scalar | Column coordinate of the accessed neighbor |\n| `Y` | Scalar | Row coordinate of the accessed neighbor |\n\n### 8-Connectivity Neighborhood Encoding\n\nThe function uses a standardized 8-connectivity numbering scheme [FExtraction/p.m:3-6]():\n\n```mermaid\ngraph TD\n    subgraph \"Pixel Neighborhood Encoding\"\n        P4[\"4\u003cbr/\u003e(-1,-1)\"] --- P3[\"3\u003cbr/\u003e(0,-1)\"] --- P2[\"2\u003cbr/\u003e(+1,-1)\"]\n        P5[\"5\u003cbr/\u003e(-1,0)\"] --- CENTER[\"Center\u003cbr/\u003e(x,y)\"] --- P1[\"1\u003cbr/\u003e(+1,0)\"]\n        P6[\"6\u003cbr/\u003e(-1,+1)\"] --- P7[\"7\u003cbr/\u003e(0,+1)\"] --- P8[\"8\u003cbr/\u003e(+1,+1)\"]\n    end\n    \n    P1 -.-\u003e|\"i=1 or i=9\"| CODE1[\"X = x+1, Y = y\"]\n    P2 -.-\u003e|\"i=2\"| CODE2[\"X = x+1, Y = y-1\"]\n    P3 -.-\u003e|\"i=3\"| CODE3[\"X = x, Y = y-1\"]\n    P4 -.-\u003e|\"i=4\"| CODE4[\"X = x-1, Y = y-1\"]\n    P5 -.-\u003e|\"i=5\"| CODE5[\"X = x-1, Y = y\"]\n    P6 -.-\u003e|\"i=6\"| CODE6[\"X = x-1, Y = y+1\"]\n    P7 -.-\u003e|\"i=7\"| CODE7[\"X = x, Y = y+1\"]\n    P8 -.-\u003e|\"i=8\"| CODE8[\"X = x+1, Y = y+1\"]\n```\n\n**Diagram: 8-Connectivity Direction Codes**\n\nThe direction codes allow algorithms to systematically traverse pixels in clockwise order starting from the right neighbor (i=1). The implementation uses a `switch` statement [FExtraction/p.m:8-41]() to map each direction code to the appropriate coordinate offsets and retrieve the pixel value.\n\n**Note:** Direction code 9 is treated identically to direction code 1 [FExtraction/p.m:9](), allowing for modular arithmetic when wrapping around the neighborhood.\n\nSources: [FExtraction/p.m:1-43]()\n\n---\n\n## Usage Examples\n\n### Normalization in Ridge Segmentation\n\nThe `normalise` function is typically called at the beginning of the feature extraction pipeline to standardize image intensities. In the segmentation stage, images are normalized to a desired mean and variance to ensure consistent processing:\n\n```matlab\n% Example usage pattern from ridgesegment.m context\nnormim = normalise(im, 100, 100);  % Mean=100, Variance=100\n```\n\n### Coherence in Quality Assessment\n\nThe `compute_coherence` function is used to assess local fingerprint quality. High coherence regions indicate well-defined ridge patterns suitable for feature extraction:\n\n```matlab\n% After computing orientation image\ncimg = compute_coherence(orientim);\n% High quality regions: cimg \u003e threshold (e.g., 0.7)\n```\n\n### Distance Computation in Orientation Smoothing\n\nThe `dist2` function is used to compute spatial distances for weighted smoothing operations:\n\n```matlab\n% Compute distances from block centers to all other blocks\ndistances = dist2(block_centers, all_centers);\nweights = exp(-distances / sigma^2);\n```\n\n### Pixel Access in Ridge Following\n\nThe `p` function enables systematic ridge traversal in frequency estimation algorithms:\n\n```matlab\n% Follow ridge in direction perpendicular to orientation\nfor i = 1:8\n    [pixel_val, x_new, y_new] = p(img, x_cur, y_cur, i);\n    % Process neighboring pixel\nend\n```\n\nSources: [FExtraction/normalise.m:1-71](), [FExtraction/compute_coherence.m:1-31](), [FExtraction/dist2.m:1-27](), [FExtraction/p.m:1-43]()\n\n---\n\n## Summary Table\n\n| Function | Primary Purpose | Input(s) | Output(s) | Used By |\n|----------|----------------|----------|-----------|---------|\n| `normalise` | Image intensity standardization | Image, optional (mean, variance) | Normalized image | ridgesegment, fft_enhance_cubs |\n| `compute_coherence` | Ridge orientation consistency | Orientation image | Coherence map [0,1] | ridgeorient, fft_enhance_cubs |\n| `dist2` | Efficient distance calculation | Two point sets (M×N, L×N) | Distance matrix (M×L) | ridgeorient smoothing |\n| `p` | 8-connected pixel access | Image, coordinates, direction | Pixel value, new coordinates | ridgefreq |\n\nSources: [FExtraction/normalise.m:1-71](), [FExtraction/compute_coherence.m:1-31](), [FExtraction/dist2.m:1-27](), [FExtraction/p.m:1-43]()"])</script><script>self.__next_f.push([1,"2f:T372f,"])</script><script>self.__next_f.push([1,"# Fingerprint Matching\n\n\u003cdetails\u003e\n\u003csummary\u003eRelevant source files\u003c/summary\u003e\n\nThe following files were used as context for generating this wiki page:\n\n- [Copy_of_match.m](Copy_of_match.m)\n- [Copy_of_score.m](Copy_of_score.m)\n\n\u003c/details\u003e\n\n\n\n## Purpose and Scope\n\nThe Fingerprint Matching subsystem compares sets of minutiae (distinctive ridge features) to determine the similarity between fingerprints. This subsystem implements a brute-force alignment search strategy that tests multiple spatial translations and rotations to find the optimal transformation parameters between a reference fingerprint and candidate fingerprints. \n\nThis document provides an overview of the matching architecture, data structures, and workflow. For detailed information about the alignment search algorithm, see [Match Algorithm](#3.2.1). For details about the similarity scoring function, see [Similarity Scoring](#3.2.2). For information about how minutiae are extracted from fingerprint images, see [Feature Extraction Pipeline](#3.1).\n\n**Sources:** [Copy_of_match.m:1-411](), [Copy_of_score.m:1-47]()\n\n## System Architecture\n\nThe matching subsystem consists of two primary functions that work in tandem to perform fingerprint comparison:\n\n```mermaid\ngraph TB\n    subgraph \"Data Sources\"\n        DB[(\"db.mat\u003cbr/\u003eff cell array\u003cbr/\u003eminutiae database\")]\n        PARAMS[\"Input Parameters\u003cbr/\u003eIndex, Number, display_flag\"]\n    end\n    \n    subgraph \"Copy_of_match.m\"\n        LOAD[\"Load Minutiae\u003cbr/\u003eM1 = ff{Index*8-7}\u003cbr/\u003eM2-M6 = ff{random}\"]\n        FILTER[\"Filter Minutiae\u003cbr/\u003ecolumn 3 \u003c 5\"]\n        SEARCH[\"Brute-Force Search\u003cbr/\u003enested loops:\u003cbr/\u003ei: minutiae in M1\u003cbr/\u003ej: minutiae in M2-M6\u003cbr/\u003ea: rotation angles\"]\n        TRANS1[\"transform(M, i)\u003cbr/\u003etranslation to origin\"]\n        TRANS2[\"transform2(T, alpha)\u003cbr/\u003erotation by angle\"]\n        SCORE_CALL[\"score(T1, T2)\u003cbr/\u003esimilarity calculation\"]\n        BEST[\"Track Best Match\u003cbr/\u003eS2-S6, bi, bj, ba\"]\n        DISPLAY[\"Display Processing\u003cbr/\u003econsistent matches\u003cbr/\u003edistance metrics\"]\n    end\n    \n    subgraph \"Copy_of_score.m\"\n        SPATIAL[\"Spatial Matching\u003cbr/\u003ed \u003c 15 pixels\"]\n        ANGULAR[\"Angular Matching\u003cbr/\u003eDTheta \u003c 14°\"]\n        COUNT[\"Count Matches\u003cbr/\u003en matched pairs\"]\n        SM[\"Similarity Measure\u003cbr/\u003esqrt(n²/(Count1*Count2))\"]\n    end\n    \n    subgraph \"Output\"\n        RESULT[\"result array\u003cbr/\u003edistance metrics\"]\n        RESULT_R[\"result_r\u003cbr/\u003ecandidate indices\"]\n    end\n    \n    DB --\u003e LOAD\n    PARAMS --\u003e LOAD\n    LOAD --\u003e FILTER\n    FILTER --\u003e SEARCH\n    \n    SEARCH --\u003e TRANS1\n    TRANS1 --\u003e TRANS2\n    TRANS2 --\u003e SCORE_CALL\n    \n    SCORE_CALL --\u003e SPATIAL\n    SPATIAL --\u003e ANGULAR\n    ANGULAR --\u003e COUNT\n    COUNT --\u003e SM\n    \n    SM --\u003e BEST\n    BEST --\u003e DISPLAY\n    DISPLAY --\u003e RESULT\n    LOAD --\u003e RESULT_R\n    \n    style DB fill:#f8f9fa\n    style RESULT fill:#f8f9fa\n    style RESULT_R fill:#f8f9fa\n```\n\n**Diagram: Fingerprint Matching System Component Architecture**\n\n**Sources:** [Copy_of_match.m:17-411](), [Copy_of_score.m:16-47]()\n\n## Data Structures\n\n### Minutiae Database Format\n\nThe system loads minutiae data from `db.mat`, which contains a cell array named `ff`. Each cell in the array stores minutiae for one fingerprint as an N×6 matrix:\n\n| Column | Description | Data Type |\n|--------|-------------|-----------|\n| 1 | X coordinate | Numeric |\n| 2 | Y coordinate | Numeric |\n| 3 | Minutiae type | Integer (filtered to \u003c 5) |\n| 4 | Orientation angle | Radians |\n| 5 | Minutiae ID | Integer |\n| 6 | Additional attribute | Numeric |\n\nThe database is indexed such that fingerprints are grouped in sets of 8, and the system accesses them using the formula `Index * 8 - 7` to get the starting fingerprint of a set [Copy_of_match.m:19]().\n\n**Sources:** [Copy_of_match.m:18-36]()\n\n### Transformation Coordinate System\n\nThe matching system uses two transformation functions to align minutiae:\n\n```mermaid\ngraph LR\n    subgraph \"Original Space\"\n        M[\"M(x, y, theta, ...)\"]\n    end\n    \n    subgraph \"Translation - transform(M, i)\"\n        T[\"T(x', y', theta', ...)\u003cbr/\u003ex' = x - M(i,1)\u003cbr/\u003ey' = y - M(i,2)\u003cbr/\u003etheta' = theta - M(i,4)\"]\n    end\n    \n    subgraph \"Rotation - transform2(T, alpha)\"\n        T2[\"T2(x'', y'', theta'', ...)\u003cbr/\u003ex'' = x'*cos(alpha) - y'*sin(alpha)\u003cbr/\u003ey'' = x'*sin(alpha) + y'*cos(alpha)\u003cbr/\u003etheta'' = theta' + alpha\"]\n    end\n    \n    M --\u003e|\"translate to\u003cbr/\u003eminutia i at origin\"| T\n    T --\u003e|\"rotate by\u003cbr/\u003eangle alpha\"| T2\n```\n\n**Diagram: Minutiae Transformation Pipeline**\n\nBoth transformations preserve the minutiae structure while creating aligned coordinate systems for comparison. The transformation functions are called within the nested search loops [Copy_of_match.m:64-69]().\n\n**Sources:** [Copy_of_match.m:64-69](), [Copy_of_match.m:214-222]()\n\n## Matching Workflow\n\n### Multi-Candidate Comparison Process\n\nThe `Copy_of_match` function performs a one-to-many comparison, where one reference fingerprint (M1) is compared against five randomly selected candidates (M2-M6):\n\n```mermaid\nflowchart TD\n    START[\"Copy_of_match(Index, Number, display_flag)\"]\n    LOAD_DB[\"load('db.mat')\u003cbr/\u003eaccess ff cell array\"]\n    CALC_INDEX[\"Index = Index * 8 - 7\"]\n    \n    LOOP_NUMBER{\"for index = 1:Number\"}\n    RANDOM[\"r = randperm(7,5) + Index\u003cbr/\u003eselect 5 random candidates\"]\n    \n    LOAD_M1[\"M1 = ff{Index}\u003cbr/\u003ereference fingerprint\"]\n    LOAD_M2_M6[\"M2 = ff{r(1)}\u003cbr/\u003eM3 = ff{r(2)}\u003cbr/\u003e...\u003cbr/\u003eM6 = ff{r(5)}\"]\n    \n    FILTER[\"Filter all minutiae:\u003cbr/\u003eMi = Mi(Mi(:,3) \u003c 5, :)\"]\n    \n    INIT_BEST[\"Initialize best scores:\u003cbr/\u003eS2-S6 = 0\u003cbr/\u003ebi2-bi6 = 0\u003cbr/\u003ebj2-bj6 = 0\u003cbr/\u003eba2-ba6 = 0\"]\n    \n    NESTED_SEARCH[\"Triple Nested Loop:\u003cbr/\u003ei: each minutia in M1\u003cbr/\u003ej: each minutia in M2-M6\u003cbr/\u003ea: rotation angles\"]\n    \n    UPDATE_BEST[\"Track best transformation:\u003cbr/\u003eif sm \u003e S(k):\u003cbr/\u003e  S(k) = sm\u003cbr/\u003e  bi(k) = i\u003cbr/\u003e  bj(k) = j\u003cbr/\u003e  ba(k) = a\"]\n    \n    DISPLAY_CHECK{\"display_flag == 1?\"}\n    \n    CONSISTENT[\"Find consistent matches\u003cbr/\u003eacross all 5 candidates\u003cbr/\u003ebuild Dist_index matrix\"]\n    \n    CALC_DIST[\"Calculate distance metrics:\u003cbr/\u003eEuclidean distances\u003cbr/\u003ein transformed space\"]\n    \n    AVERAGE[\"Average distances\u003cbr/\u003eexcluding min/max\"]\n    \n    RESULT[\"Return result array\u003cbr/\u003eand result_r indices\"]\n    \n    END_LOOP[\"end for index\"]\n    \n    START --\u003e LOAD_DB\n    LOAD_DB --\u003e CALC_INDEX\n    CALC_INDEX --\u003e LOOP_NUMBER\n    \n    LOOP_NUMBER --\u003e|\"iterate\"| RANDOM\n    RANDOM --\u003e LOAD_M1\n    LOAD_M1 --\u003e LOAD_M2_M6\n    LOAD_M2_M6 --\u003e FILTER\n    FILTER --\u003e INIT_BEST\n    INIT_BEST --\u003e NESTED_SEARCH\n    NESTED_SEARCH --\u003e UPDATE_BEST\n    UPDATE_BEST --\u003e END_LOOP\n    \n    END_LOOP --\u003e DISPLAY_CHECK\n    DISPLAY_CHECK --\u003e|\"yes\"| CONSISTENT\n    CONSISTENT --\u003e CALC_DIST\n    CALC_DIST --\u003e AVERAGE\n    AVERAGE --\u003e RESULT\n    \n    DISPLAY_CHECK --\u003e|\"no\"| RESULT\n    \n    LOOP_NUMBER --\u003e|\"complete\"| DISPLAY_CHECK\n```\n\n**Diagram: Main Matching Workflow in Copy_of_match.m**\n\n**Sources:** [Copy_of_match.m:17-24](), [Copy_of_match.m:25-40](), [Copy_of_match.m:63-137](), [Copy_of_match.m:201-410]()\n\n### Rotation Angle Search Strategy\n\nThe system uses different rotation angle ranges for different candidates to balance computational cost with matching accuracy:\n\n| Candidate | Variable | Rotation Range | Step Size | Total Angles |\n|-----------|----------|----------------|-----------|--------------|\n| M2 | `a` | -10° to +10° | 1° | 21 |\n| M3 | `a` | -5° to +5° | 1° | 11 |\n| M4 | `a` | -10° to +10° | 1° | 21 |\n| M5 | `a` | -5° to +5° | 1° | 11 |\n| M6 | `a` | -5° to +5° | 1° | 11 |\n\nThis asymmetric search pattern [Copy_of_match.m:68](), [Copy_of_match.m:83](), [Copy_of_match.m:98](), [Copy_of_match.m:113](), [Copy_of_match.m:127]() may reflect experimental tuning for specific use cases.\n\n**Sources:** [Copy_of_match.m:68-135]()\n\n## Core Function Interfaces\n\n### Copy_of_match Function Signature\n\n```matlab\nfunction [ result, result_r ] = Copy_of_match( Index, Number, display_flag )\n```\n\n**Parameters:**\n- `Index` (integer): The fingerprint ID to use as reference (adjusted internally by `Index * 8 - 7`)\n- `Number` (integer): Number of comparison iterations to perform\n- `display_flag` (integer, optional): When set to 1, enables detailed distance metric calculation and output. Default is 0.\n\n**Returns:**\n- `result` (array): Distance metrics for consistently matched minutiae (only when `display_flag == 1`)\n- `result_r` (array): Indices of the randomly selected candidate fingerprints\n\n**Sources:** [Copy_of_match.m:17](), [Copy_of_match.m:24]()\n\n### Copy_of_score Function Signature\n\n```matlab\nfunction [ sm, T2_ ] = score( T1, T2 )\n```\n\n**Parameters:**\n- `T1` (N×6 matrix): First transformed minutiae set\n- `T2` (M×6 matrix): Second transformed minutiae set\n\n**Returns:**\n- `sm` (scalar): Similarity measure in range [0, 1], computed as `sqrt(n²/(Count1*Count2))`\n- `T2_` (Count1×1 array): Mapping of matched minutiae IDs from T1 to T2, with 0 indicating no match\n\n**Sources:** [Copy_of_score.m:16](), [Copy_of_score.m:46]()\n\n## Matching Thresholds\n\nThe similarity scoring function uses two threshold parameters to determine whether minutiae match:\n\n| Threshold | Variable | Value | Unit | Purpose |\n|-----------|----------|-------|------|---------|\n| Spatial Distance | `T` | 15 | pixels | Maximum Euclidean distance for spatial match |\n| Angular Difference | `TT` | 14 | degrees | Maximum orientation difference for angular match |\n\nThese thresholds are hardcoded in the `score` function [Copy_of_score.m:20-21](). Two minutiae are considered matched only when both thresholds are satisfied [Copy_of_score.m:28-33]().\n\n**Sources:** [Copy_of_score.m:20-21](), [Copy_of_score.m:28-33]()\n\n## Transformation Parameter Tracking\n\nFor each candidate fingerprint (M2 through M6), the matching algorithm maintains the optimal transformation parameters:\n\n```mermaid\ngraph TB\n    subgraph \"Best Parameters for Candidate k\"\n        BIK[\"bi(k)\u003cbr/\u003eindex of minutia in M1\"]\n        BJK[\"bj(k)\u003cbr/\u003eindex of minutia in Mk\"]\n        BAK[\"ba(k)\u003cbr/\u003erotation angle in degrees\"]\n        SK[\"S(k)\u003cbr/\u003ebest similarity score\"]\n    end\n    \n    subgraph \"Update Logic\"\n        SCORE[\"sm = score(T1, T2)\"]\n        COMPARE{\"sm \u003e S(k)?\"}\n        UPDATE[\"S(k) = sm\u003cbr/\u003ebi(k) = i\u003cbr/\u003ebj(k) = j\u003cbr/\u003eba(k) = a\"]\n    end\n    \n    SCORE --\u003e COMPARE\n    COMPARE --\u003e|\"yes\"| UPDATE\n    UPDATE --\u003e BIK\n    UPDATE --\u003e BJK\n    UPDATE --\u003e BAK\n    UPDATE --\u003e SK\n```\n\n**Diagram: Best Parameter Tracking Logic**\n\nThese parameters define the optimal alignment transformation: translate M1 by minutia `bi(k)` to the origin, translate Mk by minutia `bj(k)` to the origin, then rotate Mk by `ba(k)` degrees [Copy_of_match.m:71-74]().\n\n**Sources:** [Copy_of_match.m:41-46](), [Copy_of_match.m:71-74](), [Copy_of_match.m:86-89](), [Copy_of_match.m:101-104](), [Copy_of_match.m:116-119](), [Copy_of_match.m:130-133]()\n\n## Display Mode Processing\n\nWhen `display_flag` is set to 1, the function performs additional post-processing to compute distance metrics:\n\n### Consistent Match Identification\n\nThe system identifies minutiae that are consistently matched across all five candidate fingerprints. A minutia from M1 is considered consistent if its mapping in the `T_index` array is non-zero for all candidates [Copy_of_match.m:181-199]():\n\n```mermaid\nflowchart TD\n    BUILD[\"Build T_index matrix\u003cbr/\u003erows: candidates M2-M6\u003cbr/\u003ecols: minutiae in M1\"]\n    \n    SCAN[\"For each minutia i in M1\"]\n    \n    CHECK{\"T_index(j, i) ≠ 0\u003cbr/\u003efor all j?\"}\n    \n    ADD[\"Add to Dist_index:\u003cbr/\u003e- minutia ID from M1\u003cbr/\u003e- matched IDs from M2-M6\"]\n    \n    SKIP[\"Skip this minutia\"]\n    \n    BUILD --\u003e SCAN\n    SCAN --\u003e CHECK\n    CHECK --\u003e|\"yes\"| ADD\n    CHECK --\u003e|\"no\"| SKIP\n```\n\n**Diagram: Consistent Match Identification Logic**\n\n**Sources:** [Copy_of_match.m:178-199]()\n\n### Distance Metric Calculation\n\nFor each consistently matched minutia, the system computes:\n\n1. **Transformed coordinates**: Apply the optimal transformation parameters to get aligned positions [Copy_of_match.m:203-222]()\n2. **Euclidean distances**: Calculate distances from the first matched minutia (reference point) [Copy_of_match.m:253-259]()\n3. **Averaged distances**: Exclude minimum and maximum values, then average [Copy_of_match.m:359-390]()\n\nThe final `result` array contains one distance value per consistently matched minutia (excluding the reference), representing the average spatial separation across all candidates.\n\n**Sources:** [Copy_of_match.m:226-390]()\n\n## Computational Complexity\n\nThe brute-force search strategy has significant computational cost:\n\nFor a single candidate comparison with `Count1` minutiae in M1, `Count2` minutiae in the candidate, and `A` rotation angles tested:\n\n**Time Complexity:** O(Count1 × Count2 × A × min(Count1, Count2))\n\nThe innermost `score` function has O(Count1 × Count2) complexity due to its nested loop [Copy_of_score.m:22-44]().\n\nFor the full `Copy_of_match` execution with `Number` iterations and 5 candidates per iteration:\n\n**Total Comparisons:** Number × 5 × Count1 × Count2 × A × min(Count1, Count2)\n\nWith typical minutiae counts of 20-50 per fingerprint and rotation ranges of 11-21 angles, this represents tens of thousands to millions of comparisons per function call.\n\n**Sources:** [Copy_of_match.m:63-137](), [Copy_of_score.m:22-44]()\n\n## Integration with Feature Extraction\n\nThe matching subsystem expects minutiae data in a specific format produced by the feature extraction pipeline (see [Feature Extraction Pipeline](#3.1)). The `db.mat` file serves as the interface between extraction and matching:\n\n```mermaid\ngraph LR\n    subgraph \"Feature Extraction Output\"\n        MINUTIAE[\"Minutiae Extraction\u003cbr/\u003e(not in visible files)\"]\n        FORMAT[\"Format: N×6 matrix\u003cbr/\u003ex, y, type, theta, id, attr\"]\n    end\n    \n    subgraph \"Storage\"\n        DB[(\"db.mat\u003cbr/\u003eff cell array\u003cbr/\u003egrouped by 8s\")]\n    end\n    \n    subgraph \"Matching Input\"\n        LOAD[\"Copy_of_match\u003cbr/\u003eloads from ff{Index}\"]\n    end\n    \n    MINUTIAE --\u003e FORMAT\n    FORMAT --\u003e DB\n    DB --\u003e LOAD\n```\n\n**Diagram: Integration Between Feature Extraction and Matching**\n\n**Sources:** [Copy_of_match.m:18](), [Copy_of_match.m:25-36]()"])</script><script>self.__next_f.push([1,"30:T3ca1,"])</script><script>self.__next_f.push([1,"# Match Algorithm\n\n\u003cdetails\u003e\n\u003csummary\u003eRelevant source files\u003c/summary\u003e\n\nThe following files were used as context for generating this wiki page:\n\n- [Copy_of_match.m](Copy_of_match.m)\n- [Copy_of_score.m](Copy_of_score.m)\n\n\u003c/details\u003e\n\n\n\nThis page documents the fingerprint matching algorithm implemented in `Copy_of_match.m`, which performs brute-force alignment search to find optimal transformation parameters that align a reference fingerprint with multiple candidate fingerprints. The algorithm systematically tests combinations of translation and rotation transformations to maximize similarity scores.\n\nFor details on how similarity is computed between transformed minutiae sets, see [Similarity Scoring](#3.2.2).\n\n---\n\n## Algorithm Overview\n\nThe matching algorithm implements a **brute-force search strategy** that exhaustively tests spatial transformations to align fingerprint minutiae. The algorithm compares one reference fingerprint against five randomly selected candidate fingerprints from the same finger group in the database.\n\n```mermaid\ngraph TB\n    START[\"Copy_of_match(Index, Number, display_flag)\"]\n    LOAD[\"Load db.mat\u003cbr/\u003eExtract ff cell array\"]\n    SELECT[\"Select Reference: M1 = ff{Index*8-7}\u003cbr/\u003eSelect 5 Candidates: M2-M6 = ff{random}\"]\n    FILTER[\"Filter Minutiae\u003cbr/\u003eKeep only column 3 \u003c 5\"]\n    \n    SEARCH[\"Brute-Force Alignment Search\u003cbr/\u003eFor each M1 minutia (i)\u003cbr/\u003eFor each candidate minutia (j)\u003cbr/\u003eFor each rotation angle (α)\"]\n    \n    TRANSFORM[\"Apply Transformations:\u003cbr/\u003e1. transform(M, i) - Translation\u003cbr/\u003e2. transform2(T, α) - Rotation\"]\n    \n    SCORE[\"score(T1, T2)\u003cbr/\u003eCalculate Similarity\"]\n    \n    BEST[\"Track Best Parameters\u003cbr/\u003ebi, bj, ba, S for each candidate\"]\n    \n    CONSISTENT[\"Find Consistently Matched Minutiae\u003cbr/\u003ePresent in all 5 candidate matches\"]\n    \n    DISTANCE[\"Calculate Distance Metrics\u003cbr/\u003eEuclidean distances in transformed space\"]\n    \n    RESULT[\"Return: result array\u003cbr/\u003eAverage distances per minutia\"]\n    \n    START --\u003e LOAD\n    LOAD --\u003e SELECT\n    SELECT --\u003e FILTER\n    FILTER --\u003e SEARCH\n    SEARCH --\u003e TRANSFORM\n    TRANSFORM --\u003e SCORE\n    SCORE --\u003e BEST\n    BEST --\u003e CONSISTENT\n    CONSISTENT --\u003e DISTANCE\n    DISTANCE --\u003e RESULT\n    \n    style START fill:#e8e8e8\n    style RESULT fill:#e8e8e8\n    style SEARCH fill:#f0f0f0\n```\n\n**Sources:** [Copy_of_match.m:1-411]()\n\n---\n\n## Input Data Structure\n\nThe algorithm operates on minutiae data stored in `db.mat`, which contains a cell array `ff` where each cell holds minutiae for one fingerprint image.\n\n### Function Signature\n\n```matlab\nfunction [ result, result_r ] = Copy_of_match( Index, Number, display_flag )\n```\n\n| Parameter | Type | Description |\n|-----------|------|-------------|\n| `Index` | Integer | Fingerprint group index (1-based). Converted to database index via `Index*8-7` |\n| `Number` | Integer | Number of independent matching iterations to perform |\n| `display_flag` | Integer | 0 = return scores only, 1 = calculate detailed distance metrics |\n| `result` | Array | Output: average distance metrics for consistently matched minutiae |\n| `result_r` | Array | Output: indices of the 5 randomly selected candidates |\n\n### Minutiae Data Format\n\nEach minutiae set is a matrix where rows represent individual minutiae and columns contain:\n\n| Column | Data | Usage |\n|--------|------|-------|\n| 1 | X coordinate | Spatial matching |\n| 2 | Y coordinate | Spatial matching |\n| 3 | Minutiae type | Pre-filtering criterion (keep if \u003c 5) |\n| Additional | Orientation, etc. | Used in scoring function |\n\n**Sources:** [Copy_of_match.m:17-30](), [Copy_of_match.m:31-36]()\n\n---\n\n## Candidate Selection and Filtering\n\n### Database Index Calculation\n\nThe algorithm maps the input `Index` parameter to a database position:\n\n```matlab\nIndex = Index*8 - 7\n```\n\nThis suggests the database is organized in groups of 8 fingerprints per finger, and the algorithm selects the first image from each group as the reference.\n\n### Random Candidate Selection\n\nFive candidate fingerprints are randomly selected from the same finger group:\n\n```matlab\nr = randperm(7, 5) + Index\n```\n\nThis selects 5 unique indices from the range `[Index+1, Index+7]`, representing different impressions of the same finger.\n\n### Minutiae Type Filtering\n\nBefore matching, minutiae are filtered to retain only specific types:\n\n```matlab\nM1 = M1(M1(:,3) \u003c 5, :)\n```\n\nThis filtering step [Copy_of_match.m:31-36]() removes minutiae with type value ≥ 5, likely excluding unreliable or low-quality features.\n\n**Sources:** [Copy_of_match.m:18-36]()\n\n---\n\n## Transformation Search Strategy\n\nThe algorithm searches for the optimal alignment by testing combinations of translation and rotation transformations.\n\n### Two-Stage Transformation\n\n```mermaid\ngraph LR\n    ORIGINAL[\"Original Minutiae\u003cbr/\u003eM = [(x,y,θ,...)]\"]\n    TRANS[\"transform(M, i)\u003cbr/\u003eTranslate so M(i) → origin\"]\n    T1[\"Translated Minutiae\u003cbr/\u003eT = [(x',y',θ,...)]\"]\n    ROTATE[\"transform2(T, α)\u003cbr/\u003eRotate by angle α\"]\n    T2[\"Aligned Minutiae\u003cbr/\u003eT' = [(x'',y'',θ',...)]\"]\n    \n    ORIGINAL --\u003e TRANS\n    TRANS --\u003e T1\n    T1 --\u003e ROTATE\n    ROTATE --\u003e T2\n```\n\n### Transformation Functions\n\n| Function | Purpose | Implementation |\n|----------|---------|----------------|\n| `transform(M, i)` | Translates minutiae set M such that minutia i is at the origin | Not shown in provided files |\n| `transform2(T, alpha)` | Rotates translated minutiae T by angle alpha (radians) | Not shown in provided files |\n\nThese transformations establish a coordinate system where corresponding minutiae from different fingerprints can be directly compared.\n\n**Sources:** [Copy_of_match.m:64](), [Copy_of_match.m:69](), [Copy_of_match.m:84]()\n\n---\n\n## Brute-Force Alignment Search\n\nThe core matching algorithm uses nested loops to exhaustively search the transformation space.\n\n```mermaid\ngraph TB\n    subgraph \"Outer Loop: Reference Minutiae\"\n        I_LOOP[\"for i = 1:count1\u003cbr/\u003e(Each minutia in M1)\"]\n        TRANSFORM_M1[\"T1 = transform(M1, i)\"]\n    end\n    \n    subgraph \"Middle Loop: Candidate Minutiae\"\n        J_LOOP[\"for j = 1:count2\u003cbr/\u003e(Each minutia in M2)\"]\n        TYPE_CHECK[\"if M1(i,3) == M2(j,3)\u003cbr/\u003e(Same minutiae type)\"]\n        TRANSFORM_M2[\"T2 = transform(M2, j)\"]\n    end\n    \n    subgraph \"Inner Loop: Rotation Angles\"\n        A_LOOP[\"for a = -10:10\u003cbr/\u003e(α in degrees)\"]\n        ROTATE[\"T22 = transform2(T2, α*π/180)\"]\n        SCORE_CALL[\"[sm, sm2] = score(T1, T22)\"]\n        UPDATE[\"if S2 \u003c sm:\u003cbr/\u003eS2=sm; bi2=i; bj2=j; ba2=a\"]\n    end\n    \n    I_LOOP --\u003e TRANSFORM_M1\n    TRANSFORM_M1 --\u003e J_LOOP\n    J_LOOP --\u003e TYPE_CHECK\n    TYPE_CHECK --\u003e|Match| TRANSFORM_M2\n    TRANSFORM_M2 --\u003e A_LOOP\n    A_LOOP --\u003e ROTATE\n    ROTATE --\u003e SCORE_CALL\n    SCORE_CALL --\u003e UPDATE\n    UPDATE --\u003e A_LOOP\n```\n\n### Search Parameters by Candidate\n\nThe algorithm uses different rotation angle ranges for different candidates:\n\n| Candidate | Variable | Rotation Range | Line Reference |\n|-----------|----------|----------------|----------------|\n| M2 | α2 | -10° to +10° (21 angles) | [Copy_of_match.m:68]() |\n| M3 | α3 | -5° to +5° (11 angles) | [Copy_of_match.m:83]() |\n| M4 | α4 | -10° to +10° (21 angles) | [Copy_of_match.m:98]() |\n| M5 | α5 | -5° to +5° (11 angles) | [Copy_of_match.m:113]() |\n| M6 | α6 | -5° to +5° (11 angles) | [Copy_of_match.m:127]() |\n\nThis variation may be an experimental configuration or optimization strategy.\n\n### Computational Complexity\n\nFor a reference with `count1` minutiae and candidate with `count2` minutiae:\n\n- **Transformations tested per candidate:** `count1 × count2 × rotation_angles`\n- **Total transformations for 5 candidates:** Approximately `5 × count1 × count2 × 15` (assuming average 15 rotation angles)\n- **Typical scale:** With ~50 minutiae per fingerprint: `5 × 50 × 50 × 15 = 187,500` transformations\n\n**Sources:** [Copy_of_match.m:63-137]()\n\n---\n\n## Best Transformation Selection\n\nFor each candidate fingerprint, the algorithm maintains the best alignment parameters found during the search.\n\n### Tracked Parameters\n\n```matlab\n% Initialize for each candidate M2-M6\nbi2=0; bj2=0; ba2=0;  % Best translation indices and rotation angle\nS2=0;                  % Best similarity score\n```\n\n### Update Logic\n\n```matlab\n[sm, sm2] = score(T1, T22);\nif S2 \u003c sm\n    S2 = sm;\n    bi2 = i;    % Reference minutia index\n    bj2 = j;    % Candidate minutia index  \n    ba2 = a;    % Rotation angle (degrees)\n    T22_ = sm2; % Matched minutiae indices\nend\n```\n\nThe algorithm updates the best parameters whenever a higher similarity score is found [Copy_of_match.m:71-74]().\n\n### Best Transformation Storage\n\n| Variable | Stores | Description |\n|----------|--------|-------------|\n| `S2` - `S6` | Float | Best similarity measure for candidates M2-M6 |\n| `bi2` - `bi6` | Integer | Index of reference minutia that gives best alignment |\n| `bj2` - `bj6` | Integer | Index of candidate minutia that gives best alignment |\n| `ba2` - `ba6` | Integer | Rotation angle (degrees) that gives best alignment |\n| `T22_` - `T66_` | Array | Mapping of matched minutiae indices |\n\n**Sources:** [Copy_of_match.m:41-46](), [Copy_of_match.m:71-74]()\n\n---\n\n## Consistent Match Analysis\n\nAfter completing the brute-force search across multiple iterations, the algorithm identifies minutiae that consistently match across all candidates.\n\n```mermaid\ngraph TB\n    COLLECT[\"Collect Matched Indices\u003cbr/\u003eT_index = [T22_; T33_; T44_; T55_; T66_]\u003cbr/\u003eSize: (Number*5) × count1\"]\n    \n    ITERATE[\"for i = 1:count1\u003cbr/\u003e(Each reference minutia)\"]\n    \n    CHECK[\"Check All Matches\u003cbr/\u003eif T_index(j,i) ≠ 0\u003cbr/\u003efor all j in 1:Number*5\"]\n    \n    RECORD[\"Record Consistent Minutia\u003cbr/\u003eDist_index(I,1) = i\u003cbr/\u003eDist_index(I,2:6) = matched indices\"]\n    \n    COLLECT --\u003e ITERATE\n    ITERATE --\u003e CHECK\n    CHECK --\u003e|All matched| RECORD\n    CHECK --\u003e|Any zero| ITERATE\n    \n    style COLLECT fill:#f0f0f0\n```\n\n### Consistency Criterion\n\nA minutia from the reference fingerprint (M1) is considered \"consistently matched\" if:\n\n1. It has a corresponding match in **all 5 candidate fingerprints**\n2. Across **all Number iterations** of the matching process\n3. Condition: `T_index(j, i) ≠ 0` for all rows j\n\nThis filtering produces a set of highly reliable minutiae correspondences.\n\n### Data Structure: Dist_index\n\n```matlab\nDist_index(I, 1)   = i           % Reference minutia index\nDist_index(I, 2)   = T22_(i)     % Match in M2\nDist_index(I, 3)   = T33_(i)     % Match in M3\nDist_index(I, 4)   = T44_(i)     % Match in M4\nDist_index(I, 5)   = T55_(i)     % Match in M5\nDist_index(I, 6)   = T66_(i)     % Match in M6\n```\n\nEach row represents a consistently matched minutia with its corresponding indices in all candidate fingerprints.\n\n**Sources:** [Copy_of_match.m:178-199]()\n\n---\n\n## Distance Metric Calculation\n\nWhen `display_flag == 1`, the algorithm performs detailed geometric analysis of the consistently matched minutiae.\n\n### Reconstruction of Transformed Coordinates\n\nFor each consistently matched minutia, the algorithm reconstructs the coordinates in both reference and transformed spaces:\n\n```matlab\n% Apply best transformations\nT12 = transform(M1, bi2);\nT22 = transform2(transform(M2, bj2), ba2*pi/180);\n\n% Extract coordinates for matched minutiae\nfor i = 1:I\n    Dist(i, 1) = T12(Dist_index(i,1), 1);  % Reference X\n    Dist(i, 2) = T12(Dist_index(i,1), 2);  % Reference Y\n    Dist(i, 3) = T22(Dist_index(i,2), 1);  % M2 transformed X\n    Dist(i, 4) = T22(Dist_index(i,2), 2);  % M2 transformed Y\n    % ... similarly for M3-M6\nend\n```\n\n### Euclidean Distance Computation\n\nThe algorithm calculates distances between each minutia and the first consistently matched minutia (used as a reference point):\n\n```matlab\nif i ~= 1\n    % Distance in M2 transformed space\n    Dist(i, 21) = sqrt((Dist(i,3)-Dist(1,3))^2 + (Dist(i,4)-Dist(1,4))^2);\n    \n    % Distance in M3 transformed space  \n    Dist(i, 22) = sqrt((Dist(i,7)-Dist(1,7))^2 + (Dist(i,8)-Dist(1,8))^2);\n    \n    % ... similarly for M4, M5, M6\n    \n    % Distance in reference (M1) space\n    Dist(i, 26) = sqrt((Dist(i,1)-Dist(1,1))^2 + (Dist(i,2)-Dist(1,2))^2);\nend\n```\n\n### Averaged Distance Results\n\nThe final result excludes outliers (maximum and minimum distances) and averages the remaining values:\n\n```matlab\n% For each minutia (excluding first reference point)\nfor i = 2:m\n    % Find max and min across all 6 distances\n    [max_value, max_index] = find_max(T(i, :));\n    [min_value, min_index] = find_min(T(i, :));\n    \n    % Calculate average excluding max and min\n    sum = sum(T(i, :));\n    result(i-1) = (sum - max - min) / (n - 2);\nend\n```\n\nThis produces a robust distance metric for each consistently matched minutia [Copy_of_match.m:359-390]().\n\n**Sources:** [Copy_of_match.m:201-410](), [Copy_of_match.m:226-264](), [Copy_of_match.m:353-390]()\n\n---\n\n## Algorithm Flow Summary\n\n```mermaid\nflowchart TD\n    INPUT[\"Input: Index, Number, display_flag\"]\n    \n    LOAD_DB[\"Load db.mat → ff cell array\"]\n    \n    INIT[\"Initialize:\u003cbr/\u003eIndex = Index*8-7\u003cbr/\u003eM1 = ff{Index}\u003cbr/\u003eSelect 5 random candidates\"]\n    \n    FILTER[\"Filter minutiae:\u003cbr/\u003eKeep only type \u003c 5\"]\n    \n    OUTER[\"Repeat Number times\"]\n    \n    SEARCH[\"Triple-nested loop:\u003cbr/\u003ei: reference minutiae\u003cbr/\u003ej: candidate minutiae\u003cbr/\u003ea: rotation angles\"]\n    \n    TRANSFORM[\"Apply transform(M,i)\u003cbr/\u003ethen transform2(T,a)\"]\n    \n    SCORE_FN[\"Call score(T1,T2)\u003cbr/\u003eGet similarity sm\"]\n    \n    UPDATE[\"Update best S, bi, bj, ba\u003cbr/\u003eif sm improves\"]\n    \n    COLLECT[\"Collect T22_-T66_\u003cbr/\u003einto T_index matrix\"]\n    \n    CONSISTENT_CHECK[\"Find minutiae with\u003cbr/\u003enon-zero matches in all\u003cbr/\u003eNumber*5 rows\"]\n    \n    DISPLAY_Q{display_flag == 1?}\n    \n    CALC_DIST[\"Calculate Dist matrix:\u003cbr/\u003e- Reconstruct coordinates\u003cbr/\u003e- Compute Euclidean distances\u003cbr/\u003e- Average excluding outliers\"]\n    \n    RETURN_SIMPLE[\"Return: result_r\"]\n    \n    RETURN_DETAILED[\"Return: result, result_r\"]\n    \n    INPUT --\u003e LOAD_DB\n    LOAD_DB --\u003e INIT\n    INIT --\u003e FILTER\n    FILTER --\u003e OUTER\n    OUTER --\u003e SEARCH\n    SEARCH --\u003e TRANSFORM\n    TRANSFORM --\u003e SCORE_FN\n    SCORE_FN --\u003e UPDATE\n    UPDATE --\u003e COLLECT\n    COLLECT --\u003e CONSISTENT_CHECK\n    CONSISTENT_CHECK --\u003e DISPLAY_Q\n    DISPLAY_Q --\u003e|No| RETURN_SIMPLE\n    DISPLAY_Q --\u003e|Yes| CALC_DIST\n    CALC_DIST --\u003e RETURN_DETAILED\n    \n    style INPUT fill:#e8e8e8\n    style RETURN_SIMPLE fill:#e8e8e8\n    style RETURN_DETAILED fill:#e8e8e8\n    style SEARCH fill:#f0f0f0\n```\n\n**Sources:** [Copy_of_match.m:1-411]()\n\n---\n\n## Key Design Characteristics\n\n### Exhaustive Search Approach\n\nThe algorithm implements a **complete brute-force search** rather than using optimization techniques like gradient descent or RANSAC. This guarantees finding the globally optimal alignment within the discrete search space but has high computational cost.\n\n### Multiple Candidate Comparison\n\nBy comparing against 5 candidates simultaneously and tracking consistently matched minutiae, the algorithm achieves:\n\n- **Robustness:** Matches must be consistent across multiple comparisons\n- **Reliability filtering:** Spurious matches are excluded if not consistently present\n- **Geometric validation:** Distance metrics verify spatial consistency of matches\n\n### Type-Based Pre-alignment\n\nThe constraint `if M1(i,3) == M2(j,3)` [Copy_of_match.m:66]() ensures that only minutiae of the same type are used as alignment anchors. This reduces the search space and prevents meaningless transformations based on incompatible minutiae types.\n\n**Sources:** [Copy_of_match.m:63-137](), [Copy_of_match.m:180-199]()"])</script><script>self.__next_f.push([1,"31:T2fa9,"])</script><script>self.__next_f.push([1,"# Similarity Scoring\n\n\u003cdetails\u003e\n\u003csummary\u003eRelevant source files\u003c/summary\u003e\n\nThe following files were used as context for generating this wiki page:\n\n- [Copy_of_match.m](Copy_of_match.m)\n- [Copy_of_score.m](Copy_of_score.m)\n\n\u003c/details\u003e\n\n\n\n## Purpose and Scope\n\nThis page documents the similarity scoring function that quantifies how well two sets of transformed minutiae match. The `score()` function implements the core matching logic by counting minutiae pairs that satisfy both spatial and angular proximity thresholds, then computing a normalized similarity measure.\n\nFor information about how the scoring function is integrated into the overall fingerprint matching workflow, including the transformation search process, see [Match Algorithm](#3.2.1). For background on the feature extraction pipeline that produces the minutiae data, see [Feature Extraction Pipeline](#3.1).\n\n**Sources:** [Copy_of_score.m:1-47]()\n\n---\n\n## Function Overview\n\nThe similarity scoring function is implemented in `score()` and serves as the fundamental comparison operator between two transformed minutiae sets. After the match algorithm applies translation and rotation transformations to align fingerprints (see [Match Algorithm](#3.2.1)), the scoring function determines the quality of that alignment.\n\n```mermaid\ngraph TB\n    subgraph \"Input Data\"\n        T1[\"T1: Reference Minutiae\u003cbr/\u003e(transformed)\"]\n        T2[\"T2: Candidate Minutiae\u003cbr/\u003e(transformed)\"]\n    end\n    \n    subgraph \"score() Function\"\n        LOOP[\"Nested Loop\u003cbr/\u003eFor each T1(i)\u003cbr/\u003eCheck all T2(j)\"]\n        SPATIAL[\"Spatial Check\u003cbr/\u003ed \u003c 15 pixels?\"]\n        ANGULAR[\"Angular Check\u003cbr/\u003eDTheta \u003c 14°?\"]\n        COUNT[\"Increment Match Count\u003cbr/\u003en = n + 1\"]\n        STORE[\"Store Match Index\u003cbr/\u003eT2_(T1(i,5)) = T2(j,5)\"]\n    end\n    \n    subgraph \"Output\"\n        SM[\"sm: Similarity Measure\u003cbr/\u003esqrt(n²/(Count1*Count2))\"]\n        T2_[\"T2_: Match Index Array\u003cbr/\u003eMaps T1 minutiae to T2\"]\n    end\n    \n    T1 --\u003e LOOP\n    T2 --\u003e LOOP\n    LOOP --\u003e SPATIAL\n    SPATIAL --\u003e|\"Yes\"| ANGULAR\n    SPATIAL --\u003e|\"No\"| LOOP\n    ANGULAR --\u003e|\"Yes\"| COUNT\n    ANGULAR --\u003e|\"No\"| LOOP\n    COUNT --\u003e STORE\n    STORE --\u003e LOOP\n    LOOP --\u003e SM\n    LOOP --\u003e T2_\n    \n    SM --\u003e RESULT[\"Returns: [sm, T2_]\"]\n    T2_ --\u003e RESULT\n```\n\n**Diagram: Similarity Scoring Algorithm Flow**\n\nThe function signature is:\n\n```matlab\nfunction [ sm , T2_ ] = score( T1, T2 )\n```\n\n**Sources:** [Copy_of_score.m:16-47]()\n\n---\n\n## Minutiae Data Structure\n\nThe transformed minutiae arrays (`T1` and `T2`) have a specific column structure that the scoring function expects:\n\n| Column Index | Description | Units |\n|--------------|-------------|-------|\n| Column 1 | X coordinate (transformed) | Pixels |\n| Column 2 | Y coordinate (transformed) | Pixels |\n| Column 3 | Orientation angle (transformed) | Radians |\n| Column 5 | Original minutia index | Integer ID |\n\nThe scoring function primarily uses columns 1, 2, 3, and 5 to compare minutiae positions, orientations, and track which minutiae have been matched.\n\n**Sources:** [Copy_of_score.m:25-34]()\n\n---\n\n## Matching Criteria\n\nThe scoring function employs a two-stage threshold-based matching criterion. A minutia pair is considered a match only if it satisfies **both** spatial proximity and angular similarity requirements.\n\n### Spatial Distance Threshold\n\nThe Euclidean distance between two minutiae must be less than **15 pixels**:\n\n```matlab\nT = 15;  % Threshold for distance\ndx = (T1(i,1) - T2(j,1));\ndy = (T1(i,2) - T2(j,2));\nd = sqrt(dx^2 + dy^2);\nif d \u003c T\n    % Proceed to angular check\nend\n```\n\nThis threshold accounts for minor alignment imperfections that may remain after transformation, as well as natural variations in minutiae extraction across different fingerprint impressions.\n\n**Sources:** [Copy_of_score.m:20, 25-28]()\n\n### Angular Threshold\n\nThe angular difference between minutiae orientations must be less than **14 degrees**:\n\n```matlab\nTT = 14;  % Threshold for theta (degrees)\nDTheta = abs(T1(i,3) - T2(j,3)) * 180/pi;\nDTheta = min(DTheta, 360 - DTheta);\nif DTheta \u003c TT\n    n = n + 1;  % Match found\nend\n```\n\nThe algorithm handles angular wraparound by taking the minimum of `DTheta` and `360 - DTheta`, ensuring that angles near 0° and 360° are treated correctly. For example, an angle difference between 355° and 5° is computed as 10° rather than 350°.\n\n**Sources:** [Copy_of_score.m:21, 29-32]()\n\n```mermaid\ngraph LR\n    subgraph \"Matching Decision Tree\"\n        START[\"Minutia Pair\u003cbr/\u003e(T1(i), T2(j))\"]\n        DIST[\"Calculate Distance\u003cbr/\u003ed = sqrt(dx² + dy²)\"]\n        CHECK_D{\"d \u003c 15?\"}\n        ANGLE[\"Calculate Angle Diff\u003cbr/\u003eDTheta = |θ₁ - θ₂|\"]\n        WRAP[\"Handle Wraparound\u003cbr/\u003emin(DTheta, 360-DTheta)\"]\n        CHECK_A{\"DTheta \u003c 14°?\"}\n        MATCH[\"MATCH\u003cbr/\u003en = n + 1\"]\n        NO_MATCH[\"NO MATCH\u003cbr/\u003eContinue\"]\n    end\n    \n    START --\u003e DIST\n    DIST --\u003e CHECK_D\n    CHECK_D --\u003e|\"No\"| NO_MATCH\n    CHECK_D --\u003e|\"Yes\"| ANGLE\n    ANGLE --\u003e WRAP\n    WRAP --\u003e CHECK_A\n    CHECK_A --\u003e|\"Yes\"| MATCH\n    CHECK_A --\u003e|\"No\"| NO_MATCH\n```\n\n**Diagram: Two-Stage Matching Decision Process**\n\n**Sources:** [Copy_of_score.m:25-32]()\n\n---\n\n## Similarity Measure Calculation\n\nAfter counting all matched minutiae pairs (`n`), the function computes a normalized similarity measure:\n\n```\nsm = sqrt(n² / (Count1 × Count2))\n```\n\nWhere:\n- `n` = number of matched minutiae pairs\n- `Count1` = total number of minutiae in T1\n- `Count2` = total number of minutiae in T2\n\nThis formula has several important properties:\n\n| Property | Description |\n|----------|-------------|\n| **Normalization** | The division by `Count1 × Count2` normalizes for fingerprint size differences |\n| **Square term** | The `n²` numerator emphasizes the importance of having many matches |\n| **Range** | The similarity measure ranges from 0 (no matches) to 1 (perfect match) |\n| **Symmetry** | The measure is symmetric: `score(T1, T2) = score(T2, T1)` |\n\nThe square root operation brings the final score into a more intuitive range where higher values indicate better matches. The quadratic emphasis on match count means that a fingerprint with 10 matched minutiae scores significantly better than one with 5 matches.\n\n**Sources:** [Copy_of_score.m:46]()\n\n```mermaid\ngraph TB\n    subgraph \"Similarity Measure Components\"\n        N[\"n\u003cbr/\u003eMatched Minutiae Count\"]\n        C1[\"Count1\u003cbr/\u003eMinutiae in T1\"]\n        C2[\"Count2\u003cbr/\u003eMinutiae in T2\"]\n    end\n    \n    subgraph \"Formula Stages\"\n        PROD[\"Product\u003cbr/\u003eCount1 × Count2\"]\n        NSQUARE[\"Square\u003cbr/\u003en²\"]\n        DIV[\"Division\u003cbr/\u003en² / (Count1 × Count2)\"]\n        SQRT[\"Square Root\u003cbr/\u003esqrt(...)\"]\n    end\n    \n    subgraph \"Output\"\n        SM[\"sm\u003cbr/\u003eSimilarity Measure\u003cbr/\u003eRange: [0, 1]\"]\n    end\n    \n    N --\u003e NSQUARE\n    C1 --\u003e PROD\n    C2 --\u003e PROD\n    \n    NSQUARE --\u003e DIV\n    PROD --\u003e DIV\n    DIV --\u003e SQRT\n    SQRT --\u003e SM\n```\n\n**Diagram: Similarity Measure Computation Pipeline**\n\n**Sources:** [Copy_of_score.m:17, 46]()\n\n---\n\n## Return Values\n\nThe `score()` function returns two outputs:\n\n### Primary Output: `sm`\n\nThe similarity measure (floating-point value between 0 and 1) quantifying match quality. This value is used by the match algorithm to determine the best transformation parameters.\n\n### Secondary Output: `T2_`\n\nAn array of length `Count1` that maps each minutia in `T1` to its matched counterpart in `T2`:\n\n```matlab\nT2_(Count1) = 0;  % Initialize array\n% ...\nif match_found\n    T2_(T1(i,5)) = T2(j,5);  % Store matched index\nend\n```\n\nThe array is indexed by the original minutia ID from `T1` (column 5), and stores the corresponding minutia ID from `T2`. A value of 0 indicates no match was found for that minutia.\n\nThis mapping is used by the match algorithm's display mode to track consistent matches across multiple candidate fingerprints and compute distance metrics.\n\n**Sources:** [Copy_of_score.m:16, 19, 34]()\n\n---\n\n## Integration with Match Algorithm\n\nThe scoring function is called repeatedly during the transformation search process in `Copy_of_match.m`. The match algorithm follows this pattern:\n\n```mermaid\ngraph TB\n    subgraph \"Match Algorithm Loop Structure\"\n        MINUTIA_I[\"For i = 1:count1\u003cbr/\u003e(Each T1 minutia)\"]\n        MINUTIA_J[\"For j = 1:count2\u003cbr/\u003e(Each T2 minutia)\"]\n        TYPE_CHECK{\"M1(i,3) ==\u003cbr/\u003eM2(j,3)?\"}\n        TRANS[\"Apply Translation\u003cbr/\u003etransform(M2, j)\"]\n        ANGLE_LOOP[\"For a = -10:10\u003cbr/\u003e(Rotation angles)\"]\n        ROT[\"Apply Rotation\u003cbr/\u003etransform2(T2, a*π/180)\"]\n        SCORE_CALL[\"Call score(T1, T22)\u003cbr/\u003eReturns [sm, sm2]\"]\n        UPDATE{\"sm \u003e S2?\"}\n        SAVE[\"Update Best:\u003cbr/\u003eS2 = sm\u003cbr/\u003ebi2, bj2, ba2\"]\n    end\n    \n    MINUTIA_I --\u003e MINUTIA_J\n    MINUTIA_J --\u003e TYPE_CHECK\n    TYPE_CHECK --\u003e|\"No\"| MINUTIA_J\n    TYPE_CHECK --\u003e|\"Yes\"| TRANS\n    TRANS --\u003e ANGLE_LOOP\n    ANGLE_LOOP --\u003e ROT\n    ROT --\u003e SCORE_CALL\n    SCORE_CALL --\u003e UPDATE\n    UPDATE --\u003e|\"Yes\"| SAVE\n    UPDATE --\u003e|\"No\"| ANGLE_LOOP\n    SAVE --\u003e ANGLE_LOOP\n    ANGLE_LOOP --\u003e MINUTIA_J\n    MINUTIA_J --\u003e MINUTIA_I\n```\n\n**Diagram: Score Function Integration in Match Loop**\n\nThe match algorithm calls `score()` thousands of times (once for each combination of minutia pairs and rotation angles) to find the optimal alignment:\n\n| Matching Stage | Lines in Copy_of_match.m | Rotation Range | Purpose |\n|----------------|--------------------------|----------------|---------|\n| M2 matching | [Copy_of_match.m:68-75]() | -10° to +10° | First candidate comparison |\n| M3 matching | [Copy_of_match.m:83-89]() | -5° to +5° | Second candidate comparison |\n| M4 matching | [Copy_of_match.m:98-104]() | -10° to +10° | Third candidate comparison |\n| M5 matching | [Copy_of_match.m:113-119]() | -5° to +5° | Fourth candidate comparison |\n| M6 matching | [Copy_of_match.m:127-133]() | -5° to +5° | Fifth candidate comparison |\n\nFor each transformation tested, the similarity score determines whether the current alignment is better than the previous best. The transformation parameters that produce the highest similarity score are retained.\n\n**Sources:** [Copy_of_match.m:63-137]()\n\n---\n\n## Algorithm Complexity\n\nThe scoring function's computational complexity is:\n\n```\nO(Count1 × Count2)\n```\n\nFor each minutia in `T1` (Count1 iterations), the algorithm performs a linear search through all minutiae in `T2` (up to Count2 iterations). The early termination when a match is found (`Found=0` flag) provides some optimization but doesn't change the worst-case complexity.\n\nWhen integrated into the match algorithm's transformation search:\n\n```\nTotal complexity: O(Count1 × Count2 × (Count1 + Count2) × NumAngles)\n```\n\nWhere:\n- The outer loops iterate over all minutia pairs: `Count1 × Count2`\n- Each call to `score()` costs: `Count1 × Count2`\n- `NumAngles` ranges from 11 to 21 depending on the candidate fingerprint\n\nThis brute-force approach ensures thorough exploration of the transformation space at the cost of computational efficiency.\n\n**Sources:** [Copy_of_score.m:22-44](), [Copy_of_match.m:63-137]()\n\n---\n\n## Match Index Tracking\n\nThe secondary output `T2_` enables downstream analysis of which specific minutiae contributed to the match:\n\n```mermaid\ngraph LR\n    subgraph \"Match Index Array Structure\"\n        T2_1[\"T2_(1)\"]\n        T2_2[\"T2_(2)\"]\n        T2_3[\"T2_(3)\"]\n        T2_DOT[\"...\"]\n        T2_N[\"T2_(Count1)\"]\n    end\n    \n    subgraph \"Interpretation\"\n        VAL_0[\"Value = 0\u003cbr/\u003eNo match found\"]\n        VAL_K[\"Value = k\u003cbr/\u003eMatched to T2's\u003cbr/\u003eminutia k\"]\n    end\n    \n    T2_1 -.-\u003e VAL_K\n    T2_2 -.-\u003e VAL_0\n    T2_3 -.-\u003e VAL_K\n    T2_DOT -.-\u003e VAL_0\n    T2_N -.-\u003e VAL_K\n```\n\n**Diagram: Match Index Array Mapping**\n\nThe match algorithm uses these indices to:\n\n1. **Track consistency** across multiple candidates ([Copy_of_match.m:180-199]())\n2. **Build correspondence arrays** for distance calculations ([Copy_of_match.m:226-265]())\n3. **Identify stable matching minutiae** that match across all five candidate fingerprints\n\nOnly minutiae that appear in all match index arrays (`T22_`, `T33_`, `T44_`, `T55_`, `T66_`) are used for final distance metric calculations, ensuring robust matching results.\n\n**Sources:** [Copy_of_score.m:19, 34](), [Copy_of_match.m:73, 88, 103, 118, 132, 178-199]()"])</script><script>self.__next_f.push([1,"5:[\"$\",\"$L15\",null,{\"repoName\":\"QinMoMeak/Simple_FingerPrint_Matching\",\"hasConfig\":false,\"canSteer\":true,\"children\":[\"$\",\"$L16\",null,{\"wiki\":{\"metadata\":{\"repo_name\":\"QinMoMeak/Simple_FingerPrint_Matching\",\"commit_hash\":\"5cdd0b1a\",\"generated_at\":\"2026-02-19T03:40:37.381719\",\"config\":null,\"config_source\":\"none\"},\"pages\":[{\"page_plan\":{\"id\":\"1\",\"title\":\"Overview\"},\"content\":\"$17\"},{\"page_plan\":{\"id\":\"1.1\",\"title\":\"System Architecture\"},\"content\":\"$18\"},{\"page_plan\":{\"id\":\"1.2\",\"title\":\"Data Files and Dependencies\"},\"content\":\"$19\"},{\"page_plan\":{\"id\":\"2\",\"title\":\"AES Encryption System\"},\"content\":\"$1a\"},{\"page_plan\":{\"id\":\"2.1\",\"title\":\"Key Expansion\"},\"content\":\"$1b\"},{\"page_plan\":{\"id\":\"2.2\",\"title\":\"Encryption Process\"},\"content\":\"$1c\"},{\"page_plan\":{\"id\":\"2.2.1\",\"title\":\"SubBytes Transformation\"},\"content\":\"$1d\"},{\"page_plan\":{\"id\":\"2.2.2\",\"title\":\"ShiftRows Transformation\"},\"content\":\"$1e\"},{\"page_plan\":{\"id\":\"2.2.3\",\"title\":\"MixColumns Transformation\"},\"content\":\"$1f\"},{\"page_plan\":{\"id\":\"2.2.4\",\"title\":\"AddRoundKey Transformation\"},\"content\":\"$20\"},{\"page_plan\":{\"id\":\"2.3\",\"title\":\"Decryption Process\"},\"content\":\"$21\"},{\"page_plan\":{\"id\":\"2.3.1\",\"title\":\"InvSubBytes Transformation\"},\"content\":\"$22\"},{\"page_plan\":{\"id\":\"2.3.2\",\"title\":\"InvShiftRows Transformation\"},\"content\":\"$23\"},{\"page_plan\":{\"id\":\"2.3.3\",\"title\":\"InvMixColumns Transformation\"},\"content\":\"$24\"},{\"page_plan\":{\"id\":\"2.4\",\"title\":\"Galois Field Arithmetic\"},\"content\":\"$25\"},{\"page_plan\":{\"id\":\"3\",\"title\":\"Fingerprint Processing System\"},\"content\":\"$26\"},{\"page_plan\":{\"id\":\"3.1\",\"title\":\"Feature Extraction Pipeline\"},\"content\":\"$27\"},{\"page_plan\":{\"id\":\"3.1.1\",\"title\":\"Image Segmentation and Normalization\"},\"content\":\"$28\"},{\"page_plan\":{\"id\":\"3.1.2\",\"title\":\"Ridge Orientation Estimation\"},\"content\":\"$29\"},{\"page_plan\":{\"id\":\"3.1.3\",\"title\":\"Ridge Frequency Estimation\"},\"content\":\"$2a\"},{\"page_plan\":{\"id\":\"3.1.4\",\"title\":\"Ridge Filter Enhancement\"},\"content\":\"$2b\"},{\"page_plan\":{\"id\":\"3.1.5\",\"title\":\"FFT-Based Enhancement\"},\"content\":\"$2c\"},{\"page_plan\":{\"id\":\"3.1.6\",\"title\":\"Angular Filter Banks\"},\"content\":\"$2d\"},{\"page_plan\":{\"id\":\"3.1.7\",\"title\":\"Supporting Utility Functions\"},\"content\":\"$2e\"},{\"page_plan\":{\"id\":\"3.2\",\"title\":\"Fingerprint Matching\"},\"content\":\"$2f\"},{\"page_plan\":{\"id\":\"3.2.1\",\"title\":\"Match Algorithm\"},\"content\":\"$30\"},{\"page_plan\":{\"id\":\"3.2.2\",\"title\":\"Similarity Scoring\"},\"content\":\"$31\"}]},\"children\":\"$L32\"}]}]\n"])</script><script>self.__next_f.push([1,"6:[[\"$\",\"script\",null,{\"type\":\"application/ld+json\",\"dangerouslySetInnerHTML\":{\"__html\":\"{\\\"@context\\\":\\\"https://schema.org\\\",\\\"@type\\\":\\\"TechArticle\\\",\\\"headline\\\":\\\"Key Expansion\\\",\\\"description\\\":\\\"This document explains the AES key expansion algorithm implemented in $1. The key expansion process transforms an original cipher key (128, 192, or 256 bits) into a schedule of round keys used during \\\",\\\"image\\\":\\\"https://deepwiki.com/QinMoMeak/Simple_FingerPrint_Matching/og-image.png\\\",\\\"datePublished\\\":\\\"2026-02-19T03:40:37.381719\\\",\\\"dateModified\\\":\\\"2026-02-19T03:40:37.381719\\\",\\\"author\\\":{\\\"@type\\\":\\\"Organization\\\",\\\"name\\\":\\\"DeepWiki\\\",\\\"url\\\":\\\"https://deepwiki.com\\\"},\\\"publisher\\\":{\\\"@type\\\":\\\"Organization\\\",\\\"name\\\":\\\"DeepWiki\\\",\\\"logo\\\":{\\\"@type\\\":\\\"ImageObject\\\",\\\"url\\\":\\\"https://deepwiki.com/icon.png\\\"}},\\\"mainEntityOfPage\\\":{\\\"@type\\\":\\\"WebPage\\\",\\\"@id\\\":\\\"https://deepwiki.com/QinMoMeak/Simple_FingerPrint_Matching/2.1-key-expansion\\\"}}\"}}],[\"$\",\"$L3\",null,{\"parallelRouterKey\":\"children\",\"error\":\"$undefined\",\"errorStyles\":\"$undefined\",\"errorScripts\":\"$undefined\",\"template\":[\"$\",\"$L4\",null,{}],\"templateStyles\":\"$undefined\",\"templateScripts\":\"$undefined\",\"notFound\":\"$undefined\",\"forbidden\":\"$undefined\",\"unauthorized\":\"$undefined\"}]]\n"])</script><script>self.__next_f.push([1,"e:{\"metadata\":[[\"$\",\"title\",\"0\",{\"children\":\"Key Expansion | QinMoMeak/Simple_FingerPrint_Matching | DeepWiki\"}],[\"$\",\"meta\",\"1\",{\"name\":\"description\",\"content\":\"This document explains the AES key expansion algorithm implemented in $1. The key expansion process transforms an original cipher key (128, 192, or 256 bits) into a schedule of round keys used during \"}],[\"$\",\"meta\",\"2\",{\"name\":\"keywords\",\"content\":\"QinMoMeak/Simple_FingerPrint_Matching,QinMoMeak,Simple_FingerPrint_Matching,documentation,wiki,codebase,AI documentation,Devin,Key Expansion\"}],[\"$\",\"link\",\"3\",{\"rel\":\"canonical\",\"href\":\"https://deepwiki.com/QinMoMeak/Simple_FingerPrint_Matching/2.1-key-expansion\"}],[\"$\",\"meta\",\"4\",{\"property\":\"og:title\",\"content\":\"Key Expansion | QinMoMeak/Simple_FingerPrint_Matching | DeepWiki\"}],[\"$\",\"meta\",\"5\",{\"property\":\"og:description\",\"content\":\"This document explains the AES key expansion algorithm implemented in $1. The key expansion process transforms an original cipher key (128, 192, or 256 bits) into a schedule of round keys used during \"}],[\"$\",\"meta\",\"6\",{\"property\":\"og:url\",\"content\":\"https://deepwiki.com/QinMoMeak/Simple_FingerPrint_Matching/2.1-key-expansion\"}],[\"$\",\"meta\",\"7\",{\"property\":\"og:site_name\",\"content\":\"DeepWiki\"}],[\"$\",\"meta\",\"8\",{\"property\":\"og:image\",\"content\":\"https://deepwiki.com/QinMoMeak/Simple_FingerPrint_Matching/og-image.png?page=2.1\"}],[\"$\",\"meta\",\"9\",{\"property\":\"og:type\",\"content\":\"website\"}],[\"$\",\"meta\",\"10\",{\"name\":\"twitter:card\",\"content\":\"summary_large_image\"}],[\"$\",\"meta\",\"11\",{\"name\":\"twitter:site\",\"content\":\"@cognition\"}],[\"$\",\"meta\",\"12\",{\"name\":\"twitter:creator\",\"content\":\"@cognition\"}],[\"$\",\"meta\",\"13\",{\"name\":\"twitter:title\",\"content\":\"Key Expansion | QinMoMeak/Simple_FingerPrint_Matching | DeepWiki\"}],[\"$\",\"meta\",\"14\",{\"name\":\"twitter:description\",\"content\":\"This document explains the AES key expansion algorithm implemented in $1. The key expansion process transforms an original cipher key (128, 192, or 256 bits) into a schedule of round keys used during \"}],[\"$\",\"meta\",\"15\",{\"name\":\"twitter:image\",\"content\":\"https://deepwiki.com/QinMoMeak/Simple_FingerPrint_Matching/og-image.png?page=2.1\"}],[\"$\",\"link\",\"16\",{\"rel\":\"icon\",\"href\":\"/favicon.ico\",\"type\":\"image/x-icon\",\"sizes\":\"48x48\"}],[\"$\",\"link\",\"17\",{\"rel\":\"icon\",\"href\":\"/icon.png?1ee4c6a68a73a205\",\"type\":\"image/png\",\"sizes\":\"48x48\"}],[\"$\",\"link\",\"18\",{\"rel\":\"apple-touch-icon\",\"href\":\"/apple-icon.png?a4f658907db0ab87\",\"type\":\"image/png\",\"sizes\":\"180x180\"}],[\"$\",\"$L33\",\"19\",{}]],\"error\":null,\"digest\":\"$undefined\"}\n"])</script><script>self.__next_f.push([1,"13:\"$e:metadata\"\n"])</script><script>self.__next_f.push([1,"32:[\"$\",\"$L3\",null,{\"parallelRouterKey\":\"children\",\"error\":\"$undefined\",\"errorStyles\":\"$undefined\",\"errorScripts\":\"$undefined\",\"template\":[\"$\",\"$L4\",null,{}],\"templateStyles\":\"$undefined\",\"templateScripts\":\"$undefined\",\"notFound\":\"$undefined\",\"forbidden\":\"$undefined\",\"unauthorized\":\"$undefined\"}]\n"])</script></body></html>